                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 4.2.0 #13081 (MINGW64)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _eebyter
                                     13 	.globl _eebytew
                                     14 	.globl _eereset
                                     15 	.globl _RepeatedStartI2c
                                     16 	.globl _I2C_Stop
                                     17 	.globl _I2C_ReStart
                                     18 	.globl _I2C_Send_NACK
                                     19 	.globl _I2C_Read_Byte
                                     20 	.globl _I2C_Write_Byte
                                     21 	.globl _I2C_Start
                                     22 	.globl _I2C_init
                                     23 	.globl _delay
                                     24 	.globl _printf
                                     25 	.globl _CY
                                     26 	.globl _AC
                                     27 	.globl _F0
                                     28 	.globl _RS1
                                     29 	.globl _RS0
                                     30 	.globl _OV
                                     31 	.globl _F1
                                     32 	.globl _P
                                     33 	.globl _PS
                                     34 	.globl _PT1
                                     35 	.globl _PX1
                                     36 	.globl _PT0
                                     37 	.globl _PX0
                                     38 	.globl _RD
                                     39 	.globl _WR
                                     40 	.globl _T1
                                     41 	.globl _T0
                                     42 	.globl _INT1
                                     43 	.globl _INT0
                                     44 	.globl _TXD
                                     45 	.globl _RXD
                                     46 	.globl _P3_7
                                     47 	.globl _P3_6
                                     48 	.globl _P3_5
                                     49 	.globl _P3_4
                                     50 	.globl _P3_3
                                     51 	.globl _P3_2
                                     52 	.globl _P3_1
                                     53 	.globl _P3_0
                                     54 	.globl _EA
                                     55 	.globl _ES
                                     56 	.globl _ET1
                                     57 	.globl _EX1
                                     58 	.globl _ET0
                                     59 	.globl _EX0
                                     60 	.globl _P2_7
                                     61 	.globl _P2_6
                                     62 	.globl _P2_5
                                     63 	.globl _P2_4
                                     64 	.globl _P2_3
                                     65 	.globl _P2_2
                                     66 	.globl _P2_1
                                     67 	.globl _P2_0
                                     68 	.globl _SM0
                                     69 	.globl _SM1
                                     70 	.globl _SM2
                                     71 	.globl _REN
                                     72 	.globl _TB8
                                     73 	.globl _RB8
                                     74 	.globl _TI
                                     75 	.globl _RI
                                     76 	.globl _P1_7
                                     77 	.globl _P1_6
                                     78 	.globl _P1_5
                                     79 	.globl _P1_4
                                     80 	.globl _P1_3
                                     81 	.globl _P1_2
                                     82 	.globl _P1_1
                                     83 	.globl _P1_0
                                     84 	.globl _TF1
                                     85 	.globl _TR1
                                     86 	.globl _TF0
                                     87 	.globl _TR0
                                     88 	.globl _IE1
                                     89 	.globl _IT1
                                     90 	.globl _IE0
                                     91 	.globl _IT0
                                     92 	.globl _P0_7
                                     93 	.globl _P0_6
                                     94 	.globl _P0_5
                                     95 	.globl _P0_4
                                     96 	.globl _P0_3
                                     97 	.globl _P0_2
                                     98 	.globl _P0_1
                                     99 	.globl _P0_0
                                    100 	.globl _TF2
                                    101 	.globl _EXF2
                                    102 	.globl _RCLK
                                    103 	.globl _TCLK
                                    104 	.globl _EXEN2
                                    105 	.globl _TR2
                                    106 	.globl _C_T2
                                    107 	.globl _CP_RL2
                                    108 	.globl _T2CON_7
                                    109 	.globl _T2CON_6
                                    110 	.globl _T2CON_5
                                    111 	.globl _T2CON_4
                                    112 	.globl _T2CON_3
                                    113 	.globl _T2CON_2
                                    114 	.globl _T2CON_1
                                    115 	.globl _T2CON_0
                                    116 	.globl _PT2
                                    117 	.globl _ET2
                                    118 	.globl _TXD0
                                    119 	.globl _RXD0
                                    120 	.globl _BREG_F7
                                    121 	.globl _BREG_F6
                                    122 	.globl _BREG_F5
                                    123 	.globl _BREG_F4
                                    124 	.globl _BREG_F3
                                    125 	.globl _BREG_F2
                                    126 	.globl _BREG_F1
                                    127 	.globl _BREG_F0
                                    128 	.globl _P5_7
                                    129 	.globl _P5_6
                                    130 	.globl _P5_5
                                    131 	.globl _P5_4
                                    132 	.globl _P5_3
                                    133 	.globl _P5_2
                                    134 	.globl _P5_1
                                    135 	.globl _P5_0
                                    136 	.globl _P4_7
                                    137 	.globl _P4_6
                                    138 	.globl _P4_5
                                    139 	.globl _P4_4
                                    140 	.globl _P4_3
                                    141 	.globl _P4_2
                                    142 	.globl _P4_1
                                    143 	.globl _P4_0
                                    144 	.globl _PX0L
                                    145 	.globl _PT0L
                                    146 	.globl _PX1L
                                    147 	.globl _PT1L
                                    148 	.globl _PSL
                                    149 	.globl _PT2L
                                    150 	.globl _PPCL
                                    151 	.globl _EC
                                    152 	.globl _CCF0
                                    153 	.globl _CCF1
                                    154 	.globl _CCF2
                                    155 	.globl _CCF3
                                    156 	.globl _CCF4
                                    157 	.globl _CR
                                    158 	.globl _CF
                                    159 	.globl _B
                                    160 	.globl _ACC
                                    161 	.globl _PSW
                                    162 	.globl _IP
                                    163 	.globl _P3
                                    164 	.globl _IE
                                    165 	.globl _P2
                                    166 	.globl _SBUF
                                    167 	.globl _SCON
                                    168 	.globl _P1
                                    169 	.globl _TH1
                                    170 	.globl _TH0
                                    171 	.globl _TL1
                                    172 	.globl _TL0
                                    173 	.globl _TMOD
                                    174 	.globl _TCON
                                    175 	.globl _PCON
                                    176 	.globl _DPH
                                    177 	.globl _DPL
                                    178 	.globl _SP
                                    179 	.globl _P0
                                    180 	.globl _TH2
                                    181 	.globl _TL2
                                    182 	.globl _RCAP2H
                                    183 	.globl _RCAP2L
                                    184 	.globl _T2CON
                                    185 	.globl _SBUF0
                                    186 	.globl _DP0L
                                    187 	.globl _DP0H
                                    188 	.globl _EECON
                                    189 	.globl _KBF
                                    190 	.globl _KBE
                                    191 	.globl _KBLS
                                    192 	.globl _BRL
                                    193 	.globl _BDRCON
                                    194 	.globl _T2MOD
                                    195 	.globl _SPDAT
                                    196 	.globl _SPSTA
                                    197 	.globl _SPCON
                                    198 	.globl _SADEN
                                    199 	.globl _SADDR
                                    200 	.globl _WDTPRG
                                    201 	.globl _WDTRST
                                    202 	.globl _P5
                                    203 	.globl _P4
                                    204 	.globl _IPH1
                                    205 	.globl _IPL1
                                    206 	.globl _IPH0
                                    207 	.globl _IPL0
                                    208 	.globl _IEN1
                                    209 	.globl _IEN0
                                    210 	.globl _CMOD
                                    211 	.globl _CL
                                    212 	.globl _CH
                                    213 	.globl _CCON
                                    214 	.globl _CCAPM4
                                    215 	.globl _CCAPM3
                                    216 	.globl _CCAPM2
                                    217 	.globl _CCAPM1
                                    218 	.globl _CCAPM0
                                    219 	.globl _CCAP4L
                                    220 	.globl _CCAP3L
                                    221 	.globl _CCAP2L
                                    222 	.globl _CCAP1L
                                    223 	.globl _CCAP0L
                                    224 	.globl _CCAP4H
                                    225 	.globl _CCAP3H
                                    226 	.globl _CCAP2H
                                    227 	.globl _CCAP1H
                                    228 	.globl _CCAP0H
                                    229 	.globl _CKCON1
                                    230 	.globl _CKCON0
                                    231 	.globl _CKRL
                                    232 	.globl _AUXR1
                                    233 	.globl _AUXR
                                    234 	.globl _eebytew_PARM_2
                                    235 	.globl _getchar
                                    236 	.globl _putchar
                                    237 ;--------------------------------------------------------
                                    238 ; special function registers
                                    239 ;--------------------------------------------------------
                                    240 	.area RSEG    (ABS,DATA)
      000000                        241 	.org 0x0000
                           00008E   242 _AUXR	=	0x008e
                           0000A2   243 _AUXR1	=	0x00a2
                           000097   244 _CKRL	=	0x0097
                           00008F   245 _CKCON0	=	0x008f
                           0000AF   246 _CKCON1	=	0x00af
                           0000FA   247 _CCAP0H	=	0x00fa
                           0000FB   248 _CCAP1H	=	0x00fb
                           0000FC   249 _CCAP2H	=	0x00fc
                           0000FD   250 _CCAP3H	=	0x00fd
                           0000FE   251 _CCAP4H	=	0x00fe
                           0000EA   252 _CCAP0L	=	0x00ea
                           0000EB   253 _CCAP1L	=	0x00eb
                           0000EC   254 _CCAP2L	=	0x00ec
                           0000ED   255 _CCAP3L	=	0x00ed
                           0000EE   256 _CCAP4L	=	0x00ee
                           0000DA   257 _CCAPM0	=	0x00da
                           0000DB   258 _CCAPM1	=	0x00db
                           0000DC   259 _CCAPM2	=	0x00dc
                           0000DD   260 _CCAPM3	=	0x00dd
                           0000DE   261 _CCAPM4	=	0x00de
                           0000D8   262 _CCON	=	0x00d8
                           0000F9   263 _CH	=	0x00f9
                           0000E9   264 _CL	=	0x00e9
                           0000D9   265 _CMOD	=	0x00d9
                           0000A8   266 _IEN0	=	0x00a8
                           0000B1   267 _IEN1	=	0x00b1
                           0000B8   268 _IPL0	=	0x00b8
                           0000B7   269 _IPH0	=	0x00b7
                           0000B2   270 _IPL1	=	0x00b2
                           0000B3   271 _IPH1	=	0x00b3
                           0000C0   272 _P4	=	0x00c0
                           0000E8   273 _P5	=	0x00e8
                           0000A6   274 _WDTRST	=	0x00a6
                           0000A7   275 _WDTPRG	=	0x00a7
                           0000A9   276 _SADDR	=	0x00a9
                           0000B9   277 _SADEN	=	0x00b9
                           0000C3   278 _SPCON	=	0x00c3
                           0000C4   279 _SPSTA	=	0x00c4
                           0000C5   280 _SPDAT	=	0x00c5
                           0000C9   281 _T2MOD	=	0x00c9
                           00009B   282 _BDRCON	=	0x009b
                           00009A   283 _BRL	=	0x009a
                           00009C   284 _KBLS	=	0x009c
                           00009D   285 _KBE	=	0x009d
                           00009E   286 _KBF	=	0x009e
                           0000D2   287 _EECON	=	0x00d2
                           000083   288 _DP0H	=	0x0083
                           000082   289 _DP0L	=	0x0082
                           000099   290 _SBUF0	=	0x0099
                           0000C8   291 _T2CON	=	0x00c8
                           0000CA   292 _RCAP2L	=	0x00ca
                           0000CB   293 _RCAP2H	=	0x00cb
                           0000CC   294 _TL2	=	0x00cc
                           0000CD   295 _TH2	=	0x00cd
                           000080   296 _P0	=	0x0080
                           000081   297 _SP	=	0x0081
                           000082   298 _DPL	=	0x0082
                           000083   299 _DPH	=	0x0083
                           000087   300 _PCON	=	0x0087
                           000088   301 _TCON	=	0x0088
                           000089   302 _TMOD	=	0x0089
                           00008A   303 _TL0	=	0x008a
                           00008B   304 _TL1	=	0x008b
                           00008C   305 _TH0	=	0x008c
                           00008D   306 _TH1	=	0x008d
                           000090   307 _P1	=	0x0090
                           000098   308 _SCON	=	0x0098
                           000099   309 _SBUF	=	0x0099
                           0000A0   310 _P2	=	0x00a0
                           0000A8   311 _IE	=	0x00a8
                           0000B0   312 _P3	=	0x00b0
                           0000B8   313 _IP	=	0x00b8
                           0000D0   314 _PSW	=	0x00d0
                           0000E0   315 _ACC	=	0x00e0
                           0000F0   316 _B	=	0x00f0
                                    317 ;--------------------------------------------------------
                                    318 ; special function bits
                                    319 ;--------------------------------------------------------
                                    320 	.area RSEG    (ABS,DATA)
      000000                        321 	.org 0x0000
                           0000DF   322 _CF	=	0x00df
                           0000DE   323 _CR	=	0x00de
                           0000DC   324 _CCF4	=	0x00dc
                           0000DB   325 _CCF3	=	0x00db
                           0000DA   326 _CCF2	=	0x00da
                           0000D9   327 _CCF1	=	0x00d9
                           0000D8   328 _CCF0	=	0x00d8
                           0000AE   329 _EC	=	0x00ae
                           0000BE   330 _PPCL	=	0x00be
                           0000BD   331 _PT2L	=	0x00bd
                           0000BC   332 _PSL	=	0x00bc
                           0000BB   333 _PT1L	=	0x00bb
                           0000BA   334 _PX1L	=	0x00ba
                           0000B9   335 _PT0L	=	0x00b9
                           0000B8   336 _PX0L	=	0x00b8
                           0000C0   337 _P4_0	=	0x00c0
                           0000C1   338 _P4_1	=	0x00c1
                           0000C2   339 _P4_2	=	0x00c2
                           0000C3   340 _P4_3	=	0x00c3
                           0000C4   341 _P4_4	=	0x00c4
                           0000C5   342 _P4_5	=	0x00c5
                           0000C6   343 _P4_6	=	0x00c6
                           0000C7   344 _P4_7	=	0x00c7
                           0000E8   345 _P5_0	=	0x00e8
                           0000E9   346 _P5_1	=	0x00e9
                           0000EA   347 _P5_2	=	0x00ea
                           0000EB   348 _P5_3	=	0x00eb
                           0000EC   349 _P5_4	=	0x00ec
                           0000ED   350 _P5_5	=	0x00ed
                           0000EE   351 _P5_6	=	0x00ee
                           0000EF   352 _P5_7	=	0x00ef
                           0000F0   353 _BREG_F0	=	0x00f0
                           0000F1   354 _BREG_F1	=	0x00f1
                           0000F2   355 _BREG_F2	=	0x00f2
                           0000F3   356 _BREG_F3	=	0x00f3
                           0000F4   357 _BREG_F4	=	0x00f4
                           0000F5   358 _BREG_F5	=	0x00f5
                           0000F6   359 _BREG_F6	=	0x00f6
                           0000F7   360 _BREG_F7	=	0x00f7
                           0000B0   361 _RXD0	=	0x00b0
                           0000B1   362 _TXD0	=	0x00b1
                           0000AD   363 _ET2	=	0x00ad
                           0000BD   364 _PT2	=	0x00bd
                           0000C8   365 _T2CON_0	=	0x00c8
                           0000C9   366 _T2CON_1	=	0x00c9
                           0000CA   367 _T2CON_2	=	0x00ca
                           0000CB   368 _T2CON_3	=	0x00cb
                           0000CC   369 _T2CON_4	=	0x00cc
                           0000CD   370 _T2CON_5	=	0x00cd
                           0000CE   371 _T2CON_6	=	0x00ce
                           0000CF   372 _T2CON_7	=	0x00cf
                           0000C8   373 _CP_RL2	=	0x00c8
                           0000C9   374 _C_T2	=	0x00c9
                           0000CA   375 _TR2	=	0x00ca
                           0000CB   376 _EXEN2	=	0x00cb
                           0000CC   377 _TCLK	=	0x00cc
                           0000CD   378 _RCLK	=	0x00cd
                           0000CE   379 _EXF2	=	0x00ce
                           0000CF   380 _TF2	=	0x00cf
                           000080   381 _P0_0	=	0x0080
                           000081   382 _P0_1	=	0x0081
                           000082   383 _P0_2	=	0x0082
                           000083   384 _P0_3	=	0x0083
                           000084   385 _P0_4	=	0x0084
                           000085   386 _P0_5	=	0x0085
                           000086   387 _P0_6	=	0x0086
                           000087   388 _P0_7	=	0x0087
                           000088   389 _IT0	=	0x0088
                           000089   390 _IE0	=	0x0089
                           00008A   391 _IT1	=	0x008a
                           00008B   392 _IE1	=	0x008b
                           00008C   393 _TR0	=	0x008c
                           00008D   394 _TF0	=	0x008d
                           00008E   395 _TR1	=	0x008e
                           00008F   396 _TF1	=	0x008f
                           000090   397 _P1_0	=	0x0090
                           000091   398 _P1_1	=	0x0091
                           000092   399 _P1_2	=	0x0092
                           000093   400 _P1_3	=	0x0093
                           000094   401 _P1_4	=	0x0094
                           000095   402 _P1_5	=	0x0095
                           000096   403 _P1_6	=	0x0096
                           000097   404 _P1_7	=	0x0097
                           000098   405 _RI	=	0x0098
                           000099   406 _TI	=	0x0099
                           00009A   407 _RB8	=	0x009a
                           00009B   408 _TB8	=	0x009b
                           00009C   409 _REN	=	0x009c
                           00009D   410 _SM2	=	0x009d
                           00009E   411 _SM1	=	0x009e
                           00009F   412 _SM0	=	0x009f
                           0000A0   413 _P2_0	=	0x00a0
                           0000A1   414 _P2_1	=	0x00a1
                           0000A2   415 _P2_2	=	0x00a2
                           0000A3   416 _P2_3	=	0x00a3
                           0000A4   417 _P2_4	=	0x00a4
                           0000A5   418 _P2_5	=	0x00a5
                           0000A6   419 _P2_6	=	0x00a6
                           0000A7   420 _P2_7	=	0x00a7
                           0000A8   421 _EX0	=	0x00a8
                           0000A9   422 _ET0	=	0x00a9
                           0000AA   423 _EX1	=	0x00aa
                           0000AB   424 _ET1	=	0x00ab
                           0000AC   425 _ES	=	0x00ac
                           0000AF   426 _EA	=	0x00af
                           0000B0   427 _P3_0	=	0x00b0
                           0000B1   428 _P3_1	=	0x00b1
                           0000B2   429 _P3_2	=	0x00b2
                           0000B3   430 _P3_3	=	0x00b3
                           0000B4   431 _P3_4	=	0x00b4
                           0000B5   432 _P3_5	=	0x00b5
                           0000B6   433 _P3_6	=	0x00b6
                           0000B7   434 _P3_7	=	0x00b7
                           0000B0   435 _RXD	=	0x00b0
                           0000B1   436 _TXD	=	0x00b1
                           0000B2   437 _INT0	=	0x00b2
                           0000B3   438 _INT1	=	0x00b3
                           0000B4   439 _T0	=	0x00b4
                           0000B5   440 _T1	=	0x00b5
                           0000B6   441 _WR	=	0x00b6
                           0000B7   442 _RD	=	0x00b7
                           0000B8   443 _PX0	=	0x00b8
                           0000B9   444 _PT0	=	0x00b9
                           0000BA   445 _PX1	=	0x00ba
                           0000BB   446 _PT1	=	0x00bb
                           0000BC   447 _PS	=	0x00bc
                           0000D0   448 _P	=	0x00d0
                           0000D1   449 _F1	=	0x00d1
                           0000D2   450 _OV	=	0x00d2
                           0000D3   451 _RS0	=	0x00d3
                           0000D4   452 _RS1	=	0x00d4
                           0000D5   453 _F0	=	0x00d5
                           0000D6   454 _AC	=	0x00d6
                           0000D7   455 _CY	=	0x00d7
                                    456 ;--------------------------------------------------------
                                    457 ; overlayable register banks
                                    458 ;--------------------------------------------------------
                                    459 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        460 	.ds 8
                                    461 ;--------------------------------------------------------
                                    462 ; internal ram data
                                    463 ;--------------------------------------------------------
                                    464 	.area DSEG    (DATA)
      000000                        465 _eebytew_PARM_2:
      000000                        466 	.ds 1
      000001                        467 _main_addr_131072_95:
      000001                        468 	.ds 2
      000003                        469 _main_addr1_131072_95:
      000003                        470 	.ds 2
      000005                        471 _main_start_addr_131072_95:
      000005                        472 	.ds 2
      000007                        473 _main_end_addr_131072_95:
      000007                        474 	.ds 2
      000009                        475 _main_data_131072_95:
      000009                        476 	.ds 2
                                    477 ;--------------------------------------------------------
                                    478 ; overlayable items in internal ram
                                    479 ;--------------------------------------------------------
                                    480 	.area	OSEG    (OVR,DATA)
                                    481 	.area	OSEG    (OVR,DATA)
                                    482 ;--------------------------------------------------------
                                    483 ; Stack segment in internal ram
                                    484 ;--------------------------------------------------------
                                    485 	.area	SSEG
      000000                        486 __start__stack:
      000000                        487 	.ds	1
                                    488 
                                    489 ;--------------------------------------------------------
                                    490 ; indirectly addressable internal ram data
                                    491 ;--------------------------------------------------------
                                    492 	.area ISEG    (DATA)
                                    493 ;--------------------------------------------------------
                                    494 ; absolute internal ram data
                                    495 ;--------------------------------------------------------
                                    496 	.area IABS    (ABS,DATA)
                                    497 	.area IABS    (ABS,DATA)
                                    498 ;--------------------------------------------------------
                                    499 ; bit data
                                    500 ;--------------------------------------------------------
                                    501 	.area BSEG    (BIT)
      000000                        502 _eebyter_sloc0_1_0:
      000000                        503 	.ds 1
                                    504 ;--------------------------------------------------------
                                    505 ; paged external ram data
                                    506 ;--------------------------------------------------------
                                    507 	.area PSEG    (PAG,XDATA)
                                    508 ;--------------------------------------------------------
                                    509 ; external ram data
                                    510 ;--------------------------------------------------------
                                    511 	.area XSEG    (XDATA)
                                    512 ;--------------------------------------------------------
                                    513 ; absolute external ram data
                                    514 ;--------------------------------------------------------
                                    515 	.area XABS    (ABS,XDATA)
                                    516 ;--------------------------------------------------------
                                    517 ; external initialized ram data
                                    518 ;--------------------------------------------------------
                                    519 	.area XISEG   (XDATA)
                                    520 	.area HOME    (CODE)
                                    521 	.area GSINIT0 (CODE)
                                    522 	.area GSINIT1 (CODE)
                                    523 	.area GSINIT2 (CODE)
                                    524 	.area GSINIT3 (CODE)
                                    525 	.area GSINIT4 (CODE)
                                    526 	.area GSINIT5 (CODE)
                                    527 	.area GSINIT  (CODE)
                                    528 	.area GSFINAL (CODE)
                                    529 	.area CSEG    (CODE)
                                    530 ;--------------------------------------------------------
                                    531 ; interrupt vector
                                    532 ;--------------------------------------------------------
                                    533 	.area HOME    (CODE)
      000000                        534 __interrupt_vect:
      000000 02r00r00         [24]  535 	ljmp	__sdcc_gsinit_startup
                                    536 ;--------------------------------------------------------
                                    537 ; global & static initialisations
                                    538 ;--------------------------------------------------------
                                    539 	.area HOME    (CODE)
                                    540 	.area GSINIT  (CODE)
                                    541 	.area GSFINAL (CODE)
                                    542 	.area GSINIT  (CODE)
                                    543 	.globl __sdcc_gsinit_startup
                                    544 	.globl __sdcc_program_startup
                                    545 	.globl __start__stack
                                    546 	.globl __mcs51_genXINIT
                                    547 	.globl __mcs51_genXRAMCLEAR
                                    548 	.globl __mcs51_genRAMCLEAR
                                    549 	.area GSFINAL (CODE)
      000000 02r00r03         [24]  550 	ljmp	__sdcc_program_startup
                                    551 ;--------------------------------------------------------
                                    552 ; Home
                                    553 ;--------------------------------------------------------
                                    554 	.area HOME    (CODE)
                                    555 	.area HOME    (CODE)
      000003                        556 __sdcc_program_startup:
      000003 02r04r15         [24]  557 	ljmp	_main
                                    558 ;	return from main will return to caller
                                    559 ;--------------------------------------------------------
                                    560 ; code
                                    561 ;--------------------------------------------------------
                                    562 	.area CSEG    (CODE)
                                    563 ;------------------------------------------------------------
                                    564 ;Allocation info for local variables in function 'getchar'
                                    565 ;------------------------------------------------------------
                                    566 ;	main.c:17: int getchar (void)
                                    567 ;	-----------------------------------------
                                    568 ;	 function getchar
                                    569 ;	-----------------------------------------
      000000                        570 _getchar:
                           000007   571 	ar7 = 0x07
                           000006   572 	ar6 = 0x06
                           000005   573 	ar5 = 0x05
                           000004   574 	ar4 = 0x04
                           000003   575 	ar3 = 0x03
                           000002   576 	ar2 = 0x02
                           000001   577 	ar1 = 0x01
                           000000   578 	ar0 = 0x00
                                    579 ;	main.c:19: while (!RI);
      000000                        580 00101$:
                                    581 ;	main.c:21: RI = 0;                         // clear RI flag
                                    582 ;	assignBit
      000000 10 98 02         [24]  583 	jbc	_RI,00114$
      000003 80 FB            [24]  584 	sjmp	00101$
      000005                        585 00114$:
                                    586 ;	main.c:22: return SBUF;                    // return character from SBUF
      000005 AE 99            [24]  587 	mov	r6,_SBUF
      000007 7F 00            [12]  588 	mov	r7,#0x00
      000009 8E 82            [24]  589 	mov	dpl,r6
      00000B 8F 83            [24]  590 	mov	dph,r7
                                    591 ;	main.c:23: }
      00000D 22               [24]  592 	ret
                                    593 ;------------------------------------------------------------
                                    594 ;Allocation info for local variables in function 'putchar'
                                    595 ;------------------------------------------------------------
                                    596 ;c                         Allocated to registers r6 r7 
                                    597 ;------------------------------------------------------------
                                    598 ;	main.c:25: int putchar (int c)
                                    599 ;	-----------------------------------------
                                    600 ;	 function putchar
                                    601 ;	-----------------------------------------
      00000E                        602 _putchar:
      00000E AE 82            [24]  603 	mov	r6,dpl
      000010 AF 83            [24]  604 	mov	r7,dph
                                    605 ;	main.c:27: while (!TI);
      000012                        606 00101$:
      000012 30 99 FD         [24]  607 	jnb	_TI,00101$
                                    608 ;	main.c:29: SBUF = c;           // load serial port with transmit value
      000015 8E 99            [24]  609 	mov	_SBUF,r6
                                    610 ;	main.c:30: TI = 0;             // clear TI flag
                                    611 ;	assignBit
      000017 C2 99            [12]  612 	clr	_TI
                                    613 ;	main.c:32: return c;
      000019 8E 82            [24]  614 	mov	dpl,r6
      00001B 8F 83            [24]  615 	mov	dph,r7
                                    616 ;	main.c:33: }
      00001D 22               [24]  617 	ret
                                    618 ;------------------------------------------------------------
                                    619 ;Allocation info for local variables in function 'delay'
                                    620 ;------------------------------------------------------------
                                    621 ;count                     Allocated to registers r6 r7 
                                    622 ;i                         Allocated to registers r4 r5 
                                    623 ;------------------------------------------------------------
                                    624 ;	main.c:36: void delay(unsigned int count)
                                    625 ;	-----------------------------------------
                                    626 ;	 function delay
                                    627 ;	-----------------------------------------
      00001E                        628 _delay:
      00001E AE 82            [24]  629 	mov	r6,dpl
      000020 AF 83            [24]  630 	mov	r7,dph
                                    631 ;	main.c:39: for(i=0;i<count;i++);
      000022 7C 00            [12]  632 	mov	r4,#0x00
      000024 7D 00            [12]  633 	mov	r5,#0x00
      000026                        634 00103$:
      000026 C3               [12]  635 	clr	c
      000027 EC               [12]  636 	mov	a,r4
      000028 9E               [12]  637 	subb	a,r6
      000029 ED               [12]  638 	mov	a,r5
      00002A 9F               [12]  639 	subb	a,r7
      00002B 50 07            [24]  640 	jnc	00105$
      00002D 0C               [12]  641 	inc	r4
      00002E BC 00 F5         [24]  642 	cjne	r4,#0x00,00103$
      000031 0D               [12]  643 	inc	r5
      000032 80 F2            [24]  644 	sjmp	00103$
      000034                        645 00105$:
                                    646 ;	main.c:40: }
      000034 22               [24]  647 	ret
                                    648 ;------------------------------------------------------------
                                    649 ;Allocation info for local variables in function 'I2C_init'
                                    650 ;------------------------------------------------------------
                                    651 ;	main.c:44: void I2C_init(void)
                                    652 ;	-----------------------------------------
                                    653 ;	 function I2C_init
                                    654 ;	-----------------------------------------
      000035                        655 _I2C_init:
                                    656 ;	main.c:47: SDA = 1;
                                    657 ;	assignBit
      000035 D2 97            [12]  658 	setb	_P1_7
                                    659 ;	main.c:48: SCL = 1;
                                    660 ;	assignBit
      000037 D2 96            [12]  661 	setb	_P1_6
                                    662 ;	main.c:49: }
      000039 22               [24]  663 	ret
                                    664 ;------------------------------------------------------------
                                    665 ;Allocation info for local variables in function 'I2C_Start'
                                    666 ;------------------------------------------------------------
                                    667 ;	main.c:52: void I2C_Start(void)
                                    668 ;	-----------------------------------------
                                    669 ;	 function I2C_Start
                                    670 ;	-----------------------------------------
      00003A                        671 _I2C_Start:
                                    672 ;	main.c:54: set_SCL_high;				// Make SCL pin high
                                    673 ;	assignBit
      00003A D2 96            [12]  674 	setb	_P1_6
                                    675 ;	main.c:55: set_SDA_high;				// Make SDA pin High
                                    676 ;	assignBit
      00003C D2 97            [12]  677 	setb	_P1_7
                                    678 ;	main.c:56: delay(50);	// Half bit delay
      00003E 90 00 32         [24]  679 	mov	dptr,#0x0032
      000041 12r00r1E         [24]  680 	lcall	_delay
                                    681 ;	main.c:57: set_SDA_low;				// Make SDA Low
                                    682 ;	assignBit
      000044 C2 97            [12]  683 	clr	_P1_7
                                    684 ;	main.c:58: delay(50);	// Half bit delay
      000046 90 00 32         [24]  685 	mov	dptr,#0x0032
                                    686 ;	main.c:59: }
      000049 02r00r1E         [24]  687 	ljmp	_delay
                                    688 ;------------------------------------------------------------
                                    689 ;Allocation info for local variables in function 'I2C_Write_Byte'
                                    690 ;------------------------------------------------------------
                                    691 ;Byte                      Allocated to registers r7 
                                    692 ;i                         Allocated to registers r6 
                                    693 ;------------------------------------------------------------
                                    694 ;	main.c:61: unsigned char I2C_Write_Byte(unsigned char Byte)
                                    695 ;	-----------------------------------------
                                    696 ;	 function I2C_Write_Byte
                                    697 ;	-----------------------------------------
      00004C                        698 _I2C_Write_Byte:
      00004C AF 82            [24]  699 	mov	r7,dpl
                                    700 ;	main.c:65: for(i=0;i<8;i++)		// Repeat for every bit
      00004E 7E 00            [12]  701 	mov	r6,#0x00
      000050                        702 00105$:
                                    703 ;	main.c:67: set_SCL_low;		// Make SCL pin low
                                    704 ;	assignBit
      000050 C2 96            [12]  705 	clr	_P1_6
                                    706 ;	main.c:69: delay(50);	// Data pin should change it's value,
      000052 90 00 32         [24]  707 	mov	dptr,#0x0032
      000055 C0 07            [24]  708 	push	ar7
      000057 C0 06            [24]  709 	push	ar6
      000059 12r00r1E         [24]  710 	lcall	_delay
      00005C D0 06            [24]  711 	pop	ar6
      00005E D0 07            [24]  712 	pop	ar7
                                    713 ;	main.c:72: if((Byte<<i)&0x80)  // Place data bit value on SDA pin
      000060 8F 04            [24]  714 	mov	ar4,r7
      000062 7D 00            [12]  715 	mov	r5,#0x00
      000064 8E F0            [24]  716 	mov	b,r6
      000066 05 F0            [12]  717 	inc	b
      000068 80 06            [24]  718 	sjmp	00123$
      00006A                        719 00122$:
      00006A EC               [12]  720 	mov	a,r4
      00006B 2C               [12]  721 	add	a,r4
      00006C FC               [12]  722 	mov	r4,a
      00006D ED               [12]  723 	mov	a,r5
      00006E 33               [12]  724 	rlc	a
      00006F FD               [12]  725 	mov	r5,a
      000070                        726 00123$:
      000070 D5 F0 F7         [24]  727 	djnz	b,00122$
      000073 EC               [12]  728 	mov	a,r4
      000074 30 E7 04         [24]  729 	jnb	acc.7,00102$
                                    730 ;	main.c:73: set_SDA_high;	// If bit is high, make SDA high
                                    731 ;	assignBit
      000077 D2 97            [12]  732 	setb	_P1_7
      000079 80 02            [24]  733 	sjmp	00103$
      00007B                        734 00102$:
                                    735 ;	main.c:75: set_SDA_low;	// If bit is low, make SDA low
                                    736 ;	assignBit
      00007B C2 97            [12]  737 	clr	_P1_7
      00007D                        738 00103$:
                                    739 ;	main.c:77: delay(50);	// Toggle SCL pin
      00007D 90 00 32         [24]  740 	mov	dptr,#0x0032
      000080 C0 07            [24]  741 	push	ar7
      000082 C0 06            [24]  742 	push	ar6
      000084 12r00r1E         [24]  743 	lcall	_delay
                                    744 ;	main.c:78: set_SCL_high;				// So that slave can
                                    745 ;	assignBit
      000087 D2 96            [12]  746 	setb	_P1_6
                                    747 ;	main.c:79: delay(50);	// latch data bit
      000089 90 00 32         [24]  748 	mov	dptr,#0x0032
      00008C 12r00r1E         [24]  749 	lcall	_delay
      00008F D0 06            [24]  750 	pop	ar6
      000091 D0 07            [24]  751 	pop	ar7
                                    752 ;	main.c:65: for(i=0;i<8;i++)		// Repeat for every bit
      000093 0E               [12]  753 	inc	r6
      000094 BE 08 00         [24]  754 	cjne	r6,#0x08,00125$
      000097                        755 00125$:
      000097 40 B7            [24]  756 	jc	00105$
                                    757 ;	main.c:83: set_SCL_low;
                                    758 ;	assignBit
      000099 C2 96            [12]  759 	clr	_P1_6
                                    760 ;	main.c:84: set_SDA_high;
                                    761 ;	assignBit
      00009B D2 97            [12]  762 	setb	_P1_7
                                    763 ;	main.c:85: delay(50);
      00009D 90 00 32         [24]  764 	mov	dptr,#0x0032
      0000A0 12r00r1E         [24]  765 	lcall	_delay
                                    766 ;	main.c:86: set_SCL_high;
                                    767 ;	assignBit
      0000A3 D2 96            [12]  768 	setb	_P1_6
                                    769 ;	main.c:87: delay(50);
      0000A5 90 00 32         [24]  770 	mov	dptr,#0x0032
      0000A8 12r00r1E         [24]  771 	lcall	_delay
                                    772 ;	main.c:89: return SDA;
      0000AB A2 97            [12]  773 	mov	c,_P1_7
      0000AD E4               [12]  774 	clr	a
      0000AE 33               [12]  775 	rlc	a
      0000AF F5 82            [12]  776 	mov	dpl,a
                                    777 ;	main.c:90: }
      0000B1 22               [24]  778 	ret
                                    779 ;------------------------------------------------------------
                                    780 ;Allocation info for local variables in function 'I2C_Read_Byte'
                                    781 ;------------------------------------------------------------
                                    782 ;i                         Allocated to registers r6 
                                    783 ;d                         Allocated to registers r5 
                                    784 ;RxData                    Allocated to registers r7 
                                    785 ;------------------------------------------------------------
                                    786 ;	main.c:93: unsigned char I2C_Read_Byte(void)
                                    787 ;	-----------------------------------------
                                    788 ;	 function I2C_Read_Byte
                                    789 ;	-----------------------------------------
      0000B2                        790 _I2C_Read_Byte:
                                    791 ;	main.c:95: unsigned char i, d, RxData = 0;
      0000B2 7F 00            [12]  792 	mov	r7,#0x00
                                    793 ;	main.c:97: for(i=0;i<8;i++)
      0000B4 7E 00            [12]  794 	mov	r6,#0x00
      0000B6                        795 00102$:
                                    796 ;	main.c:99: set_SCL_low;					// Make SCL pin low
                                    797 ;	assignBit
      0000B6 C2 96            [12]  798 	clr	_P1_6
                                    799 ;	main.c:100: set_SDA_high;					// Don't drive SDA
                                    800 ;	assignBit
      0000B8 D2 97            [12]  801 	setb	_P1_7
                                    802 ;	main.c:101: delay(50);		// Half bit delay
      0000BA 90 00 32         [24]  803 	mov	dptr,#0x0032
      0000BD C0 07            [24]  804 	push	ar7
      0000BF C0 06            [24]  805 	push	ar6
      0000C1 12r00r1E         [24]  806 	lcall	_delay
                                    807 ;	main.c:102: set_SCL_high;					// Make SCL pin high
                                    808 ;	assignBit
      0000C4 D2 96            [12]  809 	setb	_P1_6
                                    810 ;	main.c:103: delay(50);		// 1/4 bit delay
      0000C6 90 00 32         [24]  811 	mov	dptr,#0x0032
      0000C9 12r00r1E         [24]  812 	lcall	_delay
      0000CC D0 06            [24]  813 	pop	ar6
      0000CE D0 07            [24]  814 	pop	ar7
                                    815 ;	main.c:104: d = SDA;					    // Capture Received Bit
      0000D0 A2 97            [12]  816 	mov	c,_P1_7
      0000D2 E4               [12]  817 	clr	a
      0000D3 33               [12]  818 	rlc	a
      0000D4 FD               [12]  819 	mov	r5,a
                                    820 ;	main.c:105: RxData = RxData|(d<<(7-i));   	// Copy it in RxData
      0000D5 8E 04            [24]  821 	mov	ar4,r6
      0000D7 74 07            [12]  822 	mov	a,#0x07
      0000D9 C3               [12]  823 	clr	c
      0000DA 9C               [12]  824 	subb	a,r4
      0000DB FC               [12]  825 	mov	r4,a
      0000DC 8C F0            [24]  826 	mov	b,r4
      0000DE 05 F0            [12]  827 	inc	b
      0000E0 ED               [12]  828 	mov	a,r5
      0000E1 80 02            [24]  829 	sjmp	00117$
      0000E3                        830 00115$:
      0000E3 25 E0            [12]  831 	add	a,acc
      0000E5                        832 00117$:
      0000E5 D5 F0 FB         [24]  833 	djnz	b,00115$
      0000E8 42 07            [12]  834 	orl	ar7,a
                                    835 ;	main.c:106: delay(50);		// 1/4 bit delay
      0000EA 90 00 32         [24]  836 	mov	dptr,#0x0032
      0000ED C0 07            [24]  837 	push	ar7
      0000EF C0 06            [24]  838 	push	ar6
      0000F1 12r00r1E         [24]  839 	lcall	_delay
      0000F4 D0 06            [24]  840 	pop	ar6
      0000F6 D0 07            [24]  841 	pop	ar7
                                    842 ;	main.c:97: for(i=0;i<8;i++)
      0000F8 0E               [12]  843 	inc	r6
      0000F9 BE 08 00         [24]  844 	cjne	r6,#0x08,00118$
      0000FC                        845 00118$:
      0000FC 40 B8            [24]  846 	jc	00102$
                                    847 ;	main.c:109: return RxData;						// Return received byte
      0000FE 8F 82            [24]  848 	mov	dpl,r7
                                    849 ;	main.c:110: }
      000100 22               [24]  850 	ret
                                    851 ;------------------------------------------------------------
                                    852 ;Allocation info for local variables in function 'I2C_Send_NACK'
                                    853 ;------------------------------------------------------------
                                    854 ;	main.c:113: void I2C_Send_NACK(void)
                                    855 ;	-----------------------------------------
                                    856 ;	 function I2C_Send_NACK
                                    857 ;	-----------------------------------------
      000101                        858 _I2C_Send_NACK:
                                    859 ;	main.c:115: set_SCL_low;				// Make SCL pin low
                                    860 ;	assignBit
      000101 C2 96            [12]  861 	clr	_P1_6
                                    862 ;	main.c:116: delay(50);	// Data pin should change it's value,
      000103 90 00 32         [24]  863 	mov	dptr,#0x0032
      000106 12r00r1E         [24]  864 	lcall	_delay
                                    865 ;	main.c:118: set_SDA_low;				// Make SDA Low
                                    866 ;	assignBit
      000109 C2 97            [12]  867 	clr	_P1_7
                                    868 ;	main.c:119: delay(50);	// 1/4 bit delay
      00010B 90 00 32         [24]  869 	mov	dptr,#0x0032
      00010E 12r00r1E         [24]  870 	lcall	_delay
                                    871 ;	main.c:120: set_SCL_high;				// Make SCL pin high
                                    872 ;	assignBit
      000111 D2 96            [12]  873 	setb	_P1_6
                                    874 ;	main.c:121: delay(50);	// Half bit delay
      000113 90 00 32         [24]  875 	mov	dptr,#0x0032
                                    876 ;	main.c:122: }
      000116 02r00r1E         [24]  877 	ljmp	_delay
                                    878 ;------------------------------------------------------------
                                    879 ;Allocation info for local variables in function 'I2C_ReStart'
                                    880 ;------------------------------------------------------------
                                    881 ;	main.c:125: void I2C_ReStart(void)
                                    882 ;	-----------------------------------------
                                    883 ;	 function I2C_ReStart
                                    884 ;	-----------------------------------------
      000119                        885 _I2C_ReStart:
                                    886 ;	main.c:127: set_SCL_low;				// Make SCL pin low
                                    887 ;	assignBit
      000119 C2 96            [12]  888 	clr	_P1_6
                                    889 ;	main.c:129: delay(50);	// Data pin should change it's value,
      00011B 90 00 32         [24]  890 	mov	dptr,#0x0032
      00011E 12r00r1E         [24]  891 	lcall	_delay
                                    892 ;	main.c:131: set_SDA_high;				// Make SDA pin High
                                    893 ;	assignBit
      000121 D2 97            [12]  894 	setb	_P1_7
                                    895 ;	main.c:133: delay(50);	// 1/4 bit delay
      000123 90 00 32         [24]  896 	mov	dptr,#0x0032
      000126 12r00r1E         [24]  897 	lcall	_delay
                                    898 ;	main.c:134: set_SCL_high;				// Make SCL pin high
                                    899 ;	assignBit
      000129 D2 96            [12]  900 	setb	_P1_6
                                    901 ;	main.c:135: delay(50);	// 1/4 bit delay
      00012B 90 00 32         [24]  902 	mov	dptr,#0x0032
      00012E 12r00r1E         [24]  903 	lcall	_delay
                                    904 ;	main.c:136: set_SDA_low;				// Make SDA Low
                                    905 ;	assignBit
      000131 C2 97            [12]  906 	clr	_P1_7
                                    907 ;	main.c:137: delay(50);	// 1/4 bit delay
      000133 90 00 32         [24]  908 	mov	dptr,#0x0032
                                    909 ;	main.c:138: }
      000136 02r00r1E         [24]  910 	ljmp	_delay
                                    911 ;------------------------------------------------------------
                                    912 ;Allocation info for local variables in function 'I2C_Stop'
                                    913 ;------------------------------------------------------------
                                    914 ;	main.c:142: void I2C_Stop(void)
                                    915 ;	-----------------------------------------
                                    916 ;	 function I2C_Stop
                                    917 ;	-----------------------------------------
      000139                        918 _I2C_Stop:
                                    919 ;	main.c:144: set_SCL_low;				// Make SCL pin low
                                    920 ;	assignBit
      000139 C2 96            [12]  921 	clr	_P1_6
                                    922 ;	main.c:146: delay(50);	// Data pin should change it's value,
      00013B 90 00 32         [24]  923 	mov	dptr,#0x0032
      00013E 12r00r1E         [24]  924 	lcall	_delay
                                    925 ;	main.c:148: set_SDA_low;				// Make SDA pin low
                                    926 ;	assignBit
      000141 C2 97            [12]  927 	clr	_P1_7
                                    928 ;	main.c:150: delay(50);	// 1/4 bit delay
      000143 90 00 32         [24]  929 	mov	dptr,#0x0032
      000146 12r00r1E         [24]  930 	lcall	_delay
                                    931 ;	main.c:151: set_SCL_high;				// Make SCL pin high
                                    932 ;	assignBit
      000149 D2 96            [12]  933 	setb	_P1_6
                                    934 ;	main.c:152: delay(50);	// 1/4 bit delay
      00014B 90 00 32         [24]  935 	mov	dptr,#0x0032
      00014E 12r00r1E         [24]  936 	lcall	_delay
                                    937 ;	main.c:153: set_SDA_high;				// Make SDA high
                                    938 ;	assignBit
      000151 D2 97            [12]  939 	setb	_P1_7
                                    940 ;	main.c:154: delay(50);	// 1/4 bit delay
      000153 90 00 32         [24]  941 	mov	dptr,#0x0032
                                    942 ;	main.c:155: }
      000156 02r00r1E         [24]  943 	ljmp	_delay
                                    944 ;------------------------------------------------------------
                                    945 ;Allocation info for local variables in function 'RepeatedStartI2c'
                                    946 ;------------------------------------------------------------
                                    947 ;	main.c:157: void RepeatedStartI2c()
                                    948 ;	-----------------------------------------
                                    949 ;	 function RepeatedStartI2c
                                    950 ;	-----------------------------------------
      000159                        951 _RepeatedStartI2c:
                                    952 ;	main.c:159: SCL  = 0;
                                    953 ;	assignBit
      000159 C2 96            [12]  954 	clr	_P1_6
                                    955 ;	main.c:160: delay(50);
      00015B 90 00 32         [24]  956 	mov	dptr,#0x0032
      00015E 12r00r1E         [24]  957 	lcall	_delay
                                    958 ;	main.c:161: SDA  = 1;
                                    959 ;	assignBit
      000161 D2 97            [12]  960 	setb	_P1_7
                                    961 ;	main.c:162: delay(50);
      000163 90 00 32         [24]  962 	mov	dptr,#0x0032
      000166 12r00r1E         [24]  963 	lcall	_delay
                                    964 ;	main.c:163: SCL  = 1;
                                    965 ;	assignBit
      000169 D2 96            [12]  966 	setb	_P1_6
                                    967 ;	main.c:164: delay(50);
      00016B 90 00 32         [24]  968 	mov	dptr,#0x0032
      00016E 12r00r1E         [24]  969 	lcall	_delay
                                    970 ;	main.c:165: SDA  = 0;
                                    971 ;	assignBit
      000171 C2 97            [12]  972 	clr	_P1_7
                                    973 ;	main.c:166: delay(50);
      000173 90 00 32         [24]  974 	mov	dptr,#0x0032
                                    975 ;	main.c:167: }
      000176 02r00r1E         [24]  976 	ljmp	_delay
                                    977 ;------------------------------------------------------------
                                    978 ;Allocation info for local variables in function 'eereset'
                                    979 ;------------------------------------------------------------
                                    980 ;i                         Allocated to registers r6 r7 
                                    981 ;------------------------------------------------------------
                                    982 ;	main.c:169: void eereset()
                                    983 ;	-----------------------------------------
                                    984 ;	 function eereset
                                    985 ;	-----------------------------------------
      000179                        986 _eereset:
                                    987 ;	main.c:172: I2C_Start();
      000179 12r00r3A         [24]  988 	lcall	_I2C_Start
                                    989 ;	main.c:173: for (i=0;i<9; i++)
      00017C 7E 00            [12]  990 	mov	r6,#0x00
      00017E 7F 00            [12]  991 	mov	r7,#0x00
      000180                        992 00102$:
                                    993 ;	main.c:175: SCL = 0;
                                    994 ;	assignBit
      000180 C2 96            [12]  995 	clr	_P1_6
                                    996 ;	main.c:176: delay(50);
      000182 90 00 32         [24]  997 	mov	dptr,#0x0032
      000185 C0 07            [24]  998 	push	ar7
      000187 C0 06            [24]  999 	push	ar6
      000189 12r00r1E         [24] 1000 	lcall	_delay
                                   1001 ;	main.c:177: SDA = 1;
                                   1002 ;	assignBit
      00018C D2 97            [12] 1003 	setb	_P1_7
                                   1004 ;	main.c:178: delay(50);
      00018E 90 00 32         [24] 1005 	mov	dptr,#0x0032
      000191 12r00r1E         [24] 1006 	lcall	_delay
                                   1007 ;	main.c:179: SCL = 1;
                                   1008 ;	assignBit
      000194 D2 96            [12] 1009 	setb	_P1_6
                                   1010 ;	main.c:180: delay(50);
      000196 90 00 32         [24] 1011 	mov	dptr,#0x0032
      000199 12r00r1E         [24] 1012 	lcall	_delay
      00019C D0 06            [24] 1013 	pop	ar6
      00019E D0 07            [24] 1014 	pop	ar7
                                   1015 ;	main.c:173: for (i=0;i<9; i++)
      0001A0 0E               [12] 1016 	inc	r6
      0001A1 BE 00 01         [24] 1017 	cjne	r6,#0x00,00115$
      0001A4 0F               [12] 1018 	inc	r7
      0001A5                       1019 00115$:
      0001A5 C3               [12] 1020 	clr	c
      0001A6 EE               [12] 1021 	mov	a,r6
      0001A7 94 09            [12] 1022 	subb	a,#0x09
      0001A9 EF               [12] 1023 	mov	a,r7
      0001AA 64 80            [12] 1024 	xrl	a,#0x80
      0001AC 94 80            [12] 1025 	subb	a,#0x80
      0001AE 40 D0            [24] 1026 	jc	00102$
                                   1027 ;	main.c:182: I2C_Start();
      0001B0 12r00r3A         [24] 1028 	lcall	_I2C_Start
                                   1029 ;	main.c:183: I2C_Stop();
                                   1030 ;	main.c:184: }
      0001B3 02r01r39         [24] 1031 	ljmp	_I2C_Stop
                                   1032 ;------------------------------------------------------------
                                   1033 ;Allocation info for local variables in function 'eebytew'
                                   1034 ;------------------------------------------------------------
                                   1035 ;databyte                  Allocated with name '_eebytew_PARM_2'
                                   1036 ;addr                      Allocated to registers r6 r7 
                                   1037 ;------------------------------------------------------------
                                   1038 ;	main.c:186: void eebytew(unsigned int addr, unsigned char databyte)
                                   1039 ;	-----------------------------------------
                                   1040 ;	 function eebytew
                                   1041 ;	-----------------------------------------
      0001B6                       1042 _eebytew:
      0001B6 AE 82            [24] 1043 	mov	r6,dpl
      0001B8 AF 83            [24] 1044 	mov	r7,dph
                                   1045 ;	main.c:188: I2C_Start();
      0001BA C0 07            [24] 1046 	push	ar7
      0001BC C0 06            [24] 1047 	push	ar6
      0001BE 12r00r3A         [24] 1048 	lcall	_I2C_Start
      0001C1 D0 06            [24] 1049 	pop	ar6
      0001C3 D0 07            [24] 1050 	pop	ar7
                                   1051 ;	main.c:189: if(addr <= 0xFF)
      0001C5 C3               [12] 1052 	clr	c
      0001C6 74 FF            [12] 1053 	mov	a,#0xff
      0001C8 9E               [12] 1054 	subb	a,r6
      0001C9 E4               [12] 1055 	clr	a
      0001CA 9F               [12] 1056 	subb	a,r7
      0001CB 40 11            [24] 1057 	jc	00122$
                                   1058 ;	main.c:191: I2C_Write_Byte((unsigned char)0xA0);
      0001CD 75 82 A0         [24] 1059 	mov	dpl,#0xa0
      0001D0 C0 07            [24] 1060 	push	ar7
      0001D2 C0 06            [24] 1061 	push	ar6
      0001D4 12r00r4C         [24] 1062 	lcall	_I2C_Write_Byte
      0001D7 D0 06            [24] 1063 	pop	ar6
      0001D9 D0 07            [24] 1064 	pop	ar7
      0001DB 02r02r8D         [24] 1065 	ljmp	00123$
      0001DE                       1066 00122$:
                                   1067 ;	main.c:194: if(addr <= 0x1FF){
      0001DE C3               [12] 1068 	clr	c
      0001DF 74 FF            [12] 1069 	mov	a,#0xff
      0001E1 9E               [12] 1070 	subb	a,r6
      0001E2 74 01            [12] 1071 	mov	a,#0x01
      0001E4 9F               [12] 1072 	subb	a,r7
      0001E5 40 11            [24] 1073 	jc	00119$
                                   1074 ;	main.c:195: I2C_Write_Byte((unsigned char)0xA2);
      0001E7 75 82 A2         [24] 1075 	mov	dpl,#0xa2
      0001EA C0 07            [24] 1076 	push	ar7
      0001EC C0 06            [24] 1077 	push	ar6
      0001EE 12r00r4C         [24] 1078 	lcall	_I2C_Write_Byte
      0001F1 D0 06            [24] 1079 	pop	ar6
      0001F3 D0 07            [24] 1080 	pop	ar7
      0001F5 02r02r8D         [24] 1081 	ljmp	00123$
      0001F8                       1082 00119$:
                                   1083 ;	main.c:198: if(addr <= 0x2FF){
      0001F8 C3               [12] 1084 	clr	c
      0001F9 74 FF            [12] 1085 	mov	a,#0xff
      0001FB 9E               [12] 1086 	subb	a,r6
      0001FC 74 02            [12] 1087 	mov	a,#0x02
      0001FE 9F               [12] 1088 	subb	a,r7
      0001FF 40 11            [24] 1089 	jc	00116$
                                   1090 ;	main.c:199: I2C_Write_Byte((unsigned char)0xA4);
      000201 75 82 A4         [24] 1091 	mov	dpl,#0xa4
      000204 C0 07            [24] 1092 	push	ar7
      000206 C0 06            [24] 1093 	push	ar6
      000208 12r00r4C         [24] 1094 	lcall	_I2C_Write_Byte
      00020B D0 06            [24] 1095 	pop	ar6
      00020D D0 07            [24] 1096 	pop	ar7
      00020F 02r02r8D         [24] 1097 	ljmp	00123$
      000212                       1098 00116$:
                                   1099 ;	main.c:202: if(addr <= 0x3FF){
      000212 C3               [12] 1100 	clr	c
      000213 74 FF            [12] 1101 	mov	a,#0xff
      000215 9E               [12] 1102 	subb	a,r6
      000216 74 03            [12] 1103 	mov	a,#0x03
      000218 9F               [12] 1104 	subb	a,r7
      000219 40 10            [24] 1105 	jc	00113$
                                   1106 ;	main.c:203: I2C_Write_Byte((unsigned char)0xA6);
      00021B 75 82 A6         [24] 1107 	mov	dpl,#0xa6
      00021E C0 07            [24] 1108 	push	ar7
      000220 C0 06            [24] 1109 	push	ar6
      000222 12r00r4C         [24] 1110 	lcall	_I2C_Write_Byte
      000225 D0 06            [24] 1111 	pop	ar6
      000227 D0 07            [24] 1112 	pop	ar7
      000229 80 62            [24] 1113 	sjmp	00123$
      00022B                       1114 00113$:
                                   1115 ;	main.c:206: if(addr <= 0x4FF){
      00022B C3               [12] 1116 	clr	c
      00022C 74 FF            [12] 1117 	mov	a,#0xff
      00022E 9E               [12] 1118 	subb	a,r6
      00022F 74 04            [12] 1119 	mov	a,#0x04
      000231 9F               [12] 1120 	subb	a,r7
      000232 40 10            [24] 1121 	jc	00110$
                                   1122 ;	main.c:207: I2C_Write_Byte((unsigned char)0xA8);
      000234 75 82 A8         [24] 1123 	mov	dpl,#0xa8
      000237 C0 07            [24] 1124 	push	ar7
      000239 C0 06            [24] 1125 	push	ar6
      00023B 12r00r4C         [24] 1126 	lcall	_I2C_Write_Byte
      00023E D0 06            [24] 1127 	pop	ar6
      000240 D0 07            [24] 1128 	pop	ar7
      000242 80 49            [24] 1129 	sjmp	00123$
      000244                       1130 00110$:
                                   1131 ;	main.c:210: if(addr <= 0x5FF){
      000244 C3               [12] 1132 	clr	c
      000245 74 FF            [12] 1133 	mov	a,#0xff
      000247 9E               [12] 1134 	subb	a,r6
      000248 74 05            [12] 1135 	mov	a,#0x05
      00024A 9F               [12] 1136 	subb	a,r7
      00024B 40 10            [24] 1137 	jc	00107$
                                   1138 ;	main.c:211: I2C_Write_Byte((unsigned char)0xAA);
      00024D 75 82 AA         [24] 1139 	mov	dpl,#0xaa
      000250 C0 07            [24] 1140 	push	ar7
      000252 C0 06            [24] 1141 	push	ar6
      000254 12r00r4C         [24] 1142 	lcall	_I2C_Write_Byte
      000257 D0 06            [24] 1143 	pop	ar6
      000259 D0 07            [24] 1144 	pop	ar7
      00025B 80 30            [24] 1145 	sjmp	00123$
      00025D                       1146 00107$:
                                   1147 ;	main.c:214: if(addr <= 0x6FF){
      00025D C3               [12] 1148 	clr	c
      00025E 74 FF            [12] 1149 	mov	a,#0xff
      000260 9E               [12] 1150 	subb	a,r6
      000261 74 06            [12] 1151 	mov	a,#0x06
      000263 9F               [12] 1152 	subb	a,r7
      000264 40 10            [24] 1153 	jc	00104$
                                   1154 ;	main.c:215: I2C_Write_Byte((unsigned char)0xAC);
      000266 75 82 AC         [24] 1155 	mov	dpl,#0xac
      000269 C0 07            [24] 1156 	push	ar7
      00026B C0 06            [24] 1157 	push	ar6
      00026D 12r00r4C         [24] 1158 	lcall	_I2C_Write_Byte
      000270 D0 06            [24] 1159 	pop	ar6
      000272 D0 07            [24] 1160 	pop	ar7
      000274 80 17            [24] 1161 	sjmp	00123$
      000276                       1162 00104$:
                                   1163 ;	main.c:218: if(addr <= 0x7FF){
      000276 C3               [12] 1164 	clr	c
      000277 74 FF            [12] 1165 	mov	a,#0xff
      000279 9E               [12] 1166 	subb	a,r6
      00027A 74 07            [12] 1167 	mov	a,#0x07
      00027C 9F               [12] 1168 	subb	a,r7
      00027D 40 0E            [24] 1169 	jc	00123$
                                   1170 ;	main.c:219: I2C_Write_Byte((unsigned char)0xAE);
      00027F 75 82 AE         [24] 1171 	mov	dpl,#0xae
      000282 C0 07            [24] 1172 	push	ar7
      000284 C0 06            [24] 1173 	push	ar6
      000286 12r00r4C         [24] 1174 	lcall	_I2C_Write_Byte
      000289 D0 06            [24] 1175 	pop	ar6
      00028B D0 07            [24] 1176 	pop	ar7
      00028D                       1177 00123$:
                                   1178 ;	main.c:228: I2C_Write_Byte((unsigned char)addr);
      00028D 8E 82            [24] 1179 	mov	dpl,r6
      00028F 12r00r4C         [24] 1180 	lcall	_I2C_Write_Byte
                                   1181 ;	main.c:229: I2C_Write_Byte(databyte);
      000292 85*00 82         [24] 1182 	mov	dpl,_eebytew_PARM_2
      000295 12r00r4C         [24] 1183 	lcall	_I2C_Write_Byte
                                   1184 ;	main.c:230: I2C_Stop();
                                   1185 ;	main.c:232: }
      000298 02r01r39         [24] 1186 	ljmp	_I2C_Stop
                                   1187 ;------------------------------------------------------------
                                   1188 ;Allocation info for local variables in function 'eebyter'
                                   1189 ;------------------------------------------------------------
                                   1190 ;addr                      Allocated to registers r6 r7 
                                   1191 ;rec                       Allocated to registers r7 
                                   1192 ;------------------------------------------------------------
                                   1193 ;	main.c:234: unsigned char eebyter(unsigned int addr)
                                   1194 ;	-----------------------------------------
                                   1195 ;	 function eebyter
                                   1196 ;	-----------------------------------------
      00029B                       1197 _eebyter:
      00029B AE 82            [24] 1198 	mov	r6,dpl
      00029D AF 83            [24] 1199 	mov	r7,dph
                                   1200 ;	main.c:237: I2C_Start();
      00029F C0 07            [24] 1201 	push	ar7
      0002A1 C0 06            [24] 1202 	push	ar6
      0002A3 12r00r3A         [24] 1203 	lcall	_I2C_Start
      0002A6 D0 06            [24] 1204 	pop	ar6
      0002A8 D0 07            [24] 1205 	pop	ar7
                                   1206 ;	main.c:238: if(addr <= 0xFF)
      0002AA C3               [12] 1207 	clr	c
      0002AB 74 FF            [12] 1208 	mov	a,#0xff
      0002AD 9E               [12] 1209 	subb	a,r6
      0002AE E4               [12] 1210 	clr	a
      0002AF 9F               [12] 1211 	subb	a,r7
      0002B0 92*00            [24] 1212 	mov	_eebyter_sloc0_1_0,c
      0002B2 40 11            [24] 1213 	jc	00122$
                                   1214 ;	main.c:240: I2C_Write_Byte((unsigned char)0xA0);
      0002B4 75 82 A0         [24] 1215 	mov	dpl,#0xa0
      0002B7 C0 07            [24] 1216 	push	ar7
      0002B9 C0 06            [24] 1217 	push	ar6
      0002BB 12r00r4C         [24] 1218 	lcall	_I2C_Write_Byte
      0002BE D0 06            [24] 1219 	pop	ar6
      0002C0 D0 07            [24] 1220 	pop	ar7
      0002C2 02r03r73         [24] 1221 	ljmp	00123$
      0002C5                       1222 00122$:
                                   1223 ;	main.c:243: if(addr <= 0x1FF){
      0002C5 C3               [12] 1224 	clr	c
      0002C6 74 FF            [12] 1225 	mov	a,#0xff
      0002C8 9E               [12] 1226 	subb	a,r6
      0002C9 74 01            [12] 1227 	mov	a,#0x01
      0002CB 9F               [12] 1228 	subb	a,r7
      0002CC 40 11            [24] 1229 	jc	00119$
                                   1230 ;	main.c:244: I2C_Write_Byte((unsigned char)0xA2);
      0002CE 75 82 A2         [24] 1231 	mov	dpl,#0xa2
      0002D1 C0 07            [24] 1232 	push	ar7
      0002D3 C0 06            [24] 1233 	push	ar6
      0002D5 12r00r4C         [24] 1234 	lcall	_I2C_Write_Byte
      0002D8 D0 06            [24] 1235 	pop	ar6
      0002DA D0 07            [24] 1236 	pop	ar7
      0002DC 02r03r73         [24] 1237 	ljmp	00123$
      0002DF                       1238 00119$:
                                   1239 ;	main.c:247: if(addr <= 0x2FF){
      0002DF C3               [12] 1240 	clr	c
      0002E0 74 FF            [12] 1241 	mov	a,#0xff
      0002E2 9E               [12] 1242 	subb	a,r6
      0002E3 74 02            [12] 1243 	mov	a,#0x02
      0002E5 9F               [12] 1244 	subb	a,r7
      0002E6 40 10            [24] 1245 	jc	00116$
                                   1246 ;	main.c:248: I2C_Write_Byte((unsigned char)0xA4);
      0002E8 75 82 A4         [24] 1247 	mov	dpl,#0xa4
      0002EB C0 07            [24] 1248 	push	ar7
      0002ED C0 06            [24] 1249 	push	ar6
      0002EF 12r00r4C         [24] 1250 	lcall	_I2C_Write_Byte
      0002F2 D0 06            [24] 1251 	pop	ar6
      0002F4 D0 07            [24] 1252 	pop	ar7
      0002F6 80 7B            [24] 1253 	sjmp	00123$
      0002F8                       1254 00116$:
                                   1255 ;	main.c:251: if(addr <= 0x3FF){
      0002F8 C3               [12] 1256 	clr	c
      0002F9 74 FF            [12] 1257 	mov	a,#0xff
      0002FB 9E               [12] 1258 	subb	a,r6
      0002FC 74 03            [12] 1259 	mov	a,#0x03
      0002FE 9F               [12] 1260 	subb	a,r7
      0002FF 40 10            [24] 1261 	jc	00113$
                                   1262 ;	main.c:252: I2C_Write_Byte((unsigned char)0xA6);
      000301 75 82 A6         [24] 1263 	mov	dpl,#0xa6
      000304 C0 07            [24] 1264 	push	ar7
      000306 C0 06            [24] 1265 	push	ar6
      000308 12r00r4C         [24] 1266 	lcall	_I2C_Write_Byte
      00030B D0 06            [24] 1267 	pop	ar6
      00030D D0 07            [24] 1268 	pop	ar7
      00030F 80 62            [24] 1269 	sjmp	00123$
      000311                       1270 00113$:
                                   1271 ;	main.c:255: if(addr <= 0x4FF){
      000311 C3               [12] 1272 	clr	c
      000312 74 FF            [12] 1273 	mov	a,#0xff
      000314 9E               [12] 1274 	subb	a,r6
      000315 74 04            [12] 1275 	mov	a,#0x04
      000317 9F               [12] 1276 	subb	a,r7
      000318 40 10            [24] 1277 	jc	00110$
                                   1278 ;	main.c:256: I2C_Write_Byte((unsigned char)0xA8);
      00031A 75 82 A8         [24] 1279 	mov	dpl,#0xa8
      00031D C0 07            [24] 1280 	push	ar7
      00031F C0 06            [24] 1281 	push	ar6
      000321 12r00r4C         [24] 1282 	lcall	_I2C_Write_Byte
      000324 D0 06            [24] 1283 	pop	ar6
      000326 D0 07            [24] 1284 	pop	ar7
      000328 80 49            [24] 1285 	sjmp	00123$
      00032A                       1286 00110$:
                                   1287 ;	main.c:259: if(addr <= 0x5FF){
      00032A C3               [12] 1288 	clr	c
      00032B 74 FF            [12] 1289 	mov	a,#0xff
      00032D 9E               [12] 1290 	subb	a,r6
      00032E 74 05            [12] 1291 	mov	a,#0x05
      000330 9F               [12] 1292 	subb	a,r7
      000331 40 10            [24] 1293 	jc	00107$
                                   1294 ;	main.c:260: I2C_Write_Byte((unsigned char)0xAA);
      000333 75 82 AA         [24] 1295 	mov	dpl,#0xaa
      000336 C0 07            [24] 1296 	push	ar7
      000338 C0 06            [24] 1297 	push	ar6
      00033A 12r00r4C         [24] 1298 	lcall	_I2C_Write_Byte
      00033D D0 06            [24] 1299 	pop	ar6
      00033F D0 07            [24] 1300 	pop	ar7
      000341 80 30            [24] 1301 	sjmp	00123$
      000343                       1302 00107$:
                                   1303 ;	main.c:263: if(addr <= 0x6FF){
      000343 C3               [12] 1304 	clr	c
      000344 74 FF            [12] 1305 	mov	a,#0xff
      000346 9E               [12] 1306 	subb	a,r6
      000347 74 06            [12] 1307 	mov	a,#0x06
      000349 9F               [12] 1308 	subb	a,r7
      00034A 40 10            [24] 1309 	jc	00104$
                                   1310 ;	main.c:264: I2C_Write_Byte((unsigned char)0xAC);
      00034C 75 82 AC         [24] 1311 	mov	dpl,#0xac
      00034F C0 07            [24] 1312 	push	ar7
      000351 C0 06            [24] 1313 	push	ar6
      000353 12r00r4C         [24] 1314 	lcall	_I2C_Write_Byte
      000356 D0 06            [24] 1315 	pop	ar6
      000358 D0 07            [24] 1316 	pop	ar7
      00035A 80 17            [24] 1317 	sjmp	00123$
      00035C                       1318 00104$:
                                   1319 ;	main.c:267: if(addr <= 0x7FF){
      00035C C3               [12] 1320 	clr	c
      00035D 74 FF            [12] 1321 	mov	a,#0xff
      00035F 9E               [12] 1322 	subb	a,r6
      000360 74 07            [12] 1323 	mov	a,#0x07
      000362 9F               [12] 1324 	subb	a,r7
      000363 40 0E            [24] 1325 	jc	00123$
                                   1326 ;	main.c:268: I2C_Write_Byte((unsigned char)0xAE);
      000365 75 82 AE         [24] 1327 	mov	dpl,#0xae
      000368 C0 07            [24] 1328 	push	ar7
      00036A C0 06            [24] 1329 	push	ar6
      00036C 12r00r4C         [24] 1330 	lcall	_I2C_Write_Byte
      00036F D0 06            [24] 1331 	pop	ar6
      000371 D0 07            [24] 1332 	pop	ar7
      000373                       1333 00123$:
                                   1334 ;	main.c:278: I2C_Write_Byte((unsigned char)addr);
      000373 8E 82            [24] 1335 	mov	dpl,r6
      000375 C0 07            [24] 1336 	push	ar7
      000377 C0 06            [24] 1337 	push	ar6
      000379 12r00r4C         [24] 1338 	lcall	_I2C_Write_Byte
                                   1339 ;	main.c:279: RepeatedStartI2c();
      00037C 12r01r59         [24] 1340 	lcall	_RepeatedStartI2c
      00037F D0 06            [24] 1341 	pop	ar6
      000381 D0 07            [24] 1342 	pop	ar7
                                   1343 ;	main.c:280: if(addr <= 0xFF)
      000383 20*00 08         [24] 1344 	jb	_eebyter_sloc0_1_0,00145$
                                   1345 ;	main.c:282: I2C_Write_Byte((unsigned char)0xA1);
      000386 75 82 A1         [24] 1346 	mov	dpl,#0xa1
      000389 12r00r4C         [24] 1347 	lcall	_I2C_Write_Byte
      00038C 80 75            [24] 1348 	sjmp	00146$
      00038E                       1349 00145$:
                                   1350 ;	main.c:285: if(addr <= 0x1FF){
      00038E C3               [12] 1351 	clr	c
      00038F 74 FF            [12] 1352 	mov	a,#0xff
      000391 9E               [12] 1353 	subb	a,r6
      000392 74 01            [12] 1354 	mov	a,#0x01
      000394 9F               [12] 1355 	subb	a,r7
      000395 40 08            [24] 1356 	jc	00142$
                                   1357 ;	main.c:286: I2C_Write_Byte((unsigned char)0xA3);
      000397 75 82 A3         [24] 1358 	mov	dpl,#0xa3
      00039A 12r00r4C         [24] 1359 	lcall	_I2C_Write_Byte
      00039D 80 64            [24] 1360 	sjmp	00146$
      00039F                       1361 00142$:
                                   1362 ;	main.c:289: if(addr <= 0x2FF){
      00039F C3               [12] 1363 	clr	c
      0003A0 74 FF            [12] 1364 	mov	a,#0xff
      0003A2 9E               [12] 1365 	subb	a,r6
      0003A3 74 02            [12] 1366 	mov	a,#0x02
      0003A5 9F               [12] 1367 	subb	a,r7
      0003A6 40 08            [24] 1368 	jc	00139$
                                   1369 ;	main.c:290: I2C_Write_Byte((unsigned char)0xA5);
      0003A8 75 82 A5         [24] 1370 	mov	dpl,#0xa5
      0003AB 12r00r4C         [24] 1371 	lcall	_I2C_Write_Byte
      0003AE 80 53            [24] 1372 	sjmp	00146$
      0003B0                       1373 00139$:
                                   1374 ;	main.c:293: if(addr <= 0x3FF){
      0003B0 C3               [12] 1375 	clr	c
      0003B1 74 FF            [12] 1376 	mov	a,#0xff
      0003B3 9E               [12] 1377 	subb	a,r6
      0003B4 74 03            [12] 1378 	mov	a,#0x03
      0003B6 9F               [12] 1379 	subb	a,r7
      0003B7 40 08            [24] 1380 	jc	00136$
                                   1381 ;	main.c:294: I2C_Write_Byte((unsigned char)0xA7);
      0003B9 75 82 A7         [24] 1382 	mov	dpl,#0xa7
      0003BC 12r00r4C         [24] 1383 	lcall	_I2C_Write_Byte
      0003BF 80 42            [24] 1384 	sjmp	00146$
      0003C1                       1385 00136$:
                                   1386 ;	main.c:297: if(addr <= 0x4FF){
      0003C1 C3               [12] 1387 	clr	c
      0003C2 74 FF            [12] 1388 	mov	a,#0xff
      0003C4 9E               [12] 1389 	subb	a,r6
      0003C5 74 04            [12] 1390 	mov	a,#0x04
      0003C7 9F               [12] 1391 	subb	a,r7
      0003C8 40 08            [24] 1392 	jc	00133$
                                   1393 ;	main.c:298: I2C_Write_Byte((unsigned char)0xA9);
      0003CA 75 82 A9         [24] 1394 	mov	dpl,#0xa9
      0003CD 12r00r4C         [24] 1395 	lcall	_I2C_Write_Byte
      0003D0 80 31            [24] 1396 	sjmp	00146$
      0003D2                       1397 00133$:
                                   1398 ;	main.c:301: if(addr <= 0x5FF){
      0003D2 C3               [12] 1399 	clr	c
      0003D3 74 FF            [12] 1400 	mov	a,#0xff
      0003D5 9E               [12] 1401 	subb	a,r6
      0003D6 74 05            [12] 1402 	mov	a,#0x05
      0003D8 9F               [12] 1403 	subb	a,r7
      0003D9 40 08            [24] 1404 	jc	00130$
                                   1405 ;	main.c:302: I2C_Write_Byte((unsigned char)0xAB);
      0003DB 75 82 AB         [24] 1406 	mov	dpl,#0xab
      0003DE 12r00r4C         [24] 1407 	lcall	_I2C_Write_Byte
      0003E1 80 20            [24] 1408 	sjmp	00146$
      0003E3                       1409 00130$:
                                   1410 ;	main.c:305: if(addr <= 0x6FF){
      0003E3 C3               [12] 1411 	clr	c
      0003E4 74 FF            [12] 1412 	mov	a,#0xff
      0003E6 9E               [12] 1413 	subb	a,r6
      0003E7 74 06            [12] 1414 	mov	a,#0x06
      0003E9 9F               [12] 1415 	subb	a,r7
      0003EA 40 08            [24] 1416 	jc	00127$
                                   1417 ;	main.c:306: I2C_Write_Byte((unsigned char)0xAD);
      0003EC 75 82 AD         [24] 1418 	mov	dpl,#0xad
      0003EF 12r00r4C         [24] 1419 	lcall	_I2C_Write_Byte
      0003F2 80 0F            [24] 1420 	sjmp	00146$
      0003F4                       1421 00127$:
                                   1422 ;	main.c:309: if(addr <= 0x7FF){
      0003F4 C3               [12] 1423 	clr	c
      0003F5 74 FF            [12] 1424 	mov	a,#0xff
      0003F7 9E               [12] 1425 	subb	a,r6
      0003F8 74 07            [12] 1426 	mov	a,#0x07
      0003FA 9F               [12] 1427 	subb	a,r7
      0003FB 40 06            [24] 1428 	jc	00146$
                                   1429 ;	main.c:310: I2C_Write_Byte((unsigned char)0xAF);
      0003FD 75 82 AF         [24] 1430 	mov	dpl,#0xaf
      000400 12r00r4C         [24] 1431 	lcall	_I2C_Write_Byte
      000403                       1432 00146$:
                                   1433 ;	main.c:320: rec=I2C_Read_Byte();
      000403 12r00rB2         [24] 1434 	lcall	_I2C_Read_Byte
      000406 AF 82            [24] 1435 	mov	r7,dpl
                                   1436 ;	main.c:321: I2C_Send_NACK();
      000408 C0 07            [24] 1437 	push	ar7
      00040A 12r01r01         [24] 1438 	lcall	_I2C_Send_NACK
                                   1439 ;	main.c:322: I2C_Stop();
      00040D 12r01r39         [24] 1440 	lcall	_I2C_Stop
      000410 D0 07            [24] 1441 	pop	ar7
                                   1442 ;	main.c:323: return rec;
      000412 8F 82            [24] 1443 	mov	dpl,r7
                                   1444 ;	main.c:324: }
      000414 22               [24] 1445 	ret
                                   1446 ;------------------------------------------------------------
                                   1447 ;Allocation info for local variables in function 'main'
                                   1448 ;------------------------------------------------------------
                                   1449 ;rx                        Allocated to registers 
                                   1450 ;addr                      Allocated with name '_main_addr_131072_95'
                                   1451 ;addr1                     Allocated with name '_main_addr1_131072_95'
                                   1452 ;start_addr                Allocated with name '_main_start_addr_131072_95'
                                   1453 ;end_addr                  Allocated with name '_main_end_addr_131072_95'
                                   1454 ;data                      Allocated with name '_main_data_131072_95'
                                   1455 ;digit                     Allocated to registers r1 r2 
                                   1456 ;ch                        Allocated to registers r4 
                                   1457 ;rd                        Allocated to registers r5 
                                   1458 ;i                         Allocated to registers r0 r1 
                                   1459 ;------------------------------------------------------------
                                   1460 ;	main.c:326: void main(void)
                                   1461 ;	-----------------------------------------
                                   1462 ;	 function main
                                   1463 ;	-----------------------------------------
      000415                       1464 _main:
                                   1465 ;	main.c:329: I2C_init();					// Initialize i2c pins
      000415 12r00r35         [24] 1466 	lcall	_I2C_init
                                   1467 ;	main.c:330: printf("Starting I2C application\r\n");
      000418 74r00            [12] 1468 	mov	a,#___str_0
      00041A C0 E0            [24] 1469 	push	acc
      00041C 74s00            [12] 1470 	mov	a,#(___str_0 >> 8)
      00041E C0 E0            [24] 1471 	push	acc
      000420 74 80            [12] 1472 	mov	a,#0x80
      000422 C0 E0            [24] 1473 	push	acc
      000424 12r00r00         [24] 1474 	lcall	_printf
      000427 15 81            [12] 1475 	dec	sp
      000429 15 81            [12] 1476 	dec	sp
      00042B 15 81            [12] 1477 	dec	sp
                                   1478 ;	main.c:331: printf("Help menu:\r\n");
      00042D 74r1B            [12] 1479 	mov	a,#___str_1
      00042F C0 E0            [24] 1480 	push	acc
      000431 74s00            [12] 1481 	mov	a,#(___str_1 >> 8)
      000433 C0 E0            [24] 1482 	push	acc
      000435 74 80            [12] 1483 	mov	a,#0x80
      000437 C0 E0            [24] 1484 	push	acc
      000439 12r00r00         [24] 1485 	lcall	_printf
      00043C 15 81            [12] 1486 	dec	sp
      00043E 15 81            [12] 1487 	dec	sp
      000440 15 81            [12] 1488 	dec	sp
                                   1489 ;	main.c:332: printf("'w': Enter an EEPROM address in hex to write data at and byte data\r\n");
      000442 74r28            [12] 1490 	mov	a,#___str_2
      000444 C0 E0            [24] 1491 	push	acc
      000446 74s00            [12] 1492 	mov	a,#(___str_2 >> 8)
      000448 C0 E0            [24] 1493 	push	acc
      00044A 74 80            [12] 1494 	mov	a,#0x80
      00044C C0 E0            [24] 1495 	push	acc
      00044E 12r00r00         [24] 1496 	lcall	_printf
      000451 15 81            [12] 1497 	dec	sp
      000453 15 81            [12] 1498 	dec	sp
      000455 15 81            [12] 1499 	dec	sp
                                   1500 ;	main.c:333: printf("'r': Enter an EEPROM address in hex to read data from\r\n");
      000457 74r6D            [12] 1501 	mov	a,#___str_3
      000459 C0 E0            [24] 1502 	push	acc
      00045B 74s00            [12] 1503 	mov	a,#(___str_3 >> 8)
      00045D C0 E0            [24] 1504 	push	acc
      00045F 74 80            [12] 1505 	mov	a,#0x80
      000461 C0 E0            [24] 1506 	push	acc
      000463 12r00r00         [24] 1507 	lcall	_printf
      000466 15 81            [12] 1508 	dec	sp
      000468 15 81            [12] 1509 	dec	sp
      00046A 15 81            [12] 1510 	dec	sp
                                   1511 ;	main.c:334: printf("'h': Enter an EEPROM start and end addresses to dump the data\r\n");
      00046C 74rA5            [12] 1512 	mov	a,#___str_4
      00046E C0 E0            [24] 1513 	push	acc
      000470 74s00            [12] 1514 	mov	a,#(___str_4 >> 8)
      000472 C0 E0            [24] 1515 	push	acc
      000474 74 80            [12] 1516 	mov	a,#0x80
      000476 C0 E0            [24] 1517 	push	acc
      000478 12r00r00         [24] 1518 	lcall	_printf
      00047B 15 81            [12] 1519 	dec	sp
      00047D 15 81            [12] 1520 	dec	sp
      00047F 15 81            [12] 1521 	dec	sp
                                   1522 ;	main.c:335: printf("'e': Reset EEPROM\r\n");
      000481 74rE5            [12] 1523 	mov	a,#___str_5
      000483 C0 E0            [24] 1524 	push	acc
      000485 74s00            [12] 1525 	mov	a,#(___str_5 >> 8)
      000487 C0 E0            [24] 1526 	push	acc
      000489 74 80            [12] 1527 	mov	a,#0x80
      00048B C0 E0            [24] 1528 	push	acc
      00048D 12r00r00         [24] 1529 	lcall	_printf
      000490 15 81            [12] 1530 	dec	sp
      000492 15 81            [12] 1531 	dec	sp
      000494 15 81            [12] 1532 	dec	sp
                                   1533 ;	main.c:337: while(1)
      000496 E4               [12] 1534 	clr	a
      000497 FE               [12] 1535 	mov	r6,a
      000498 FF               [12] 1536 	mov	r7,a
      000499 F5*03            [12] 1537 	mov	_main_addr1_131072_95,a
      00049B F5*04            [12] 1538 	mov	(_main_addr1_131072_95 + 1),a
      00049D F5*05            [12] 1539 	mov	_main_start_addr_131072_95,a
      00049F F5*06            [12] 1540 	mov	(_main_start_addr_131072_95 + 1),a
      0004A1                       1541 00213$:
                                   1542 ;	main.c:339: unsigned int addr, addr1, start_addr, end_addr = 0;
      0004A1 E4               [12] 1543 	clr	a
      0004A2 F5*07            [12] 1544 	mov	_main_end_addr_131072_95,a
      0004A4 F5*08            [12] 1545 	mov	(_main_end_addr_131072_95 + 1),a
                                   1546 ;	main.c:340: unsigned int data = 0;
      0004A6 F5*09            [12] 1547 	mov	_main_data_131072_95,a
      0004A8 F5*0A            [12] 1548 	mov	(_main_data_131072_95 + 1),a
                                   1549 ;	main.c:342: char ch = getchar();
      0004AA C0 07            [24] 1550 	push	ar7
      0004AC C0 06            [24] 1551 	push	ar6
      0004AE 12r00r00         [24] 1552 	lcall	_getchar
      0004B1 AC 82            [24] 1553 	mov	r4,dpl
                                   1554 ;	main.c:343: putchar(ch);
      0004B3 8C 01            [24] 1555 	mov	ar1,r4
      0004B5 7D 00            [12] 1556 	mov	r5,#0x00
      0004B7 89 82            [24] 1557 	mov	dpl,r1
      0004B9 8D 83            [24] 1558 	mov	dph,r5
      0004BB C0 04            [24] 1559 	push	ar4
      0004BD 12r00r0E         [24] 1560 	lcall	_putchar
                                   1561 ;	main.c:344: printf("\r\n");
      0004C0 74rF9            [12] 1562 	mov	a,#___str_6
      0004C2 C0 E0            [24] 1563 	push	acc
      0004C4 74s00            [12] 1564 	mov	a,#(___str_6 >> 8)
      0004C6 C0 E0            [24] 1565 	push	acc
      0004C8 74 80            [12] 1566 	mov	a,#0x80
      0004CA C0 E0            [24] 1567 	push	acc
      0004CC 12r00r00         [24] 1568 	lcall	_printf
      0004CF 15 81            [12] 1569 	dec	sp
      0004D1 15 81            [12] 1570 	dec	sp
      0004D3 15 81            [12] 1571 	dec	sp
      0004D5 D0 04            [24] 1572 	pop	ar4
      0004D7 D0 06            [24] 1573 	pop	ar6
      0004D9 D0 07            [24] 1574 	pop	ar7
                                   1575 ;	main.c:345: switch(ch)
      0004DB BC 65 03         [24] 1576 	cjne	r4,#0x65,00491$
      0004DE 02r0ArC0         [24] 1577 	ljmp	00209$
      0004E1                       1578 00491$:
      0004E1 BC 68 03         [24] 1579 	cjne	r4,#0x68,00492$
      0004E4 02r08r02         [24] 1580 	ljmp	00163$
      0004E7                       1581 00492$:
      0004E7 BC 72 03         [24] 1582 	cjne	r4,#0x72,00493$
      0004EA 02r06rE6         [24] 1583 	ljmp	00142$
      0004ED                       1584 00493$:
      0004ED BC 77 02         [24] 1585 	cjne	r4,#0x77,00494$
      0004F0 80 03            [24] 1586 	sjmp	00495$
      0004F2                       1587 00494$:
      0004F2 02r0ArE3         [24] 1588 	ljmp	00210$
      0004F5                       1589 00495$:
                                   1590 ;	main.c:348: printf("Enter the address location to store the data at : \r\n");
      0004F5 C0 07            [24] 1591 	push	ar7
      0004F7 C0 06            [24] 1592 	push	ar6
      0004F9 74rFC            [12] 1593 	mov	a,#___str_7
      0004FB C0 E0            [24] 1594 	push	acc
      0004FD 74s00            [12] 1595 	mov	a,#(___str_7 >> 8)
      0004FF C0 E0            [24] 1596 	push	acc
      000501 74 80            [12] 1597 	mov	a,#0x80
      000503 C0 E0            [24] 1598 	push	acc
      000505 12r00r00         [24] 1599 	lcall	_printf
      000508 15 81            [12] 1600 	dec	sp
      00050A 15 81            [12] 1601 	dec	sp
      00050C 15 81            [12] 1602 	dec	sp
      00050E D0 06            [24] 1603 	pop	ar6
      000510 D0 07            [24] 1604 	pop	ar7
                                   1605 ;	main.c:349: while (1) {
      000512                       1606 00117$:
                                   1607 ;	main.c:350: ch = getchar();
      000512 C0 07            [24] 1608 	push	ar7
      000514 C0 06            [24] 1609 	push	ar6
      000516 12r00r00         [24] 1610 	lcall	_getchar
      000519 AC 82            [24] 1611 	mov	r4,dpl
      00051B D0 06            [24] 1612 	pop	ar6
      00051D D0 07            [24] 1613 	pop	ar7
                                   1614 ;	main.c:352: if ((int)ch == 13) { // Check until carriage return
      00051F 8C 01            [24] 1615 	mov	ar1,r4
      000521 7D 00            [12] 1616 	mov	r5,#0x00
      000523 B9 0D 05         [24] 1617 	cjne	r1,#0x0d,00496$
      000526 BD 00 02         [24] 1618 	cjne	r5,#0x00,00496$
      000529 80 71            [24] 1619 	sjmp	00118$
      00052B                       1620 00496$:
                                   1621 ;	main.c:356: if ((ch >= '0') && (ch <= '9')) {
      00052B BC 30 00         [24] 1622 	cjne	r4,#0x30,00497$
      00052E                       1623 00497$:
      00052E 40 0F            [24] 1624 	jc	00113$
      000530 EC               [12] 1625 	mov	a,r4
      000531 24 C6            [12] 1626 	add	a,#0xff - 0x39
      000533 40 0A            [24] 1627 	jc	00113$
                                   1628 ;	main.c:357: digit = ch - '0';
      000535 E9               [12] 1629 	mov	a,r1
      000536 24 D0            [12] 1630 	add	a,#0xd0
      000538 F9               [12] 1631 	mov	r1,a
      000539 ED               [12] 1632 	mov	a,r5
      00053A 34 FF            [12] 1633 	addc	a,#0xff
      00053C FD               [12] 1634 	mov	r5,a
      00053D 80 44            [24] 1635 	sjmp	00114$
      00053F                       1636 00113$:
                                   1637 ;	main.c:358: } else if ((ch >= 'A') && (ch <= 'F')) {
      00053F BC 41 00         [24] 1638 	cjne	r4,#0x41,00500$
      000542                       1639 00500$:
      000542 40 13            [24] 1640 	jc	00109$
      000544 EC               [12] 1641 	mov	a,r4
      000545 24 B9            [12] 1642 	add	a,#0xff - 0x46
      000547 40 0E            [24] 1643 	jc	00109$
                                   1644 ;	main.c:359: digit = ch - 7 - '0';
      000549 8C 00            [24] 1645 	mov	ar0,r4
      00054B 7B 00            [12] 1646 	mov	r3,#0x00
      00054D E8               [12] 1647 	mov	a,r0
      00054E 24 C9            [12] 1648 	add	a,#0xc9
      000550 F9               [12] 1649 	mov	r1,a
      000551 EB               [12] 1650 	mov	a,r3
      000552 34 FF            [12] 1651 	addc	a,#0xff
      000554 FD               [12] 1652 	mov	r5,a
      000555 80 2C            [24] 1653 	sjmp	00114$
      000557                       1654 00109$:
                                   1655 ;	main.c:360: } else if ((ch >= 'a') && (ch <= 'f')) {
      000557 BC 61 00         [24] 1656 	cjne	r4,#0x61,00503$
      00055A                       1657 00503$:
      00055A 40 11            [24] 1658 	jc	00105$
      00055C EC               [12] 1659 	mov	a,r4
      00055D 24 99            [12] 1660 	add	a,#0xff - 0x66
      00055F 40 0C            [24] 1661 	jc	00105$
                                   1662 ;	main.c:361: digit = ch - 32 - 7 - '0';
      000561 7B 00            [12] 1663 	mov	r3,#0x00
      000563 EC               [12] 1664 	mov	a,r4
      000564 24 A9            [12] 1665 	add	a,#0xa9
      000566 F9               [12] 1666 	mov	r1,a
      000567 EB               [12] 1667 	mov	a,r3
      000568 34 FF            [12] 1668 	addc	a,#0xff
      00056A FD               [12] 1669 	mov	r5,a
      00056B 80 16            [24] 1670 	sjmp	00114$
      00056D                       1671 00105$:
                                   1672 ;	main.c:363: printf("Invalid input. Please enter 0-9, A-F or a-f only.\r\n");
      00056D 74r31            [12] 1673 	mov	a,#___str_8
      00056F C0 E0            [24] 1674 	push	acc
      000571 74s01            [12] 1675 	mov	a,#(___str_8 >> 8)
      000573 C0 E0            [24] 1676 	push	acc
      000575 74 80            [12] 1677 	mov	a,#0x80
      000577 C0 E0            [24] 1678 	push	acc
      000579 12r00r00         [24] 1679 	lcall	_printf
      00057C 15 81            [12] 1680 	dec	sp
      00057E 15 81            [12] 1681 	dec	sp
      000580 15 81            [12] 1682 	dec	sp
                                   1683 ;	main.c:364: return;
      000582 22               [24] 1684 	ret
      000583                       1685 00114$:
                                   1686 ;	main.c:366: addr = addr * 16 + digit;
      000583 8E 03            [24] 1687 	mov	ar3,r6
      000585 EF               [12] 1688 	mov	a,r7
      000586 C4               [12] 1689 	swap	a
      000587 54 F0            [12] 1690 	anl	a,#0xf0
      000589 CB               [12] 1691 	xch	a,r3
      00058A C4               [12] 1692 	swap	a
      00058B CB               [12] 1693 	xch	a,r3
      00058C 6B               [12] 1694 	xrl	a,r3
      00058D CB               [12] 1695 	xch	a,r3
      00058E 54 F0            [12] 1696 	anl	a,#0xf0
      000590 CB               [12] 1697 	xch	a,r3
      000591 6B               [12] 1698 	xrl	a,r3
      000592 FC               [12] 1699 	mov	r4,a
      000593 E9               [12] 1700 	mov	a,r1
      000594 2B               [12] 1701 	add	a,r3
      000595 FE               [12] 1702 	mov	r6,a
      000596 ED               [12] 1703 	mov	a,r5
      000597 3C               [12] 1704 	addc	a,r4
      000598 FF               [12] 1705 	mov	r7,a
      000599 02r05r12         [24] 1706 	ljmp	00117$
      00059C                       1707 00118$:
                                   1708 ;	main.c:370: printf("Entered address: 0x%x\r\n", addr);
      00059C C0 07            [24] 1709 	push	ar7
      00059E C0 06            [24] 1710 	push	ar6
      0005A0 C0 06            [24] 1711 	push	ar6
      0005A2 C0 07            [24] 1712 	push	ar7
      0005A4 74r65            [12] 1713 	mov	a,#___str_9
      0005A6 C0 E0            [24] 1714 	push	acc
      0005A8 74s01            [12] 1715 	mov	a,#(___str_9 >> 8)
      0005AA C0 E0            [24] 1716 	push	acc
      0005AC 74 80            [12] 1717 	mov	a,#0x80
      0005AE C0 E0            [24] 1718 	push	acc
      0005B0 12r00r00         [24] 1719 	lcall	_printf
      0005B3 E5 81            [12] 1720 	mov	a,sp
      0005B5 24 FB            [12] 1721 	add	a,#0xfb
      0005B7 F5 81            [12] 1722 	mov	sp,a
      0005B9 D0 06            [24] 1723 	pop	ar6
      0005BB D0 07            [24] 1724 	pop	ar7
                                   1725 ;	main.c:373: if ((addr < 0x0) || (addr > 0x7FF)) {
      0005BD C3               [12] 1726 	clr	c
      0005BE 74 FF            [12] 1727 	mov	a,#0xff
      0005C0 9E               [12] 1728 	subb	a,r6
      0005C1 74 07            [12] 1729 	mov	a,#0x07
      0005C3 9F               [12] 1730 	subb	a,r7
      0005C4 50 20            [24] 1731 	jnc	00120$
                                   1732 ;	main.c:374: printf("Invalid buffer address. The address should be between 0 and 7FF.\r\n");
      0005C6 C0 07            [24] 1733 	push	ar7
      0005C8 C0 06            [24] 1734 	push	ar6
      0005CA 74r7D            [12] 1735 	mov	a,#___str_10
      0005CC C0 E0            [24] 1736 	push	acc
      0005CE 74s01            [12] 1737 	mov	a,#(___str_10 >> 8)
      0005D0 C0 E0            [24] 1738 	push	acc
      0005D2 74 80            [12] 1739 	mov	a,#0x80
      0005D4 C0 E0            [24] 1740 	push	acc
      0005D6 12r00r00         [24] 1741 	lcall	_printf
      0005D9 15 81            [12] 1742 	dec	sp
      0005DB 15 81            [12] 1743 	dec	sp
      0005DD 15 81            [12] 1744 	dec	sp
      0005DF D0 06            [24] 1745 	pop	ar6
      0005E1 D0 07            [24] 1746 	pop	ar7
                                   1747 ;	main.c:375: break;
      0005E3 02r04rA1         [24] 1748 	ljmp	00213$
      0005E6                       1749 00120$:
                                   1750 ;	main.c:378: printf("Enter the data byte to write:\r\n");
      0005E6 C0 07            [24] 1751 	push	ar7
      0005E8 C0 06            [24] 1752 	push	ar6
      0005EA 74rC0            [12] 1753 	mov	a,#___str_11
      0005EC C0 E0            [24] 1754 	push	acc
      0005EE 74s01            [12] 1755 	mov	a,#(___str_11 >> 8)
      0005F0 C0 E0            [24] 1756 	push	acc
      0005F2 74 80            [12] 1757 	mov	a,#0x80
      0005F4 C0 E0            [24] 1758 	push	acc
      0005F6 12r00r00         [24] 1759 	lcall	_printf
      0005F9 15 81            [12] 1760 	dec	sp
      0005FB 15 81            [12] 1761 	dec	sp
      0005FD 15 81            [12] 1762 	dec	sp
      0005FF D0 06            [24] 1763 	pop	ar6
      000601 D0 07            [24] 1764 	pop	ar7
                                   1765 ;	main.c:380: while (1) {
      000603                       1766 00137$:
                                   1767 ;	main.c:381: ch = getchar();
      000603 C0 07            [24] 1768 	push	ar7
      000605 C0 06            [24] 1769 	push	ar6
      000607 12r00r00         [24] 1770 	lcall	_getchar
      00060A AC 82            [24] 1771 	mov	r4,dpl
      00060C D0 06            [24] 1772 	pop	ar6
      00060E D0 07            [24] 1773 	pop	ar7
                                   1774 ;	main.c:383: if ((int)ch == 13) { // Check until carriage return
      000610 8C 03            [24] 1775 	mov	ar3,r4
      000612 7D 00            [12] 1776 	mov	r5,#0x00
      000614 BB 0D 05         [24] 1777 	cjne	r3,#0x0d,00507$
      000617 BD 00 02         [24] 1778 	cjne	r5,#0x00,00507$
      00061A 80 6E            [24] 1779 	sjmp	00138$
      00061C                       1780 00507$:
                                   1781 ;	main.c:387: if ((ch >= '0') && (ch <= '9')) {
      00061C BC 30 00         [24] 1782 	cjne	r4,#0x30,00508$
      00061F                       1783 00508$:
      00061F 40 0F            [24] 1784 	jc	00133$
      000621 EC               [12] 1785 	mov	a,r4
      000622 24 C6            [12] 1786 	add	a,#0xff - 0x39
      000624 40 0A            [24] 1787 	jc	00133$
                                   1788 ;	main.c:388: digit = ch - '0';
      000626 EB               [12] 1789 	mov	a,r3
      000627 24 D0            [12] 1790 	add	a,#0xd0
      000629 F9               [12] 1791 	mov	r1,a
      00062A ED               [12] 1792 	mov	a,r5
      00062B 34 FF            [12] 1793 	addc	a,#0xff
      00062D FA               [12] 1794 	mov	r2,a
      00062E 80 3E            [24] 1795 	sjmp	00134$
      000630                       1796 00133$:
                                   1797 ;	main.c:389: } else if ((ch >= 'A') && (ch <= 'F')) {
      000630 BC 41 00         [24] 1798 	cjne	r4,#0x41,00511$
      000633                       1799 00511$:
      000633 40 0F            [24] 1800 	jc	00129$
      000635 EC               [12] 1801 	mov	a,r4
      000636 24 B9            [12] 1802 	add	a,#0xff - 0x46
      000638 40 0A            [24] 1803 	jc	00129$
                                   1804 ;	main.c:390: digit = ch - 7 - '0';
      00063A EB               [12] 1805 	mov	a,r3
      00063B 24 C9            [12] 1806 	add	a,#0xc9
      00063D F9               [12] 1807 	mov	r1,a
      00063E ED               [12] 1808 	mov	a,r5
      00063F 34 FF            [12] 1809 	addc	a,#0xff
      000641 FA               [12] 1810 	mov	r2,a
      000642 80 2A            [24] 1811 	sjmp	00134$
      000644                       1812 00129$:
                                   1813 ;	main.c:391: } else if ((ch >= 'a') && (ch <= 'f')) {
      000644 BC 61 00         [24] 1814 	cjne	r4,#0x61,00514$
      000647                       1815 00514$:
      000647 40 0F            [24] 1816 	jc	00125$
      000649 EC               [12] 1817 	mov	a,r4
      00064A 24 99            [12] 1818 	add	a,#0xff - 0x66
      00064C 40 0A            [24] 1819 	jc	00125$
                                   1820 ;	main.c:392: digit = ch - 32 - 7 - '0';
      00064E EB               [12] 1821 	mov	a,r3
      00064F 24 A9            [12] 1822 	add	a,#0xa9
      000651 F9               [12] 1823 	mov	r1,a
      000652 ED               [12] 1824 	mov	a,r5
      000653 34 FF            [12] 1825 	addc	a,#0xff
      000655 FA               [12] 1826 	mov	r2,a
      000656 80 16            [24] 1827 	sjmp	00134$
      000658                       1828 00125$:
                                   1829 ;	main.c:394: printf("Invalid input. Please enter 0-9, A-F or a-f only.\r\n");
      000658 74r31            [12] 1830 	mov	a,#___str_8
      00065A C0 E0            [24] 1831 	push	acc
      00065C 74s01            [12] 1832 	mov	a,#(___str_8 >> 8)
      00065E C0 E0            [24] 1833 	push	acc
      000660 74 80            [12] 1834 	mov	a,#0x80
      000662 C0 E0            [24] 1835 	push	acc
      000664 12r00r00         [24] 1836 	lcall	_printf
      000667 15 81            [12] 1837 	dec	sp
      000669 15 81            [12] 1838 	dec	sp
      00066B 15 81            [12] 1839 	dec	sp
                                   1840 ;	main.c:395: return;
      00066D 22               [24] 1841 	ret
      00066E                       1842 00134$:
                                   1843 ;	main.c:397: data = data * 16 + digit;
      00066E AC*09            [24] 1844 	mov	r4,_main_data_131072_95
      000670 E5*0A            [12] 1845 	mov	a,(_main_data_131072_95 + 1)
      000672 C4               [12] 1846 	swap	a
      000673 54 F0            [12] 1847 	anl	a,#0xf0
      000675 CC               [12] 1848 	xch	a,r4
      000676 C4               [12] 1849 	swap	a
      000677 CC               [12] 1850 	xch	a,r4
      000678 6C               [12] 1851 	xrl	a,r4
      000679 CC               [12] 1852 	xch	a,r4
      00067A 54 F0            [12] 1853 	anl	a,#0xf0
      00067C CC               [12] 1854 	xch	a,r4
      00067D 6C               [12] 1855 	xrl	a,r4
      00067E FD               [12] 1856 	mov	r5,a
      00067F E9               [12] 1857 	mov	a,r1
      000680 2C               [12] 1858 	add	a,r4
      000681 F5*09            [12] 1859 	mov	_main_data_131072_95,a
      000683 EA               [12] 1860 	mov	a,r2
      000684 3D               [12] 1861 	addc	a,r5
      000685 F5*0A            [12] 1862 	mov	(_main_data_131072_95 + 1),a
      000687 02r06r03         [24] 1863 	ljmp	00137$
      00068A                       1864 00138$:
                                   1865 ;	main.c:401: printf("Entered data: 0x%x\r\n", data);
      00068A C0 07            [24] 1866 	push	ar7
      00068C C0 06            [24] 1867 	push	ar6
      00068E C0*09            [24] 1868 	push	_main_data_131072_95
      000690 C0*0A            [24] 1869 	push	(_main_data_131072_95 + 1)
      000692 74rE0            [12] 1870 	mov	a,#___str_12
      000694 C0 E0            [24] 1871 	push	acc
      000696 74s01            [12] 1872 	mov	a,#(___str_12 >> 8)
      000698 C0 E0            [24] 1873 	push	acc
      00069A 74 80            [12] 1874 	mov	a,#0x80
      00069C C0 E0            [24] 1875 	push	acc
      00069E 12r00r00         [24] 1876 	lcall	_printf
      0006A1 E5 81            [12] 1877 	mov	a,sp
      0006A3 24 FB            [12] 1878 	add	a,#0xfb
      0006A5 F5 81            [12] 1879 	mov	sp,a
      0006A7 D0 06            [24] 1880 	pop	ar6
      0006A9 D0 07            [24] 1881 	pop	ar7
                                   1882 ;	main.c:404: if ((data < 0x0) || (data > 0xFF)) {
      0006AB C3               [12] 1883 	clr	c
      0006AC 74 FF            [12] 1884 	mov	a,#0xff
      0006AE 95*09            [12] 1885 	subb	a,_main_data_131072_95
      0006B0 E4               [12] 1886 	clr	a
      0006B1 95*0A            [12] 1887 	subb	a,(_main_data_131072_95 + 1)
      0006B3 50 20            [24] 1888 	jnc	00140$
                                   1889 ;	main.c:405: printf("Invalid buffer data. The data should be between 0 and FF.\r\n");
      0006B5 C0 07            [24] 1890 	push	ar7
      0006B7 C0 06            [24] 1891 	push	ar6
      0006B9 74rF5            [12] 1892 	mov	a,#___str_13
      0006BB C0 E0            [24] 1893 	push	acc
      0006BD 74s01            [12] 1894 	mov	a,#(___str_13 >> 8)
      0006BF C0 E0            [24] 1895 	push	acc
      0006C1 74 80            [12] 1896 	mov	a,#0x80
      0006C3 C0 E0            [24] 1897 	push	acc
      0006C5 12r00r00         [24] 1898 	lcall	_printf
      0006C8 15 81            [12] 1899 	dec	sp
      0006CA 15 81            [12] 1900 	dec	sp
      0006CC 15 81            [12] 1901 	dec	sp
      0006CE D0 06            [24] 1902 	pop	ar6
      0006D0 D0 07            [24] 1903 	pop	ar7
                                   1904 ;	main.c:406: break;
      0006D2 02r04rA1         [24] 1905 	ljmp	00213$
      0006D5                       1906 00140$:
                                   1907 ;	main.c:409: eebytew(addr, data);
      0006D5 85*09*00         [24] 1908 	mov	_eebytew_PARM_2,_main_data_131072_95
      0006D8 8E 82            [24] 1909 	mov	dpl,r6
      0006DA 8F 83            [24] 1910 	mov	dph,r7
      0006DC 12r01rB6         [24] 1911 	lcall	_eebytew
                                   1912 ;	main.c:410: addr = 0;
      0006DF 7E 00            [12] 1913 	mov	r6,#0x00
      0006E1 7F 00            [12] 1914 	mov	r7,#0x00
                                   1915 ;	main.c:411: break;
      0006E3 02r04rA1         [24] 1916 	ljmp	00213$
                                   1917 ;	main.c:414: case 'r':
      0006E6                       1918 00142$:
                                   1919 ;	main.c:415: printf("Enter the address location to read the data from : \r\n");
      0006E6 C0 07            [24] 1920 	push	ar7
      0006E8 C0 06            [24] 1921 	push	ar6
      0006EA 74r31            [12] 1922 	mov	a,#___str_14
      0006EC C0 E0            [24] 1923 	push	acc
      0006EE 74s02            [12] 1924 	mov	a,#(___str_14 >> 8)
      0006F0 C0 E0            [24] 1925 	push	acc
      0006F2 74 80            [12] 1926 	mov	a,#0x80
      0006F4 C0 E0            [24] 1927 	push	acc
      0006F6 12r00r00         [24] 1928 	lcall	_printf
      0006F9 15 81            [12] 1929 	dec	sp
      0006FB 15 81            [12] 1930 	dec	sp
      0006FD 15 81            [12] 1931 	dec	sp
      0006FF D0 06            [24] 1932 	pop	ar6
      000701 D0 07            [24] 1933 	pop	ar7
                                   1934 ;	main.c:416: while (1) {
      000703                       1935 00158$:
                                   1936 ;	main.c:417: ch = getchar();
      000703 C0 07            [24] 1937 	push	ar7
      000705 C0 06            [24] 1938 	push	ar6
      000707 12r00r00         [24] 1939 	lcall	_getchar
      00070A AC 82            [24] 1940 	mov	r4,dpl
      00070C D0 06            [24] 1941 	pop	ar6
      00070E D0 07            [24] 1942 	pop	ar7
                                   1943 ;	main.c:419: if ((int)ch == 13) { // Check until carriage return
      000710 8C 03            [24] 1944 	mov	ar3,r4
      000712 7D 00            [12] 1945 	mov	r5,#0x00
      000714 BB 0D 05         [24] 1946 	cjne	r3,#0x0d,00518$
      000717 BD 00 02         [24] 1947 	cjne	r5,#0x00,00518$
      00071A 80 6E            [24] 1948 	sjmp	00159$
      00071C                       1949 00518$:
                                   1950 ;	main.c:423: if ((ch >= '0') && (ch <= '9')) {
      00071C BC 30 00         [24] 1951 	cjne	r4,#0x30,00519$
      00071F                       1952 00519$:
      00071F 40 0F            [24] 1953 	jc	00154$
      000721 EC               [12] 1954 	mov	a,r4
      000722 24 C6            [12] 1955 	add	a,#0xff - 0x39
      000724 40 0A            [24] 1956 	jc	00154$
                                   1957 ;	main.c:424: digit = ch - '0';
      000726 EB               [12] 1958 	mov	a,r3
      000727 24 D0            [12] 1959 	add	a,#0xd0
      000729 F9               [12] 1960 	mov	r1,a
      00072A ED               [12] 1961 	mov	a,r5
      00072B 34 FF            [12] 1962 	addc	a,#0xff
      00072D FA               [12] 1963 	mov	r2,a
      00072E 80 3E            [24] 1964 	sjmp	00155$
      000730                       1965 00154$:
                                   1966 ;	main.c:425: } else if ((ch >= 'A') && (ch <= 'F')) {
      000730 BC 41 00         [24] 1967 	cjne	r4,#0x41,00522$
      000733                       1968 00522$:
      000733 40 0F            [24] 1969 	jc	00150$
      000735 EC               [12] 1970 	mov	a,r4
      000736 24 B9            [12] 1971 	add	a,#0xff - 0x46
      000738 40 0A            [24] 1972 	jc	00150$
                                   1973 ;	main.c:426: digit = ch - 7 - '0';
      00073A EB               [12] 1974 	mov	a,r3
      00073B 24 C9            [12] 1975 	add	a,#0xc9
      00073D F9               [12] 1976 	mov	r1,a
      00073E ED               [12] 1977 	mov	a,r5
      00073F 34 FF            [12] 1978 	addc	a,#0xff
      000741 FA               [12] 1979 	mov	r2,a
      000742 80 2A            [24] 1980 	sjmp	00155$
      000744                       1981 00150$:
                                   1982 ;	main.c:427: } else if ((ch >= 'a') && (ch <= 'f')) {
      000744 BC 61 00         [24] 1983 	cjne	r4,#0x61,00525$
      000747                       1984 00525$:
      000747 40 0F            [24] 1985 	jc	00146$
      000749 EC               [12] 1986 	mov	a,r4
      00074A 24 99            [12] 1987 	add	a,#0xff - 0x66
      00074C 40 0A            [24] 1988 	jc	00146$
                                   1989 ;	main.c:428: digit = ch - 32 - 7 - '0';
      00074E EB               [12] 1990 	mov	a,r3
      00074F 24 A9            [12] 1991 	add	a,#0xa9
      000751 F9               [12] 1992 	mov	r1,a
      000752 ED               [12] 1993 	mov	a,r5
      000753 34 FF            [12] 1994 	addc	a,#0xff
      000755 FA               [12] 1995 	mov	r2,a
      000756 80 16            [24] 1996 	sjmp	00155$
      000758                       1997 00146$:
                                   1998 ;	main.c:430: printf("Invalid input. Please enter 0-9, A-F or a-f.\r\n");
      000758 74r67            [12] 1999 	mov	a,#___str_15
      00075A C0 E0            [24] 2000 	push	acc
      00075C 74s02            [12] 2001 	mov	a,#(___str_15 >> 8)
      00075E C0 E0            [24] 2002 	push	acc
      000760 74 80            [12] 2003 	mov	a,#0x80
      000762 C0 E0            [24] 2004 	push	acc
      000764 12r00r00         [24] 2005 	lcall	_printf
      000767 15 81            [12] 2006 	dec	sp
      000769 15 81            [12] 2007 	dec	sp
      00076B 15 81            [12] 2008 	dec	sp
                                   2009 ;	main.c:431: return;
      00076D 22               [24] 2010 	ret
      00076E                       2011 00155$:
                                   2012 ;	main.c:433: addr1 = addr1 * 16 + digit;
      00076E AC*03            [24] 2013 	mov	r4,_main_addr1_131072_95
      000770 E5*04            [12] 2014 	mov	a,(_main_addr1_131072_95 + 1)
      000772 C4               [12] 2015 	swap	a
      000773 54 F0            [12] 2016 	anl	a,#0xf0
      000775 CC               [12] 2017 	xch	a,r4
      000776 C4               [12] 2018 	swap	a
      000777 CC               [12] 2019 	xch	a,r4
      000778 6C               [12] 2020 	xrl	a,r4
      000779 CC               [12] 2021 	xch	a,r4
      00077A 54 F0            [12] 2022 	anl	a,#0xf0
      00077C CC               [12] 2023 	xch	a,r4
      00077D 6C               [12] 2024 	xrl	a,r4
      00077E FD               [12] 2025 	mov	r5,a
      00077F E9               [12] 2026 	mov	a,r1
      000780 2C               [12] 2027 	add	a,r4
      000781 F5*03            [12] 2028 	mov	_main_addr1_131072_95,a
      000783 EA               [12] 2029 	mov	a,r2
      000784 3D               [12] 2030 	addc	a,r5
      000785 F5*04            [12] 2031 	mov	(_main_addr1_131072_95 + 1),a
      000787 02r07r03         [24] 2032 	ljmp	00158$
      00078A                       2033 00159$:
                                   2034 ;	main.c:437: printf("Entered address: 0x%x\r\n", addr1);
      00078A C0 07            [24] 2035 	push	ar7
      00078C C0 06            [24] 2036 	push	ar6
      00078E C0*03            [24] 2037 	push	_main_addr1_131072_95
      000790 C0*04            [24] 2038 	push	(_main_addr1_131072_95 + 1)
      000792 74r65            [12] 2039 	mov	a,#___str_9
      000794 C0 E0            [24] 2040 	push	acc
      000796 74s01            [12] 2041 	mov	a,#(___str_9 >> 8)
      000798 C0 E0            [24] 2042 	push	acc
      00079A 74 80            [12] 2043 	mov	a,#0x80
      00079C C0 E0            [24] 2044 	push	acc
      00079E 12r00r00         [24] 2045 	lcall	_printf
      0007A1 E5 81            [12] 2046 	mov	a,sp
      0007A3 24 FB            [12] 2047 	add	a,#0xfb
      0007A5 F5 81            [12] 2048 	mov	sp,a
      0007A7 D0 06            [24] 2049 	pop	ar6
      0007A9 D0 07            [24] 2050 	pop	ar7
                                   2051 ;	main.c:440: if ((addr1 < 0x0) || (addr1 > 0x7FF)) {
      0007AB C3               [12] 2052 	clr	c
      0007AC 74 FF            [12] 2053 	mov	a,#0xff
      0007AE 95*03            [12] 2054 	subb	a,_main_addr1_131072_95
      0007B0 74 07            [12] 2055 	mov	a,#0x07
      0007B2 95*04            [12] 2056 	subb	a,(_main_addr1_131072_95 + 1)
      0007B4 50 16            [24] 2057 	jnc	00161$
                                   2058 ;	main.c:441: printf("Invalid buffer address. The address should be between 0 and 7FF.\r\n");
      0007B6 74r7D            [12] 2059 	mov	a,#___str_10
      0007B8 C0 E0            [24] 2060 	push	acc
      0007BA 74s01            [12] 2061 	mov	a,#(___str_10 >> 8)
      0007BC C0 E0            [24] 2062 	push	acc
      0007BE 74 80            [12] 2063 	mov	a,#0x80
      0007C0 C0 E0            [24] 2064 	push	acc
      0007C2 12r00r00         [24] 2065 	lcall	_printf
      0007C5 15 81            [12] 2066 	dec	sp
      0007C7 15 81            [12] 2067 	dec	sp
      0007C9 15 81            [12] 2068 	dec	sp
                                   2069 ;	main.c:442: return;
      0007CB 22               [24] 2070 	ret
      0007CC                       2071 00161$:
                                   2072 ;	main.c:444: unsigned char rd = eebyter(addr1);
      0007CC 85*03 82         [24] 2073 	mov	dpl,_main_addr1_131072_95
      0007CF 85*04 83         [24] 2074 	mov	dph,(_main_addr1_131072_95 + 1)
      0007D2 C0 07            [24] 2075 	push	ar7
      0007D4 C0 06            [24] 2076 	push	ar6
      0007D6 12r02r9B         [24] 2077 	lcall	_eebyter
      0007D9 AD 82            [24] 2078 	mov	r5,dpl
                                   2079 ;	main.c:445: printf("read data: 0x%x\r\n", rd);
      0007DB 7C 00            [12] 2080 	mov	r4,#0x00
      0007DD C0 05            [24] 2081 	push	ar5
      0007DF C0 04            [24] 2082 	push	ar4
      0007E1 74r96            [12] 2083 	mov	a,#___str_16
      0007E3 C0 E0            [24] 2084 	push	acc
      0007E5 74s02            [12] 2085 	mov	a,#(___str_16 >> 8)
      0007E7 C0 E0            [24] 2086 	push	acc
      0007E9 74 80            [12] 2087 	mov	a,#0x80
      0007EB C0 E0            [24] 2088 	push	acc
      0007ED 12r00r00         [24] 2089 	lcall	_printf
      0007F0 E5 81            [12] 2090 	mov	a,sp
      0007F2 24 FB            [12] 2091 	add	a,#0xfb
      0007F4 F5 81            [12] 2092 	mov	sp,a
      0007F6 D0 06            [24] 2093 	pop	ar6
      0007F8 D0 07            [24] 2094 	pop	ar7
                                   2095 ;	main.c:446: addr1 = 0;
      0007FA E4               [12] 2096 	clr	a
      0007FB F5*03            [12] 2097 	mov	_main_addr1_131072_95,a
      0007FD F5*04            [12] 2098 	mov	(_main_addr1_131072_95 + 1),a
                                   2099 ;	main.c:447: break;
      0007FF 02r04rA1         [24] 2100 	ljmp	00213$
                                   2101 ;	main.c:449: case 'h':
      000802                       2102 00163$:
                                   2103 ;	main.c:450: printf("Enter the start address for dump:\r\n");
      000802 74rA8            [12] 2104 	mov	a,#___str_17
      000804 C0 E0            [24] 2105 	push	acc
      000806 74s02            [12] 2106 	mov	a,#(___str_17 >> 8)
      000808 C0 E0            [24] 2107 	push	acc
      00080A 74 80            [12] 2108 	mov	a,#0x80
      00080C C0 E0            [24] 2109 	push	acc
      00080E 12r00r00         [24] 2110 	lcall	_printf
      000811 15 81            [12] 2111 	dec	sp
      000813 15 81            [12] 2112 	dec	sp
      000815 15 81            [12] 2113 	dec	sp
                                   2114 ;	main.c:451: while (1) {
      000817                       2115 00179$:
                                   2116 ;	main.c:452: ch = getchar();
      000817 12r00r00         [24] 2117 	lcall	_getchar
      00081A AC 82            [24] 2118 	mov	r4,dpl
                                   2119 ;	main.c:454: if ((int)ch == 13) { // Check until carriage return
      00081C 8C 05            [24] 2120 	mov	ar5,r4
      00081E 7B 00            [12] 2121 	mov	r3,#0x00
      000820 BD 0D 05         [24] 2122 	cjne	r5,#0x0d,00529$
      000823 BB 00 02         [24] 2123 	cjne	r3,#0x00,00529$
      000826 80 74            [24] 2124 	sjmp	00180$
      000828                       2125 00529$:
                                   2126 ;	main.c:458: if ((ch >= '0') && (ch <= '9')) {
      000828 BC 30 00         [24] 2127 	cjne	r4,#0x30,00530$
      00082B                       2128 00530$:
      00082B 40 0F            [24] 2129 	jc	00175$
      00082D EC               [12] 2130 	mov	a,r4
      00082E 24 C6            [12] 2131 	add	a,#0xff - 0x39
      000830 40 0A            [24] 2132 	jc	00175$
                                   2133 ;	main.c:459: digit = ch - '0';
      000832 ED               [12] 2134 	mov	a,r5
      000833 24 D0            [12] 2135 	add	a,#0xd0
      000835 FD               [12] 2136 	mov	r5,a
      000836 EB               [12] 2137 	mov	a,r3
      000837 34 FF            [12] 2138 	addc	a,#0xff
      000839 FB               [12] 2139 	mov	r3,a
      00083A 80 44            [24] 2140 	sjmp	00176$
      00083C                       2141 00175$:
                                   2142 ;	main.c:460: } else if ((ch >= 'A') && (ch <= 'F')) {
      00083C BC 41 00         [24] 2143 	cjne	r4,#0x41,00533$
      00083F                       2144 00533$:
      00083F 40 13            [24] 2145 	jc	00171$
      000841 EC               [12] 2146 	mov	a,r4
      000842 24 B9            [12] 2147 	add	a,#0xff - 0x46
      000844 40 0E            [24] 2148 	jc	00171$
                                   2149 ;	main.c:461: digit = ch - 7 - '0';
      000846 8C 01            [24] 2150 	mov	ar1,r4
      000848 7A 00            [12] 2151 	mov	r2,#0x00
      00084A E9               [12] 2152 	mov	a,r1
      00084B 24 C9            [12] 2153 	add	a,#0xc9
      00084D FD               [12] 2154 	mov	r5,a
      00084E EA               [12] 2155 	mov	a,r2
      00084F 34 FF            [12] 2156 	addc	a,#0xff
      000851 FB               [12] 2157 	mov	r3,a
      000852 80 2C            [24] 2158 	sjmp	00176$
      000854                       2159 00171$:
                                   2160 ;	main.c:462: } else if ((ch >= 'a') && (ch <= 'f')) {
      000854 BC 61 00         [24] 2161 	cjne	r4,#0x61,00536$
      000857                       2162 00536$:
      000857 40 11            [24] 2163 	jc	00167$
      000859 EC               [12] 2164 	mov	a,r4
      00085A 24 99            [12] 2165 	add	a,#0xff - 0x66
      00085C 40 0C            [24] 2166 	jc	00167$
                                   2167 ;	main.c:463: digit = ch - 32 - 7 - '0';
      00085E 7A 00            [12] 2168 	mov	r2,#0x00
      000860 EC               [12] 2169 	mov	a,r4
      000861 24 A9            [12] 2170 	add	a,#0xa9
      000863 FD               [12] 2171 	mov	r5,a
      000864 EA               [12] 2172 	mov	a,r2
      000865 34 FF            [12] 2173 	addc	a,#0xff
      000867 FB               [12] 2174 	mov	r3,a
      000868 80 16            [24] 2175 	sjmp	00176$
      00086A                       2176 00167$:
                                   2177 ;	main.c:465: printf("Invalid input. Please enter 0-9, A-F or a-f.\r\n");
      00086A 74r67            [12] 2178 	mov	a,#___str_15
      00086C C0 E0            [24] 2179 	push	acc
      00086E 74s02            [12] 2180 	mov	a,#(___str_15 >> 8)
      000870 C0 E0            [24] 2181 	push	acc
      000872 74 80            [12] 2182 	mov	a,#0x80
      000874 C0 E0            [24] 2183 	push	acc
      000876 12r00r00         [24] 2184 	lcall	_printf
      000879 15 81            [12] 2185 	dec	sp
      00087B 15 81            [12] 2186 	dec	sp
      00087D 15 81            [12] 2187 	dec	sp
                                   2188 ;	main.c:466: return;
      00087F 22               [24] 2189 	ret
      000880                       2190 00176$:
                                   2191 ;	main.c:468: start_addr = start_addr * 16 + digit;
      000880 AA*05            [24] 2192 	mov	r2,_main_start_addr_131072_95
      000882 E5*06            [12] 2193 	mov	a,(_main_start_addr_131072_95 + 1)
      000884 C4               [12] 2194 	swap	a
      000885 54 F0            [12] 2195 	anl	a,#0xf0
      000887 CA               [12] 2196 	xch	a,r2
      000888 C4               [12] 2197 	swap	a
      000889 CA               [12] 2198 	xch	a,r2
      00088A 6A               [12] 2199 	xrl	a,r2
      00088B CA               [12] 2200 	xch	a,r2
      00088C 54 F0            [12] 2201 	anl	a,#0xf0
      00088E CA               [12] 2202 	xch	a,r2
      00088F 6A               [12] 2203 	xrl	a,r2
      000890 FC               [12] 2204 	mov	r4,a
      000891 ED               [12] 2205 	mov	a,r5
      000892 2A               [12] 2206 	add	a,r2
      000893 F5*05            [12] 2207 	mov	_main_start_addr_131072_95,a
      000895 EB               [12] 2208 	mov	a,r3
      000896 3C               [12] 2209 	addc	a,r4
      000897 F5*06            [12] 2210 	mov	(_main_start_addr_131072_95 + 1),a
      000899 02r08r17         [24] 2211 	ljmp	00179$
      00089C                       2212 00180$:
                                   2213 ;	main.c:472: printf("Entered start address: 0x%x\r\n", start_addr);
      00089C C0*05            [24] 2214 	push	_main_start_addr_131072_95
      00089E C0*06            [24] 2215 	push	(_main_start_addr_131072_95 + 1)
      0008A0 74rCC            [12] 2216 	mov	a,#___str_18
      0008A2 C0 E0            [24] 2217 	push	acc
      0008A4 74s02            [12] 2218 	mov	a,#(___str_18 >> 8)
      0008A6 C0 E0            [24] 2219 	push	acc
      0008A8 74 80            [12] 2220 	mov	a,#0x80
      0008AA C0 E0            [24] 2221 	push	acc
      0008AC 12r00r00         [24] 2222 	lcall	_printf
      0008AF E5 81            [12] 2223 	mov	a,sp
      0008B1 24 FB            [12] 2224 	add	a,#0xfb
      0008B3 F5 81            [12] 2225 	mov	sp,a
                                   2226 ;	main.c:475: if ((start_addr < 0x0) || (start_addr > 0x7FF)) {
      0008B5 C3               [12] 2227 	clr	c
      0008B6 74 FF            [12] 2228 	mov	a,#0xff
      0008B8 95*05            [12] 2229 	subb	a,_main_start_addr_131072_95
      0008BA 74 07            [12] 2230 	mov	a,#0x07
      0008BC 95*06            [12] 2231 	subb	a,(_main_start_addr_131072_95 + 1)
      0008BE 50 16            [24] 2232 	jnc	00182$
                                   2233 ;	main.c:476: printf("Invalid start address. The address should be between 0 and 7FF.\r\n");
      0008C0 74rEA            [12] 2234 	mov	a,#___str_19
      0008C2 C0 E0            [24] 2235 	push	acc
      0008C4 74s02            [12] 2236 	mov	a,#(___str_19 >> 8)
      0008C6 C0 E0            [24] 2237 	push	acc
      0008C8 74 80            [12] 2238 	mov	a,#0x80
      0008CA C0 E0            [24] 2239 	push	acc
      0008CC 12r00r00         [24] 2240 	lcall	_printf
      0008CF 15 81            [12] 2241 	dec	sp
      0008D1 15 81            [12] 2242 	dec	sp
      0008D3 15 81            [12] 2243 	dec	sp
                                   2244 ;	main.c:477: return;
      0008D5 22               [24] 2245 	ret
      0008D6                       2246 00182$:
                                   2247 ;	main.c:480: printf("Enter the end address for dump:\r\n");
      0008D6 74r2C            [12] 2248 	mov	a,#___str_20
      0008D8 C0 E0            [24] 2249 	push	acc
      0008DA 74s03            [12] 2250 	mov	a,#(___str_20 >> 8)
      0008DC C0 E0            [24] 2251 	push	acc
      0008DE 74 80            [12] 2252 	mov	a,#0x80
      0008E0 C0 E0            [24] 2253 	push	acc
      0008E2 12r00r00         [24] 2254 	lcall	_printf
      0008E5 15 81            [12] 2255 	dec	sp
      0008E7 15 81            [12] 2256 	dec	sp
      0008E9 15 81            [12] 2257 	dec	sp
                                   2258 ;	main.c:481: while (1) {
      0008EB                       2259 00199$:
                                   2260 ;	main.c:482: ch = getchar();
      0008EB 12r00r00         [24] 2261 	lcall	_getchar
      0008EE AC 82            [24] 2262 	mov	r4,dpl
                                   2263 ;	main.c:484: if ((int)ch == 13) { // Check until carriage return
      0008F0 8C 03            [24] 2264 	mov	ar3,r4
      0008F2 7D 00            [12] 2265 	mov	r5,#0x00
      0008F4 BB 0D 05         [24] 2266 	cjne	r3,#0x0d,00540$
      0008F7 BD 00 02         [24] 2267 	cjne	r5,#0x00,00540$
      0008FA 80 6D            [24] 2268 	sjmp	00200$
      0008FC                       2269 00540$:
                                   2270 ;	main.c:488: if ((ch >= '0') && (ch <= '9')) {
      0008FC BC 30 00         [24] 2271 	cjne	r4,#0x30,00541$
      0008FF                       2272 00541$:
      0008FF 40 0F            [24] 2273 	jc	00195$
      000901 EC               [12] 2274 	mov	a,r4
      000902 24 C6            [12] 2275 	add	a,#0xff - 0x39
      000904 40 0A            [24] 2276 	jc	00195$
                                   2277 ;	main.c:489: digit = ch - '0';
      000906 EB               [12] 2278 	mov	a,r3
      000907 24 D0            [12] 2279 	add	a,#0xd0
      000909 FA               [12] 2280 	mov	r2,a
      00090A ED               [12] 2281 	mov	a,r5
      00090B 34 FF            [12] 2282 	addc	a,#0xff
      00090D F9               [12] 2283 	mov	r1,a
      00090E 80 3E            [24] 2284 	sjmp	00196$
      000910                       2285 00195$:
                                   2286 ;	main.c:490: } else if ((ch >= 'A') && (ch <= 'F')) {
      000910 BC 41 00         [24] 2287 	cjne	r4,#0x41,00544$
      000913                       2288 00544$:
      000913 40 0F            [24] 2289 	jc	00191$
      000915 EC               [12] 2290 	mov	a,r4
      000916 24 B9            [12] 2291 	add	a,#0xff - 0x46
      000918 40 0A            [24] 2292 	jc	00191$
                                   2293 ;	main.c:491: digit = ch - 7 - '0';
      00091A EB               [12] 2294 	mov	a,r3
      00091B 24 C9            [12] 2295 	add	a,#0xc9
      00091D FA               [12] 2296 	mov	r2,a
      00091E ED               [12] 2297 	mov	a,r5
      00091F 34 FF            [12] 2298 	addc	a,#0xff
      000921 F9               [12] 2299 	mov	r1,a
      000922 80 2A            [24] 2300 	sjmp	00196$
      000924                       2301 00191$:
                                   2302 ;	main.c:492: } else if ((ch >= 'a') && (ch <= 'f')) {
      000924 BC 61 00         [24] 2303 	cjne	r4,#0x61,00547$
      000927                       2304 00547$:
      000927 40 0F            [24] 2305 	jc	00187$
      000929 EC               [12] 2306 	mov	a,r4
      00092A 24 99            [12] 2307 	add	a,#0xff - 0x66
      00092C 40 0A            [24] 2308 	jc	00187$
                                   2309 ;	main.c:493: digit = ch - 32 - 7 - '0';
      00092E EB               [12] 2310 	mov	a,r3
      00092F 24 A9            [12] 2311 	add	a,#0xa9
      000931 FA               [12] 2312 	mov	r2,a
      000932 ED               [12] 2313 	mov	a,r5
      000933 34 FF            [12] 2314 	addc	a,#0xff
      000935 F9               [12] 2315 	mov	r1,a
      000936 80 16            [24] 2316 	sjmp	00196$
      000938                       2317 00187$:
                                   2318 ;	main.c:495: printf("Invalid input. Please enter 0-9, A-F or a-f.\r\n");
      000938 74r67            [12] 2319 	mov	a,#___str_15
      00093A C0 E0            [24] 2320 	push	acc
      00093C 74s02            [12] 2321 	mov	a,#(___str_15 >> 8)
      00093E C0 E0            [24] 2322 	push	acc
      000940 74 80            [12] 2323 	mov	a,#0x80
      000942 C0 E0            [24] 2324 	push	acc
      000944 12r00r00         [24] 2325 	lcall	_printf
      000947 15 81            [12] 2326 	dec	sp
      000949 15 81            [12] 2327 	dec	sp
      00094B 15 81            [12] 2328 	dec	sp
                                   2329 ;	main.c:496: return;
      00094D 22               [24] 2330 	ret
      00094E                       2331 00196$:
                                   2332 ;	main.c:498: end_addr = end_addr * 16 + digit;
      00094E AC*07            [24] 2333 	mov	r4,_main_end_addr_131072_95
      000950 E5*08            [12] 2334 	mov	a,(_main_end_addr_131072_95 + 1)
      000952 C4               [12] 2335 	swap	a
      000953 54 F0            [12] 2336 	anl	a,#0xf0
      000955 CC               [12] 2337 	xch	a,r4
      000956 C4               [12] 2338 	swap	a
      000957 CC               [12] 2339 	xch	a,r4
      000958 6C               [12] 2340 	xrl	a,r4
      000959 CC               [12] 2341 	xch	a,r4
      00095A 54 F0            [12] 2342 	anl	a,#0xf0
      00095C CC               [12] 2343 	xch	a,r4
      00095D 6C               [12] 2344 	xrl	a,r4
      00095E FD               [12] 2345 	mov	r5,a
      00095F EA               [12] 2346 	mov	a,r2
      000960 2C               [12] 2347 	add	a,r4
      000961 F5*07            [12] 2348 	mov	_main_end_addr_131072_95,a
      000963 E9               [12] 2349 	mov	a,r1
      000964 3D               [12] 2350 	addc	a,r5
      000965 F5*08            [12] 2351 	mov	(_main_end_addr_131072_95 + 1),a
      000967 80 82            [24] 2352 	sjmp	00199$
      000969                       2353 00200$:
                                   2354 ;	main.c:502: printf("Entered end address: 0x%x\r\n", end_addr);
      000969 C0*07            [24] 2355 	push	_main_end_addr_131072_95
      00096B C0*08            [24] 2356 	push	(_main_end_addr_131072_95 + 1)
      00096D 74r4E            [12] 2357 	mov	a,#___str_21
      00096F C0 E0            [24] 2358 	push	acc
      000971 74s03            [12] 2359 	mov	a,#(___str_21 >> 8)
      000973 C0 E0            [24] 2360 	push	acc
      000975 74 80            [12] 2361 	mov	a,#0x80
      000977 C0 E0            [24] 2362 	push	acc
      000979 12r00r00         [24] 2363 	lcall	_printf
      00097C E5 81            [12] 2364 	mov	a,sp
      00097E 24 FB            [12] 2365 	add	a,#0xfb
      000980 F5 81            [12] 2366 	mov	sp,a
                                   2367 ;	main.c:505: if ((end_addr < 0x0) || (end_addr > 0x7FF) || (end_addr < start_addr)) {
      000982 C3               [12] 2368 	clr	c
      000983 74 FF            [12] 2369 	mov	a,#0xff
      000985 95*07            [12] 2370 	subb	a,_main_end_addr_131072_95
      000987 74 07            [12] 2371 	mov	a,#0x07
      000989 95*08            [12] 2372 	subb	a,(_main_end_addr_131072_95 + 1)
      00098B 40 0A            [24] 2373 	jc	00201$
      00098D E5*07            [12] 2374 	mov	a,_main_end_addr_131072_95
      00098F 95*05            [12] 2375 	subb	a,_main_start_addr_131072_95
      000991 E5*08            [12] 2376 	mov	a,(_main_end_addr_131072_95 + 1)
      000993 95*06            [12] 2377 	subb	a,(_main_start_addr_131072_95 + 1)
      000995 50 16            [24] 2378 	jnc	00202$
      000997                       2379 00201$:
                                   2380 ;	main.c:506: printf("Invalid end address. The address should be between 0-7FF and more than the start address.\r\n");
      000997 74r6A            [12] 2381 	mov	a,#___str_22
      000999 C0 E0            [24] 2382 	push	acc
      00099B 74s03            [12] 2383 	mov	a,#(___str_22 >> 8)
      00099D C0 E0            [24] 2384 	push	acc
      00099F 74 80            [12] 2385 	mov	a,#0x80
      0009A1 C0 E0            [24] 2386 	push	acc
      0009A3 12r00r00         [24] 2387 	lcall	_printf
      0009A6 15 81            [12] 2388 	dec	sp
      0009A8 15 81            [12] 2389 	dec	sp
      0009AA 15 81            [12] 2390 	dec	sp
                                   2391 ;	main.c:507: return;
      0009AC 22               [24] 2392 	ret
      0009AD                       2393 00202$:
                                   2394 ;	main.c:510: printf("%03x:", start_addr);
      0009AD C0*05            [24] 2395 	push	_main_start_addr_131072_95
      0009AF C0*06            [24] 2396 	push	(_main_start_addr_131072_95 + 1)
      0009B1 74rC6            [12] 2397 	mov	a,#___str_23
      0009B3 C0 E0            [24] 2398 	push	acc
      0009B5 74s03            [12] 2399 	mov	a,#(___str_23 >> 8)
      0009B7 C0 E0            [24] 2400 	push	acc
      0009B9 74 80            [12] 2401 	mov	a,#0x80
      0009BB C0 E0            [24] 2402 	push	acc
      0009BD 12r00r00         [24] 2403 	lcall	_printf
      0009C0 E5 81            [12] 2404 	mov	a,sp
      0009C2 24 FB            [12] 2405 	add	a,#0xfb
      0009C4 F5 81            [12] 2406 	mov	sp,a
                                   2407 ;	main.c:512: for (int i=0; i<=end_addr - start_addr; i++)
      0009C6 E5*07            [12] 2408 	mov	a,_main_end_addr_131072_95
      0009C8 C3               [12] 2409 	clr	c
      0009C9 95*05            [12] 2410 	subb	a,_main_start_addr_131072_95
      0009CB FC               [12] 2411 	mov	r4,a
      0009CC E5*08            [12] 2412 	mov	a,(_main_end_addr_131072_95 + 1)
      0009CE 95*06            [12] 2413 	subb	a,(_main_start_addr_131072_95 + 1)
      0009D0 FD               [12] 2414 	mov	r5,a
      0009D1 85*05*01         [24] 2415 	mov	_main_addr_131072_95,_main_start_addr_131072_95
      0009D4 85*06*02         [24] 2416 	mov	(_main_addr_131072_95 + 1),(_main_start_addr_131072_95 + 1)
      0009D7 78 00            [12] 2417 	mov	r0,#0x00
      0009D9 79 00            [12] 2418 	mov	r1,#0x00
      0009DB                       2419 00216$:
      0009DB 88 02            [24] 2420 	mov	ar2,r0
      0009DD 89 03            [24] 2421 	mov	ar3,r1
      0009DF C3               [12] 2422 	clr	c
      0009E0 EC               [12] 2423 	mov	a,r4
      0009E1 9A               [12] 2424 	subb	a,r2
      0009E2 ED               [12] 2425 	mov	a,r5
      0009E3 9B               [12] 2426 	subb	a,r3
      0009E4 50 03            [24] 2427 	jnc	00552$
      0009E6 02r0ArA1         [24] 2428 	ljmp	00208$
      0009E9                       2429 00552$:
                                   2430 ;	main.c:514: if (i > 0 && i % 16 == 0) {
      0009E9 C3               [12] 2431 	clr	c
      0009EA E4               [12] 2432 	clr	a
      0009EB 98               [12] 2433 	subb	a,r0
      0009EC 74 80            [12] 2434 	mov	a,#(0x00 ^ 0x80)
      0009EE 89 F0            [24] 2435 	mov	b,r1
      0009F0 63 F0 80         [24] 2436 	xrl	b,#0x80
      0009F3 95 F0            [12] 2437 	subb	a,b
      0009F5 50 64            [24] 2438 	jnc	00206$
      0009F7 75*00 10         [24] 2439 	mov	__modsint_PARM_2,#0x10
      0009FA 75*01 00         [24] 2440 	mov	(__modsint_PARM_2 + 1),#0x00
      0009FD 88 82            [24] 2441 	mov	dpl,r0
      0009FF 89 83            [24] 2442 	mov	dph,r1
      000A01 C0 05            [24] 2443 	push	ar5
      000A03 C0 04            [24] 2444 	push	ar4
      000A05 C0 01            [24] 2445 	push	ar1
      000A07 C0 00            [24] 2446 	push	ar0
      000A09 12r00r00         [24] 2447 	lcall	__modsint
      000A0C E5 82            [12] 2448 	mov	a,dpl
      000A0E 85 83 F0         [24] 2449 	mov	b,dph
      000A11 D0 00            [24] 2450 	pop	ar0
      000A13 D0 01            [24] 2451 	pop	ar1
      000A15 D0 04            [24] 2452 	pop	ar4
      000A17 D0 05            [24] 2453 	pop	ar5
      000A19 45 F0            [12] 2454 	orl	a,b
      000A1B 70 3E            [24] 2455 	jnz	00206$
                                   2456 ;	main.c:515: printf("\r\n");  // Start a new line after every 16 bytes
      000A1D C0 05            [24] 2457 	push	ar5
      000A1F C0 04            [24] 2458 	push	ar4
      000A21 C0 01            [24] 2459 	push	ar1
      000A23 C0 00            [24] 2460 	push	ar0
      000A25 74rF9            [12] 2461 	mov	a,#___str_6
      000A27 C0 E0            [24] 2462 	push	acc
      000A29 74s00            [12] 2463 	mov	a,#(___str_6 >> 8)
      000A2B C0 E0            [24] 2464 	push	acc
      000A2D 74 80            [12] 2465 	mov	a,#0x80
      000A2F C0 E0            [24] 2466 	push	acc
      000A31 12r00r00         [24] 2467 	lcall	_printf
      000A34 15 81            [12] 2468 	dec	sp
      000A36 15 81            [12] 2469 	dec	sp
      000A38 15 81            [12] 2470 	dec	sp
                                   2471 ;	main.c:516: printf("%03x:", addr);
      000A3A C0*01            [24] 2472 	push	_main_addr_131072_95
      000A3C C0*02            [24] 2473 	push	(_main_addr_131072_95 + 1)
      000A3E 74rC6            [12] 2474 	mov	a,#___str_23
      000A40 C0 E0            [24] 2475 	push	acc
      000A42 74s03            [12] 2476 	mov	a,#(___str_23 >> 8)
      000A44 C0 E0            [24] 2477 	push	acc
      000A46 74 80            [12] 2478 	mov	a,#0x80
      000A48 C0 E0            [24] 2479 	push	acc
      000A4A 12r00r00         [24] 2480 	lcall	_printf
      000A4D E5 81            [12] 2481 	mov	a,sp
      000A4F 24 FB            [12] 2482 	add	a,#0xfb
      000A51 F5 81            [12] 2483 	mov	sp,a
      000A53 D0 00            [24] 2484 	pop	ar0
      000A55 D0 01            [24] 2485 	pop	ar1
      000A57 D0 04            [24] 2486 	pop	ar4
      000A59 D0 05            [24] 2487 	pop	ar5
      000A5B                       2488 00206$:
                                   2489 ;	main.c:518: printf("%x ", eebyter(addr));
      000A5B 85*01 82         [24] 2490 	mov	dpl,_main_addr_131072_95
      000A5E 85*02 83         [24] 2491 	mov	dph,(_main_addr_131072_95 + 1)
      000A61 C0 05            [24] 2492 	push	ar5
      000A63 C0 04            [24] 2493 	push	ar4
      000A65 C0 01            [24] 2494 	push	ar1
      000A67 C0 00            [24] 2495 	push	ar0
      000A69 12r02r9B         [24] 2496 	lcall	_eebyter
      000A6C AB 82            [24] 2497 	mov	r3,dpl
      000A6E 7A 00            [12] 2498 	mov	r2,#0x00
      000A70 C0 03            [24] 2499 	push	ar3
      000A72 C0 02            [24] 2500 	push	ar2
      000A74 74rCC            [12] 2501 	mov	a,#___str_24
      000A76 C0 E0            [24] 2502 	push	acc
      000A78 74s03            [12] 2503 	mov	a,#(___str_24 >> 8)
      000A7A C0 E0            [24] 2504 	push	acc
      000A7C 74 80            [12] 2505 	mov	a,#0x80
      000A7E C0 E0            [24] 2506 	push	acc
      000A80 12r00r00         [24] 2507 	lcall	_printf
      000A83 E5 81            [12] 2508 	mov	a,sp
      000A85 24 FB            [12] 2509 	add	a,#0xfb
      000A87 F5 81            [12] 2510 	mov	sp,a
      000A89 D0 00            [24] 2511 	pop	ar0
      000A8B D0 01            [24] 2512 	pop	ar1
      000A8D D0 04            [24] 2513 	pop	ar4
      000A8F D0 05            [24] 2514 	pop	ar5
                                   2515 ;	main.c:519: addr += 1;
      000A91 05*01            [12] 2516 	inc	_main_addr_131072_95
      000A93 E4               [12] 2517 	clr	a
      000A94 B5*01 02         [24] 2518 	cjne	a,_main_addr_131072_95,00555$
      000A97 05*02            [12] 2519 	inc	(_main_addr_131072_95 + 1)
      000A99                       2520 00555$:
                                   2521 ;	main.c:512: for (int i=0; i<=end_addr - start_addr; i++)
      000A99 08               [12] 2522 	inc	r0
      000A9A B8 00 01         [24] 2523 	cjne	r0,#0x00,00556$
      000A9D 09               [12] 2524 	inc	r1
      000A9E                       2525 00556$:
      000A9E 02r09rDB         [24] 2526 	ljmp	00216$
      000AA1                       2527 00208$:
                                   2528 ;	main.c:521: printf("\r\n");
      000AA1 74rF9            [12] 2529 	mov	a,#___str_6
      000AA3 C0 E0            [24] 2530 	push	acc
      000AA5 74s00            [12] 2531 	mov	a,#(___str_6 >> 8)
      000AA7 C0 E0            [24] 2532 	push	acc
      000AA9 74 80            [12] 2533 	mov	a,#0x80
      000AAB C0 E0            [24] 2534 	push	acc
      000AAD 12r00r00         [24] 2535 	lcall	_printf
      000AB0 15 81            [12] 2536 	dec	sp
      000AB2 15 81            [12] 2537 	dec	sp
      000AB4 15 81            [12] 2538 	dec	sp
                                   2539 ;	main.c:522: start_addr = 0;
                                   2540 ;	main.c:524: addr = 0;
      000AB6 E4               [12] 2541 	clr	a
      000AB7 F5*05            [12] 2542 	mov	_main_start_addr_131072_95,a
      000AB9 F5*06            [12] 2543 	mov	(_main_start_addr_131072_95 + 1),a
      000ABB FE               [12] 2544 	mov	r6,a
      000ABC FF               [12] 2545 	mov	r7,a
                                   2546 ;	main.c:525: break;
      000ABD 02r04rA1         [24] 2547 	ljmp	00213$
                                   2548 ;	main.c:527: case 'e':
      000AC0                       2549 00209$:
                                   2550 ;	main.c:528: printf("Resetting EEPROM\r\n");
      000AC0 C0 07            [24] 2551 	push	ar7
      000AC2 C0 06            [24] 2552 	push	ar6
      000AC4 74rD0            [12] 2553 	mov	a,#___str_25
      000AC6 C0 E0            [24] 2554 	push	acc
      000AC8 74s03            [12] 2555 	mov	a,#(___str_25 >> 8)
      000ACA C0 E0            [24] 2556 	push	acc
      000ACC 74 80            [12] 2557 	mov	a,#0x80
      000ACE C0 E0            [24] 2558 	push	acc
      000AD0 12r00r00         [24] 2559 	lcall	_printf
      000AD3 15 81            [12] 2560 	dec	sp
      000AD5 15 81            [12] 2561 	dec	sp
      000AD7 15 81            [12] 2562 	dec	sp
                                   2563 ;	main.c:529: eereset();
      000AD9 12r01r79         [24] 2564 	lcall	_eereset
      000ADC D0 06            [24] 2565 	pop	ar6
      000ADE D0 07            [24] 2566 	pop	ar7
                                   2567 ;	main.c:530: break;
      000AE0 02r04rA1         [24] 2568 	ljmp	00213$
                                   2569 ;	main.c:532: default:
      000AE3                       2570 00210$:
                                   2571 ;	main.c:533: printf("Invalid input\r\n");
      000AE3 C0 07            [24] 2572 	push	ar7
      000AE5 C0 06            [24] 2573 	push	ar6
      000AE7 74rE3            [12] 2574 	mov	a,#___str_26
      000AE9 C0 E0            [24] 2575 	push	acc
      000AEB 74s03            [12] 2576 	mov	a,#(___str_26 >> 8)
      000AED C0 E0            [24] 2577 	push	acc
      000AEF 74 80            [12] 2578 	mov	a,#0x80
      000AF1 C0 E0            [24] 2579 	push	acc
      000AF3 12r00r00         [24] 2580 	lcall	_printf
      000AF6 15 81            [12] 2581 	dec	sp
      000AF8 15 81            [12] 2582 	dec	sp
      000AFA 15 81            [12] 2583 	dec	sp
      000AFC D0 06            [24] 2584 	pop	ar6
      000AFE D0 07            [24] 2585 	pop	ar7
                                   2586 ;	main.c:536: }
                                   2587 ;	main.c:539: }
      000B00 02r04rA1         [24] 2588 	ljmp	00213$
                                   2589 	.area CSEG    (CODE)
                                   2590 	.area CONST   (CODE)
                                   2591 	.area CONST   (CODE)
      000000                       2592 ___str_0:
      000000 53 74 61 72 74 69 6E  2593 	.ascii "Starting I2C application"
             67 20 49 32 43 20 61
             70 70 6C 69 63 61 74
             69 6F 6E
      000018 0D                    2594 	.db 0x0d
      000019 0A                    2595 	.db 0x0a
      00001A 00                    2596 	.db 0x00
                                   2597 	.area CSEG    (CODE)
                                   2598 	.area CONST   (CODE)
      00001B                       2599 ___str_1:
      00001B 48 65 6C 70 20 6D 65  2600 	.ascii "Help menu:"
             6E 75 3A
      000025 0D                    2601 	.db 0x0d
      000026 0A                    2602 	.db 0x0a
      000027 00                    2603 	.db 0x00
                                   2604 	.area CSEG    (CODE)
                                   2605 	.area CONST   (CODE)
      000028                       2606 ___str_2:
      000028 27 77 27 3A 20 45 6E  2607 	.ascii "'w': Enter an EEPROM address in hex to write data at and byt"
             74 65 72 20 61 6E 20
             45 45 50 52 4F 4D 20
             61 64 64 72 65 73 73
             20 69 6E 20 68 65 78
             20 74 6F 20 77 72 69
             74 65 20 64 61 74 61
             20 61 74 20 61 6E 64
             20 62 79 74
      000064 65 20 64 61 74 61     2608 	.ascii "e data"
      00006A 0D                    2609 	.db 0x0d
      00006B 0A                    2610 	.db 0x0a
      00006C 00                    2611 	.db 0x00
                                   2612 	.area CSEG    (CODE)
                                   2613 	.area CONST   (CODE)
      00006D                       2614 ___str_3:
      00006D 27 72 27 3A 20 45 6E  2615 	.ascii "'r': Enter an EEPROM address in hex to read data from"
             74 65 72 20 61 6E 20
             45 45 50 52 4F 4D 20
             61 64 64 72 65 73 73
             20 69 6E 20 68 65 78
             20 74 6F 20 72 65 61
             64 20 64 61 74 61 20
             66 72 6F 6D
      0000A2 0D                    2616 	.db 0x0d
      0000A3 0A                    2617 	.db 0x0a
      0000A4 00                    2618 	.db 0x00
                                   2619 	.area CSEG    (CODE)
                                   2620 	.area CONST   (CODE)
      0000A5                       2621 ___str_4:
      0000A5 27 68 27 3A 20 45 6E  2622 	.ascii "'h': Enter an EEPROM start and end addresses to dump the dat"
             74 65 72 20 61 6E 20
             45 45 50 52 4F 4D 20
             73 74 61 72 74 20 61
             6E 64 20 65 6E 64 20
             61 64 64 72 65 73 73
             65 73 20 74 6F 20 64
             75 6D 70 20 74 68 65
             20 64 61 74
      0000E1 61                    2623 	.ascii "a"
      0000E2 0D                    2624 	.db 0x0d
      0000E3 0A                    2625 	.db 0x0a
      0000E4 00                    2626 	.db 0x00
                                   2627 	.area CSEG    (CODE)
                                   2628 	.area CONST   (CODE)
      0000E5                       2629 ___str_5:
      0000E5 27 65 27 3A 20 52 65  2630 	.ascii "'e': Reset EEPROM"
             73 65 74 20 45 45 50
             52 4F 4D
      0000F6 0D                    2631 	.db 0x0d
      0000F7 0A                    2632 	.db 0x0a
      0000F8 00                    2633 	.db 0x00
                                   2634 	.area CSEG    (CODE)
                                   2635 	.area CONST   (CODE)
      0000F9                       2636 ___str_6:
      0000F9 0D                    2637 	.db 0x0d
      0000FA 0A                    2638 	.db 0x0a
      0000FB 00                    2639 	.db 0x00
                                   2640 	.area CSEG    (CODE)
                                   2641 	.area CONST   (CODE)
      0000FC                       2642 ___str_7:
      0000FC 45 6E 74 65 72 20 74  2643 	.ascii "Enter the address location to store the data at : "
             68 65 20 61 64 64 72
             65 73 73 20 6C 6F 63
             61 74 69 6F 6E 20 74
             6F 20 73 74 6F 72 65
             20 74 68 65 20 64 61
             74 61 20 61 74 20 3A
             20
      00012E 0D                    2644 	.db 0x0d
      00012F 0A                    2645 	.db 0x0a
      000130 00                    2646 	.db 0x00
                                   2647 	.area CSEG    (CODE)
                                   2648 	.area CONST   (CODE)
      000131                       2649 ___str_8:
      000131 49 6E 76 61 6C 69 64  2650 	.ascii "Invalid input. Please enter 0-9, A-F or a-f only."
             20 69 6E 70 75 74 2E
             20 50 6C 65 61 73 65
             20 65 6E 74 65 72 20
             30 2D 39 2C 20 41 2D
             46 20 6F 72 20 61 2D
             66 20 6F 6E 6C 79 2E
      000162 0D                    2651 	.db 0x0d
      000163 0A                    2652 	.db 0x0a
      000164 00                    2653 	.db 0x00
                                   2654 	.area CSEG    (CODE)
                                   2655 	.area CONST   (CODE)
      000165                       2656 ___str_9:
      000165 45 6E 74 65 72 65 64  2657 	.ascii "Entered address: 0x%x"
             20 61 64 64 72 65 73
             73 3A 20 30 78 25 78
      00017A 0D                    2658 	.db 0x0d
      00017B 0A                    2659 	.db 0x0a
      00017C 00                    2660 	.db 0x00
                                   2661 	.area CSEG    (CODE)
                                   2662 	.area CONST   (CODE)
      00017D                       2663 ___str_10:
      00017D 49 6E 76 61 6C 69 64  2664 	.ascii "Invalid buffer address. The address should be between 0 and "
             20 62 75 66 66 65 72
             20 61 64 64 72 65 73
             73 2E 20 54 68 65 20
             61 64 64 72 65 73 73
             20 73 68 6F 75 6C 64
             20 62 65 20 62 65 74
             77 65 65 6E 20 30 20
             61 6E 64 20
      0001B9 37 46 46 2E           2665 	.ascii "7FF."
      0001BD 0D                    2666 	.db 0x0d
      0001BE 0A                    2667 	.db 0x0a
      0001BF 00                    2668 	.db 0x00
                                   2669 	.area CSEG    (CODE)
                                   2670 	.area CONST   (CODE)
      0001C0                       2671 ___str_11:
      0001C0 45 6E 74 65 72 20 74  2672 	.ascii "Enter the data byte to write:"
             68 65 20 64 61 74 61
             20 62 79 74 65 20 74
             6F 20 77 72 69 74 65
             3A
      0001DD 0D                    2673 	.db 0x0d
      0001DE 0A                    2674 	.db 0x0a
      0001DF 00                    2675 	.db 0x00
                                   2676 	.area CSEG    (CODE)
                                   2677 	.area CONST   (CODE)
      0001E0                       2678 ___str_12:
      0001E0 45 6E 74 65 72 65 64  2679 	.ascii "Entered data: 0x%x"
             20 64 61 74 61 3A 20
             30 78 25 78
      0001F2 0D                    2680 	.db 0x0d
      0001F3 0A                    2681 	.db 0x0a
      0001F4 00                    2682 	.db 0x00
                                   2683 	.area CSEG    (CODE)
                                   2684 	.area CONST   (CODE)
      0001F5                       2685 ___str_13:
      0001F5 49 6E 76 61 6C 69 64  2686 	.ascii "Invalid buffer data. The data should be between 0 and FF."
             20 62 75 66 66 65 72
             20 64 61 74 61 2E 20
             54 68 65 20 64 61 74
             61 20 73 68 6F 75 6C
             64 20 62 65 20 62 65
             74 77 65 65 6E 20 30
             20 61 6E 64 20 46 46
             2E
      00022E 0D                    2687 	.db 0x0d
      00022F 0A                    2688 	.db 0x0a
      000230 00                    2689 	.db 0x00
                                   2690 	.area CSEG    (CODE)
                                   2691 	.area CONST   (CODE)
      000231                       2692 ___str_14:
      000231 45 6E 74 65 72 20 74  2693 	.ascii "Enter the address location to read the data from : "
             68 65 20 61 64 64 72
             65 73 73 20 6C 6F 63
             61 74 69 6F 6E 20 74
             6F 20 72 65 61 64 20
             74 68 65 20 64 61 74
             61 20 66 72 6F 6D 20
             3A 20
      000264 0D                    2694 	.db 0x0d
      000265 0A                    2695 	.db 0x0a
      000266 00                    2696 	.db 0x00
                                   2697 	.area CSEG    (CODE)
                                   2698 	.area CONST   (CODE)
      000267                       2699 ___str_15:
      000267 49 6E 76 61 6C 69 64  2700 	.ascii "Invalid input. Please enter 0-9, A-F or a-f."
             20 69 6E 70 75 74 2E
             20 50 6C 65 61 73 65
             20 65 6E 74 65 72 20
             30 2D 39 2C 20 41 2D
             46 20 6F 72 20 61 2D
             66 2E
      000293 0D                    2701 	.db 0x0d
      000294 0A                    2702 	.db 0x0a
      000295 00                    2703 	.db 0x00
                                   2704 	.area CSEG    (CODE)
                                   2705 	.area CONST   (CODE)
      000296                       2706 ___str_16:
      000296 72 65 61 64 20 64 61  2707 	.ascii "read data: 0x%x"
             74 61 3A 20 30 78 25
             78
      0002A5 0D                    2708 	.db 0x0d
      0002A6 0A                    2709 	.db 0x0a
      0002A7 00                    2710 	.db 0x00
                                   2711 	.area CSEG    (CODE)
                                   2712 	.area CONST   (CODE)
      0002A8                       2713 ___str_17:
      0002A8 45 6E 74 65 72 20 74  2714 	.ascii "Enter the start address for dump:"
             68 65 20 73 74 61 72
             74 20 61 64 64 72 65
             73 73 20 66 6F 72 20
             64 75 6D 70 3A
      0002C9 0D                    2715 	.db 0x0d
      0002CA 0A                    2716 	.db 0x0a
      0002CB 00                    2717 	.db 0x00
                                   2718 	.area CSEG    (CODE)
                                   2719 	.area CONST   (CODE)
      0002CC                       2720 ___str_18:
      0002CC 45 6E 74 65 72 65 64  2721 	.ascii "Entered start address: 0x%x"
             20 73 74 61 72 74 20
             61 64 64 72 65 73 73
             3A 20 30 78 25 78
      0002E7 0D                    2722 	.db 0x0d
      0002E8 0A                    2723 	.db 0x0a
      0002E9 00                    2724 	.db 0x00
                                   2725 	.area CSEG    (CODE)
                                   2726 	.area CONST   (CODE)
      0002EA                       2727 ___str_19:
      0002EA 49 6E 76 61 6C 69 64  2728 	.ascii "Invalid start address. The address should be between 0 and 7"
             20 73 74 61 72 74 20
             61 64 64 72 65 73 73
             2E 20 54 68 65 20 61
             64 64 72 65 73 73 20
             73 68 6F 75 6C 64 20
             62 65 20 62 65 74 77
             65 65 6E 20 30 20 61
             6E 64 20 37
      000326 46 46 2E              2729 	.ascii "FF."
      000329 0D                    2730 	.db 0x0d
      00032A 0A                    2731 	.db 0x0a
      00032B 00                    2732 	.db 0x00
                                   2733 	.area CSEG    (CODE)
                                   2734 	.area CONST   (CODE)
      00032C                       2735 ___str_20:
      00032C 45 6E 74 65 72 20 74  2736 	.ascii "Enter the end address for dump:"
             68 65 20 65 6E 64 20
             61 64 64 72 65 73 73
             20 66 6F 72 20 64 75
             6D 70 3A
      00034B 0D                    2737 	.db 0x0d
      00034C 0A                    2738 	.db 0x0a
      00034D 00                    2739 	.db 0x00
                                   2740 	.area CSEG    (CODE)
                                   2741 	.area CONST   (CODE)
      00034E                       2742 ___str_21:
      00034E 45 6E 74 65 72 65 64  2743 	.ascii "Entered end address: 0x%x"
             20 65 6E 64 20 61 64
             64 72 65 73 73 3A 20
             30 78 25 78
      000367 0D                    2744 	.db 0x0d
      000368 0A                    2745 	.db 0x0a
      000369 00                    2746 	.db 0x00
                                   2747 	.area CSEG    (CODE)
                                   2748 	.area CONST   (CODE)
      00036A                       2749 ___str_22:
      00036A 49 6E 76 61 6C 69 64  2750 	.ascii "Invalid end address. The address should be between 0-7FF and"
             20 65 6E 64 20 61 64
             64 72 65 73 73 2E 20
             54 68 65 20 61 64 64
             72 65 73 73 20 73 68
             6F 75 6C 64 20 62 65
             20 62 65 74 77 65 65
             6E 20 30 2D 37 46 46
             20 61 6E 64
      0003A6 20 6D 6F 72 65 20 74  2751 	.ascii " more than the start address."
             68 61 6E 20 74 68 65
             20 73 74 61 72 74 20
             61 64 64 72 65 73 73
             2E
      0003C3 0D                    2752 	.db 0x0d
      0003C4 0A                    2753 	.db 0x0a
      0003C5 00                    2754 	.db 0x00
                                   2755 	.area CSEG    (CODE)
                                   2756 	.area CONST   (CODE)
      0003C6                       2757 ___str_23:
      0003C6 25 30 33 78 3A        2758 	.ascii "%03x:"
      0003CB 00                    2759 	.db 0x00
                                   2760 	.area CSEG    (CODE)
                                   2761 	.area CONST   (CODE)
      0003CC                       2762 ___str_24:
      0003CC 25 78 20              2763 	.ascii "%x "
      0003CF 00                    2764 	.db 0x00
                                   2765 	.area CSEG    (CODE)
                                   2766 	.area CONST   (CODE)
      0003D0                       2767 ___str_25:
      0003D0 52 65 73 65 74 74 69  2768 	.ascii "Resetting EEPROM"
             6E 67 20 45 45 50 52
             4F 4D
      0003E0 0D                    2769 	.db 0x0d
      0003E1 0A                    2770 	.db 0x0a
      0003E2 00                    2771 	.db 0x00
                                   2772 	.area CSEG    (CODE)
                                   2773 	.area CONST   (CODE)
      0003E3                       2774 ___str_26:
      0003E3 49 6E 76 61 6C 69 64  2775 	.ascii "Invalid input"
             20 69 6E 70 75 74
      0003F0 0D                    2776 	.db 0x0d
      0003F1 0A                    2777 	.db 0x0a
      0003F2 00                    2778 	.db 0x00
                                   2779 	.area CSEG    (CODE)
                                   2780 	.area XINIT   (CODE)
                                   2781 	.area CABS    (ABS,CODE)
