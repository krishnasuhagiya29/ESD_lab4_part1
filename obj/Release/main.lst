                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 4.2.0 #13081 (MINGW64)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _eebyter
                                     13 	.globl _eebytew
                                     14 	.globl _RepeatedStartI2c
                                     15 	.globl _I2C_Stop
                                     16 	.globl _I2C_ReStart
                                     17 	.globl _I2C_Send_ACK
                                     18 	.globl _I2C_Read_Byte
                                     19 	.globl _I2C_Write_Byte
                                     20 	.globl _I2C_Start
                                     21 	.globl _I2C_init
                                     22 	.globl _delay
                                     23 	.globl _printf
                                     24 	.globl _CY
                                     25 	.globl _AC
                                     26 	.globl _F0
                                     27 	.globl _RS1
                                     28 	.globl _RS0
                                     29 	.globl _OV
                                     30 	.globl _F1
                                     31 	.globl _P
                                     32 	.globl _PS
                                     33 	.globl _PT1
                                     34 	.globl _PX1
                                     35 	.globl _PT0
                                     36 	.globl _PX0
                                     37 	.globl _RD
                                     38 	.globl _WR
                                     39 	.globl _T1
                                     40 	.globl _T0
                                     41 	.globl _INT1
                                     42 	.globl _INT0
                                     43 	.globl _TXD
                                     44 	.globl _RXD
                                     45 	.globl _P3_7
                                     46 	.globl _P3_6
                                     47 	.globl _P3_5
                                     48 	.globl _P3_4
                                     49 	.globl _P3_3
                                     50 	.globl _P3_2
                                     51 	.globl _P3_1
                                     52 	.globl _P3_0
                                     53 	.globl _EA
                                     54 	.globl _ES
                                     55 	.globl _ET1
                                     56 	.globl _EX1
                                     57 	.globl _ET0
                                     58 	.globl _EX0
                                     59 	.globl _P2_7
                                     60 	.globl _P2_6
                                     61 	.globl _P2_5
                                     62 	.globl _P2_4
                                     63 	.globl _P2_3
                                     64 	.globl _P2_2
                                     65 	.globl _P2_1
                                     66 	.globl _P2_0
                                     67 	.globl _SM0
                                     68 	.globl _SM1
                                     69 	.globl _SM2
                                     70 	.globl _REN
                                     71 	.globl _TB8
                                     72 	.globl _RB8
                                     73 	.globl _TI
                                     74 	.globl _RI
                                     75 	.globl _P1_7
                                     76 	.globl _P1_6
                                     77 	.globl _P1_5
                                     78 	.globl _P1_4
                                     79 	.globl _P1_3
                                     80 	.globl _P1_2
                                     81 	.globl _P1_1
                                     82 	.globl _P1_0
                                     83 	.globl _TF1
                                     84 	.globl _TR1
                                     85 	.globl _TF0
                                     86 	.globl _TR0
                                     87 	.globl _IE1
                                     88 	.globl _IT1
                                     89 	.globl _IE0
                                     90 	.globl _IT0
                                     91 	.globl _P0_7
                                     92 	.globl _P0_6
                                     93 	.globl _P0_5
                                     94 	.globl _P0_4
                                     95 	.globl _P0_3
                                     96 	.globl _P0_2
                                     97 	.globl _P0_1
                                     98 	.globl _P0_0
                                     99 	.globl _TF2
                                    100 	.globl _EXF2
                                    101 	.globl _RCLK
                                    102 	.globl _TCLK
                                    103 	.globl _EXEN2
                                    104 	.globl _TR2
                                    105 	.globl _C_T2
                                    106 	.globl _CP_RL2
                                    107 	.globl _T2CON_7
                                    108 	.globl _T2CON_6
                                    109 	.globl _T2CON_5
                                    110 	.globl _T2CON_4
                                    111 	.globl _T2CON_3
                                    112 	.globl _T2CON_2
                                    113 	.globl _T2CON_1
                                    114 	.globl _T2CON_0
                                    115 	.globl _PT2
                                    116 	.globl _ET2
                                    117 	.globl _TXD0
                                    118 	.globl _RXD0
                                    119 	.globl _BREG_F7
                                    120 	.globl _BREG_F6
                                    121 	.globl _BREG_F5
                                    122 	.globl _BREG_F4
                                    123 	.globl _BREG_F3
                                    124 	.globl _BREG_F2
                                    125 	.globl _BREG_F1
                                    126 	.globl _BREG_F0
                                    127 	.globl _P5_7
                                    128 	.globl _P5_6
                                    129 	.globl _P5_5
                                    130 	.globl _P5_4
                                    131 	.globl _P5_3
                                    132 	.globl _P5_2
                                    133 	.globl _P5_1
                                    134 	.globl _P5_0
                                    135 	.globl _P4_7
                                    136 	.globl _P4_6
                                    137 	.globl _P4_5
                                    138 	.globl _P4_4
                                    139 	.globl _P4_3
                                    140 	.globl _P4_2
                                    141 	.globl _P4_1
                                    142 	.globl _P4_0
                                    143 	.globl _PX0L
                                    144 	.globl _PT0L
                                    145 	.globl _PX1L
                                    146 	.globl _PT1L
                                    147 	.globl _PSL
                                    148 	.globl _PT2L
                                    149 	.globl _PPCL
                                    150 	.globl _EC
                                    151 	.globl _CCF0
                                    152 	.globl _CCF1
                                    153 	.globl _CCF2
                                    154 	.globl _CCF3
                                    155 	.globl _CCF4
                                    156 	.globl _CR
                                    157 	.globl _CF
                                    158 	.globl _B
                                    159 	.globl _ACC
                                    160 	.globl _PSW
                                    161 	.globl _IP
                                    162 	.globl _P3
                                    163 	.globl _IE
                                    164 	.globl _P2
                                    165 	.globl _SBUF
                                    166 	.globl _SCON
                                    167 	.globl _P1
                                    168 	.globl _TH1
                                    169 	.globl _TH0
                                    170 	.globl _TL1
                                    171 	.globl _TL0
                                    172 	.globl _TMOD
                                    173 	.globl _TCON
                                    174 	.globl _PCON
                                    175 	.globl _DPH
                                    176 	.globl _DPL
                                    177 	.globl _SP
                                    178 	.globl _P0
                                    179 	.globl _TH2
                                    180 	.globl _TL2
                                    181 	.globl _RCAP2H
                                    182 	.globl _RCAP2L
                                    183 	.globl _T2CON
                                    184 	.globl _SBUF0
                                    185 	.globl _DP0L
                                    186 	.globl _DP0H
                                    187 	.globl _EECON
                                    188 	.globl _KBF
                                    189 	.globl _KBE
                                    190 	.globl _KBLS
                                    191 	.globl _BRL
                                    192 	.globl _BDRCON
                                    193 	.globl _T2MOD
                                    194 	.globl _SPDAT
                                    195 	.globl _SPSTA
                                    196 	.globl _SPCON
                                    197 	.globl _SADEN
                                    198 	.globl _SADDR
                                    199 	.globl _WDTPRG
                                    200 	.globl _WDTRST
                                    201 	.globl _P5
                                    202 	.globl _P4
                                    203 	.globl _IPH1
                                    204 	.globl _IPL1
                                    205 	.globl _IPH0
                                    206 	.globl _IPL0
                                    207 	.globl _IEN1
                                    208 	.globl _IEN0
                                    209 	.globl _CMOD
                                    210 	.globl _CL
                                    211 	.globl _CH
                                    212 	.globl _CCON
                                    213 	.globl _CCAPM4
                                    214 	.globl _CCAPM3
                                    215 	.globl _CCAPM2
                                    216 	.globl _CCAPM1
                                    217 	.globl _CCAPM0
                                    218 	.globl _CCAP4L
                                    219 	.globl _CCAP3L
                                    220 	.globl _CCAP2L
                                    221 	.globl _CCAP1L
                                    222 	.globl _CCAP0L
                                    223 	.globl _CCAP4H
                                    224 	.globl _CCAP3H
                                    225 	.globl _CCAP2H
                                    226 	.globl _CCAP1H
                                    227 	.globl _CCAP0H
                                    228 	.globl _CKCON1
                                    229 	.globl _CKCON0
                                    230 	.globl _CKRL
                                    231 	.globl _AUXR1
                                    232 	.globl _AUXR
                                    233 	.globl _eebytew_PARM_2
                                    234 	.globl _getchar
                                    235 	.globl _putchar
                                    236 ;--------------------------------------------------------
                                    237 ; special function registers
                                    238 ;--------------------------------------------------------
                                    239 	.area RSEG    (ABS,DATA)
      000000                        240 	.org 0x0000
                           00008E   241 _AUXR	=	0x008e
                           0000A2   242 _AUXR1	=	0x00a2
                           000097   243 _CKRL	=	0x0097
                           00008F   244 _CKCON0	=	0x008f
                           0000AF   245 _CKCON1	=	0x00af
                           0000FA   246 _CCAP0H	=	0x00fa
                           0000FB   247 _CCAP1H	=	0x00fb
                           0000FC   248 _CCAP2H	=	0x00fc
                           0000FD   249 _CCAP3H	=	0x00fd
                           0000FE   250 _CCAP4H	=	0x00fe
                           0000EA   251 _CCAP0L	=	0x00ea
                           0000EB   252 _CCAP1L	=	0x00eb
                           0000EC   253 _CCAP2L	=	0x00ec
                           0000ED   254 _CCAP3L	=	0x00ed
                           0000EE   255 _CCAP4L	=	0x00ee
                           0000DA   256 _CCAPM0	=	0x00da
                           0000DB   257 _CCAPM1	=	0x00db
                           0000DC   258 _CCAPM2	=	0x00dc
                           0000DD   259 _CCAPM3	=	0x00dd
                           0000DE   260 _CCAPM4	=	0x00de
                           0000D8   261 _CCON	=	0x00d8
                           0000F9   262 _CH	=	0x00f9
                           0000E9   263 _CL	=	0x00e9
                           0000D9   264 _CMOD	=	0x00d9
                           0000A8   265 _IEN0	=	0x00a8
                           0000B1   266 _IEN1	=	0x00b1
                           0000B8   267 _IPL0	=	0x00b8
                           0000B7   268 _IPH0	=	0x00b7
                           0000B2   269 _IPL1	=	0x00b2
                           0000B3   270 _IPH1	=	0x00b3
                           0000C0   271 _P4	=	0x00c0
                           0000E8   272 _P5	=	0x00e8
                           0000A6   273 _WDTRST	=	0x00a6
                           0000A7   274 _WDTPRG	=	0x00a7
                           0000A9   275 _SADDR	=	0x00a9
                           0000B9   276 _SADEN	=	0x00b9
                           0000C3   277 _SPCON	=	0x00c3
                           0000C4   278 _SPSTA	=	0x00c4
                           0000C5   279 _SPDAT	=	0x00c5
                           0000C9   280 _T2MOD	=	0x00c9
                           00009B   281 _BDRCON	=	0x009b
                           00009A   282 _BRL	=	0x009a
                           00009C   283 _KBLS	=	0x009c
                           00009D   284 _KBE	=	0x009d
                           00009E   285 _KBF	=	0x009e
                           0000D2   286 _EECON	=	0x00d2
                           000083   287 _DP0H	=	0x0083
                           000082   288 _DP0L	=	0x0082
                           000099   289 _SBUF0	=	0x0099
                           0000C8   290 _T2CON	=	0x00c8
                           0000CA   291 _RCAP2L	=	0x00ca
                           0000CB   292 _RCAP2H	=	0x00cb
                           0000CC   293 _TL2	=	0x00cc
                           0000CD   294 _TH2	=	0x00cd
                           000080   295 _P0	=	0x0080
                           000081   296 _SP	=	0x0081
                           000082   297 _DPL	=	0x0082
                           000083   298 _DPH	=	0x0083
                           000087   299 _PCON	=	0x0087
                           000088   300 _TCON	=	0x0088
                           000089   301 _TMOD	=	0x0089
                           00008A   302 _TL0	=	0x008a
                           00008B   303 _TL1	=	0x008b
                           00008C   304 _TH0	=	0x008c
                           00008D   305 _TH1	=	0x008d
                           000090   306 _P1	=	0x0090
                           000098   307 _SCON	=	0x0098
                           000099   308 _SBUF	=	0x0099
                           0000A0   309 _P2	=	0x00a0
                           0000A8   310 _IE	=	0x00a8
                           0000B0   311 _P3	=	0x00b0
                           0000B8   312 _IP	=	0x00b8
                           0000D0   313 _PSW	=	0x00d0
                           0000E0   314 _ACC	=	0x00e0
                           0000F0   315 _B	=	0x00f0
                                    316 ;--------------------------------------------------------
                                    317 ; special function bits
                                    318 ;--------------------------------------------------------
                                    319 	.area RSEG    (ABS,DATA)
      000000                        320 	.org 0x0000
                           0000DF   321 _CF	=	0x00df
                           0000DE   322 _CR	=	0x00de
                           0000DC   323 _CCF4	=	0x00dc
                           0000DB   324 _CCF3	=	0x00db
                           0000DA   325 _CCF2	=	0x00da
                           0000D9   326 _CCF1	=	0x00d9
                           0000D8   327 _CCF0	=	0x00d8
                           0000AE   328 _EC	=	0x00ae
                           0000BE   329 _PPCL	=	0x00be
                           0000BD   330 _PT2L	=	0x00bd
                           0000BC   331 _PSL	=	0x00bc
                           0000BB   332 _PT1L	=	0x00bb
                           0000BA   333 _PX1L	=	0x00ba
                           0000B9   334 _PT0L	=	0x00b9
                           0000B8   335 _PX0L	=	0x00b8
                           0000C0   336 _P4_0	=	0x00c0
                           0000C1   337 _P4_1	=	0x00c1
                           0000C2   338 _P4_2	=	0x00c2
                           0000C3   339 _P4_3	=	0x00c3
                           0000C4   340 _P4_4	=	0x00c4
                           0000C5   341 _P4_5	=	0x00c5
                           0000C6   342 _P4_6	=	0x00c6
                           0000C7   343 _P4_7	=	0x00c7
                           0000E8   344 _P5_0	=	0x00e8
                           0000E9   345 _P5_1	=	0x00e9
                           0000EA   346 _P5_2	=	0x00ea
                           0000EB   347 _P5_3	=	0x00eb
                           0000EC   348 _P5_4	=	0x00ec
                           0000ED   349 _P5_5	=	0x00ed
                           0000EE   350 _P5_6	=	0x00ee
                           0000EF   351 _P5_7	=	0x00ef
                           0000F0   352 _BREG_F0	=	0x00f0
                           0000F1   353 _BREG_F1	=	0x00f1
                           0000F2   354 _BREG_F2	=	0x00f2
                           0000F3   355 _BREG_F3	=	0x00f3
                           0000F4   356 _BREG_F4	=	0x00f4
                           0000F5   357 _BREG_F5	=	0x00f5
                           0000F6   358 _BREG_F6	=	0x00f6
                           0000F7   359 _BREG_F7	=	0x00f7
                           0000B0   360 _RXD0	=	0x00b0
                           0000B1   361 _TXD0	=	0x00b1
                           0000AD   362 _ET2	=	0x00ad
                           0000BD   363 _PT2	=	0x00bd
                           0000C8   364 _T2CON_0	=	0x00c8
                           0000C9   365 _T2CON_1	=	0x00c9
                           0000CA   366 _T2CON_2	=	0x00ca
                           0000CB   367 _T2CON_3	=	0x00cb
                           0000CC   368 _T2CON_4	=	0x00cc
                           0000CD   369 _T2CON_5	=	0x00cd
                           0000CE   370 _T2CON_6	=	0x00ce
                           0000CF   371 _T2CON_7	=	0x00cf
                           0000C8   372 _CP_RL2	=	0x00c8
                           0000C9   373 _C_T2	=	0x00c9
                           0000CA   374 _TR2	=	0x00ca
                           0000CB   375 _EXEN2	=	0x00cb
                           0000CC   376 _TCLK	=	0x00cc
                           0000CD   377 _RCLK	=	0x00cd
                           0000CE   378 _EXF2	=	0x00ce
                           0000CF   379 _TF2	=	0x00cf
                           000080   380 _P0_0	=	0x0080
                           000081   381 _P0_1	=	0x0081
                           000082   382 _P0_2	=	0x0082
                           000083   383 _P0_3	=	0x0083
                           000084   384 _P0_4	=	0x0084
                           000085   385 _P0_5	=	0x0085
                           000086   386 _P0_6	=	0x0086
                           000087   387 _P0_7	=	0x0087
                           000088   388 _IT0	=	0x0088
                           000089   389 _IE0	=	0x0089
                           00008A   390 _IT1	=	0x008a
                           00008B   391 _IE1	=	0x008b
                           00008C   392 _TR0	=	0x008c
                           00008D   393 _TF0	=	0x008d
                           00008E   394 _TR1	=	0x008e
                           00008F   395 _TF1	=	0x008f
                           000090   396 _P1_0	=	0x0090
                           000091   397 _P1_1	=	0x0091
                           000092   398 _P1_2	=	0x0092
                           000093   399 _P1_3	=	0x0093
                           000094   400 _P1_4	=	0x0094
                           000095   401 _P1_5	=	0x0095
                           000096   402 _P1_6	=	0x0096
                           000097   403 _P1_7	=	0x0097
                           000098   404 _RI	=	0x0098
                           000099   405 _TI	=	0x0099
                           00009A   406 _RB8	=	0x009a
                           00009B   407 _TB8	=	0x009b
                           00009C   408 _REN	=	0x009c
                           00009D   409 _SM2	=	0x009d
                           00009E   410 _SM1	=	0x009e
                           00009F   411 _SM0	=	0x009f
                           0000A0   412 _P2_0	=	0x00a0
                           0000A1   413 _P2_1	=	0x00a1
                           0000A2   414 _P2_2	=	0x00a2
                           0000A3   415 _P2_3	=	0x00a3
                           0000A4   416 _P2_4	=	0x00a4
                           0000A5   417 _P2_5	=	0x00a5
                           0000A6   418 _P2_6	=	0x00a6
                           0000A7   419 _P2_7	=	0x00a7
                           0000A8   420 _EX0	=	0x00a8
                           0000A9   421 _ET0	=	0x00a9
                           0000AA   422 _EX1	=	0x00aa
                           0000AB   423 _ET1	=	0x00ab
                           0000AC   424 _ES	=	0x00ac
                           0000AF   425 _EA	=	0x00af
                           0000B0   426 _P3_0	=	0x00b0
                           0000B1   427 _P3_1	=	0x00b1
                           0000B2   428 _P3_2	=	0x00b2
                           0000B3   429 _P3_3	=	0x00b3
                           0000B4   430 _P3_4	=	0x00b4
                           0000B5   431 _P3_5	=	0x00b5
                           0000B6   432 _P3_6	=	0x00b6
                           0000B7   433 _P3_7	=	0x00b7
                           0000B0   434 _RXD	=	0x00b0
                           0000B1   435 _TXD	=	0x00b1
                           0000B2   436 _INT0	=	0x00b2
                           0000B3   437 _INT1	=	0x00b3
                           0000B4   438 _T0	=	0x00b4
                           0000B5   439 _T1	=	0x00b5
                           0000B6   440 _WR	=	0x00b6
                           0000B7   441 _RD	=	0x00b7
                           0000B8   442 _PX0	=	0x00b8
                           0000B9   443 _PT0	=	0x00b9
                           0000BA   444 _PX1	=	0x00ba
                           0000BB   445 _PT1	=	0x00bb
                           0000BC   446 _PS	=	0x00bc
                           0000D0   447 _P	=	0x00d0
                           0000D1   448 _F1	=	0x00d1
                           0000D2   449 _OV	=	0x00d2
                           0000D3   450 _RS0	=	0x00d3
                           0000D4   451 _RS1	=	0x00d4
                           0000D5   452 _F0	=	0x00d5
                           0000D6   453 _AC	=	0x00d6
                           0000D7   454 _CY	=	0x00d7
                                    455 ;--------------------------------------------------------
                                    456 ; overlayable register banks
                                    457 ;--------------------------------------------------------
                                    458 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        459 	.ds 8
                                    460 ;--------------------------------------------------------
                                    461 ; internal ram data
                                    462 ;--------------------------------------------------------
                                    463 	.area DSEG    (DATA)
      000000                        464 _eebytew_PARM_2:
      000000                        465 	.ds 1
      000001                        466 _main_addr_131072_92:
      000001                        467 	.ds 2
      000003                        468 _main_addr1_131072_92:
      000003                        469 	.ds 2
      000005                        470 _main_start_addr_131072_92:
      000005                        471 	.ds 2
      000007                        472 _main_end_addr_131072_92:
      000007                        473 	.ds 2
      000009                        474 _main_data_131072_92:
      000009                        475 	.ds 2
                                    476 ;--------------------------------------------------------
                                    477 ; overlayable items in internal ram
                                    478 ;--------------------------------------------------------
                                    479 	.area	OSEG    (OVR,DATA)
                                    480 	.area	OSEG    (OVR,DATA)
                                    481 ;--------------------------------------------------------
                                    482 ; Stack segment in internal ram
                                    483 ;--------------------------------------------------------
                                    484 	.area	SSEG
      000000                        485 __start__stack:
      000000                        486 	.ds	1
                                    487 
                                    488 ;--------------------------------------------------------
                                    489 ; indirectly addressable internal ram data
                                    490 ;--------------------------------------------------------
                                    491 	.area ISEG    (DATA)
                                    492 ;--------------------------------------------------------
                                    493 ; absolute internal ram data
                                    494 ;--------------------------------------------------------
                                    495 	.area IABS    (ABS,DATA)
                                    496 	.area IABS    (ABS,DATA)
                                    497 ;--------------------------------------------------------
                                    498 ; bit data
                                    499 ;--------------------------------------------------------
                                    500 	.area BSEG    (BIT)
      000000                        501 _eebyter_sloc0_1_0:
      000000                        502 	.ds 1
                                    503 ;--------------------------------------------------------
                                    504 ; paged external ram data
                                    505 ;--------------------------------------------------------
                                    506 	.area PSEG    (PAG,XDATA)
                                    507 ;--------------------------------------------------------
                                    508 ; external ram data
                                    509 ;--------------------------------------------------------
                                    510 	.area XSEG    (XDATA)
                                    511 ;--------------------------------------------------------
                                    512 ; absolute external ram data
                                    513 ;--------------------------------------------------------
                                    514 	.area XABS    (ABS,XDATA)
                                    515 ;--------------------------------------------------------
                                    516 ; external initialized ram data
                                    517 ;--------------------------------------------------------
                                    518 	.area XISEG   (XDATA)
                                    519 	.area HOME    (CODE)
                                    520 	.area GSINIT0 (CODE)
                                    521 	.area GSINIT1 (CODE)
                                    522 	.area GSINIT2 (CODE)
                                    523 	.area GSINIT3 (CODE)
                                    524 	.area GSINIT4 (CODE)
                                    525 	.area GSINIT5 (CODE)
                                    526 	.area GSINIT  (CODE)
                                    527 	.area GSFINAL (CODE)
                                    528 	.area CSEG    (CODE)
                                    529 ;--------------------------------------------------------
                                    530 ; interrupt vector
                                    531 ;--------------------------------------------------------
                                    532 	.area HOME    (CODE)
      000000                        533 __interrupt_vect:
      000000 02r00r00         [24]  534 	ljmp	__sdcc_gsinit_startup
                                    535 ;--------------------------------------------------------
                                    536 ; global & static initialisations
                                    537 ;--------------------------------------------------------
                                    538 	.area HOME    (CODE)
                                    539 	.area GSINIT  (CODE)
                                    540 	.area GSFINAL (CODE)
                                    541 	.area GSINIT  (CODE)
                                    542 	.globl __sdcc_gsinit_startup
                                    543 	.globl __sdcc_program_startup
                                    544 	.globl __start__stack
                                    545 	.globl __mcs51_genXINIT
                                    546 	.globl __mcs51_genXRAMCLEAR
                                    547 	.globl __mcs51_genRAMCLEAR
                                    548 	.area GSFINAL (CODE)
      000000 02r00r03         [24]  549 	ljmp	__sdcc_program_startup
                                    550 ;--------------------------------------------------------
                                    551 ; Home
                                    552 ;--------------------------------------------------------
                                    553 	.area HOME    (CODE)
                                    554 	.area HOME    (CODE)
      000003                        555 __sdcc_program_startup:
      000003 02r03rD8         [24]  556 	ljmp	_main
                                    557 ;	return from main will return to caller
                                    558 ;--------------------------------------------------------
                                    559 ; code
                                    560 ;--------------------------------------------------------
                                    561 	.area CSEG    (CODE)
                                    562 ;------------------------------------------------------------
                                    563 ;Allocation info for local variables in function 'getchar'
                                    564 ;------------------------------------------------------------
                                    565 ;	main.c:17: int getchar (void)
                                    566 ;	-----------------------------------------
                                    567 ;	 function getchar
                                    568 ;	-----------------------------------------
      000000                        569 _getchar:
                           000007   570 	ar7 = 0x07
                           000006   571 	ar6 = 0x06
                           000005   572 	ar5 = 0x05
                           000004   573 	ar4 = 0x04
                           000003   574 	ar3 = 0x03
                           000002   575 	ar2 = 0x02
                           000001   576 	ar1 = 0x01
                           000000   577 	ar0 = 0x00
                                    578 ;	main.c:19: while (!RI);
      000000                        579 00101$:
                                    580 ;	main.c:21: RI = 0;                         // clear RI flag
                                    581 ;	assignBit
      000000 10 98 02         [24]  582 	jbc	_RI,00114$
      000003 80 FB            [24]  583 	sjmp	00101$
      000005                        584 00114$:
                                    585 ;	main.c:22: return SBUF;                    // return character from SBUF
      000005 AE 99            [24]  586 	mov	r6,_SBUF
      000007 7F 00            [12]  587 	mov	r7,#0x00
      000009 8E 82            [24]  588 	mov	dpl,r6
      00000B 8F 83            [24]  589 	mov	dph,r7
                                    590 ;	main.c:23: }
      00000D 22               [24]  591 	ret
                                    592 ;------------------------------------------------------------
                                    593 ;Allocation info for local variables in function 'putchar'
                                    594 ;------------------------------------------------------------
                                    595 ;c                         Allocated to registers r6 r7 
                                    596 ;------------------------------------------------------------
                                    597 ;	main.c:25: int putchar (int c)
                                    598 ;	-----------------------------------------
                                    599 ;	 function putchar
                                    600 ;	-----------------------------------------
      00000E                        601 _putchar:
      00000E AE 82            [24]  602 	mov	r6,dpl
      000010 AF 83            [24]  603 	mov	r7,dph
                                    604 ;	main.c:27: while (!TI);
      000012                        605 00101$:
      000012 30 99 FD         [24]  606 	jnb	_TI,00101$
                                    607 ;	main.c:29: SBUF = c;           // load serial port with transmit value
      000015 8E 99            [24]  608 	mov	_SBUF,r6
                                    609 ;	main.c:30: TI = 0;             // clear TI flag
                                    610 ;	assignBit
      000017 C2 99            [12]  611 	clr	_TI
                                    612 ;	main.c:32: return c;
      000019 8E 82            [24]  613 	mov	dpl,r6
      00001B 8F 83            [24]  614 	mov	dph,r7
                                    615 ;	main.c:33: }
      00001D 22               [24]  616 	ret
                                    617 ;------------------------------------------------------------
                                    618 ;Allocation info for local variables in function 'delay'
                                    619 ;------------------------------------------------------------
                                    620 ;count                     Allocated to registers r6 r7 
                                    621 ;i                         Allocated to registers r4 r5 
                                    622 ;------------------------------------------------------------
                                    623 ;	main.c:36: void delay(unsigned int count)
                                    624 ;	-----------------------------------------
                                    625 ;	 function delay
                                    626 ;	-----------------------------------------
      00001E                        627 _delay:
      00001E AE 82            [24]  628 	mov	r6,dpl
      000020 AF 83            [24]  629 	mov	r7,dph
                                    630 ;	main.c:39: for(i=0;i<count;i++);
      000022 7C 00            [12]  631 	mov	r4,#0x00
      000024 7D 00            [12]  632 	mov	r5,#0x00
      000026                        633 00103$:
      000026 C3               [12]  634 	clr	c
      000027 EC               [12]  635 	mov	a,r4
      000028 9E               [12]  636 	subb	a,r6
      000029 ED               [12]  637 	mov	a,r5
      00002A 9F               [12]  638 	subb	a,r7
      00002B 50 07            [24]  639 	jnc	00105$
      00002D 0C               [12]  640 	inc	r4
      00002E BC 00 F5         [24]  641 	cjne	r4,#0x00,00103$
      000031 0D               [12]  642 	inc	r5
      000032 80 F2            [24]  643 	sjmp	00103$
      000034                        644 00105$:
                                    645 ;	main.c:40: }
      000034 22               [24]  646 	ret
                                    647 ;------------------------------------------------------------
                                    648 ;Allocation info for local variables in function 'I2C_init'
                                    649 ;------------------------------------------------------------
                                    650 ;	main.c:44: void I2C_init(void)
                                    651 ;	-----------------------------------------
                                    652 ;	 function I2C_init
                                    653 ;	-----------------------------------------
      000035                        654 _I2C_init:
                                    655 ;	main.c:47: SDA = 1;
                                    656 ;	assignBit
      000035 D2 97            [12]  657 	setb	_P1_7
                                    658 ;	main.c:48: SCL = 1;
                                    659 ;	assignBit
      000037 D2 96            [12]  660 	setb	_P1_6
                                    661 ;	main.c:49: }
      000039 22               [24]  662 	ret
                                    663 ;------------------------------------------------------------
                                    664 ;Allocation info for local variables in function 'I2C_Start'
                                    665 ;------------------------------------------------------------
                                    666 ;	main.c:52: void I2C_Start(void)
                                    667 ;	-----------------------------------------
                                    668 ;	 function I2C_Start
                                    669 ;	-----------------------------------------
      00003A                        670 _I2C_Start:
                                    671 ;	main.c:54: set_SCL_high;				// Make SCL pin high
                                    672 ;	assignBit
      00003A D2 96            [12]  673 	setb	_P1_6
                                    674 ;	main.c:55: set_SDA_high;				// Make SDA pin High
                                    675 ;	assignBit
      00003C D2 97            [12]  676 	setb	_P1_7
                                    677 ;	main.c:56: delay(50);	// Half bit delay
      00003E 90 00 32         [24]  678 	mov	dptr,#0x0032
      000041 12r00r1E         [24]  679 	lcall	_delay
                                    680 ;	main.c:57: set_SDA_low;				// Make SDA Low
                                    681 ;	assignBit
      000044 C2 97            [12]  682 	clr	_P1_7
                                    683 ;	main.c:58: delay(50);	// Half bit delay
      000046 90 00 32         [24]  684 	mov	dptr,#0x0032
                                    685 ;	main.c:59: }
      000049 02r00r1E         [24]  686 	ljmp	_delay
                                    687 ;------------------------------------------------------------
                                    688 ;Allocation info for local variables in function 'I2C_Write_Byte'
                                    689 ;------------------------------------------------------------
                                    690 ;Byte                      Allocated to registers r7 
                                    691 ;i                         Allocated to registers r6 
                                    692 ;------------------------------------------------------------
                                    693 ;	main.c:61: unsigned char I2C_Write_Byte(unsigned char Byte)
                                    694 ;	-----------------------------------------
                                    695 ;	 function I2C_Write_Byte
                                    696 ;	-----------------------------------------
      00004C                        697 _I2C_Write_Byte:
      00004C AF 82            [24]  698 	mov	r7,dpl
                                    699 ;	main.c:65: for(i=0;i<8;i++)		// Repeat for every bit
      00004E 7E 00            [12]  700 	mov	r6,#0x00
      000050                        701 00105$:
                                    702 ;	main.c:67: set_SCL_low;		// Make SCL pin low
                                    703 ;	assignBit
      000050 C2 96            [12]  704 	clr	_P1_6
                                    705 ;	main.c:69: delay(50);	// Data pin should change it's value,
      000052 90 00 32         [24]  706 	mov	dptr,#0x0032
      000055 C0 07            [24]  707 	push	ar7
      000057 C0 06            [24]  708 	push	ar6
      000059 12r00r1E         [24]  709 	lcall	_delay
      00005C D0 06            [24]  710 	pop	ar6
      00005E D0 07            [24]  711 	pop	ar7
                                    712 ;	main.c:72: if((Byte<<i)&0x80)  // Place data bit value on SDA pin
      000060 8F 04            [24]  713 	mov	ar4,r7
      000062 7D 00            [12]  714 	mov	r5,#0x00
      000064 8E F0            [24]  715 	mov	b,r6
      000066 05 F0            [12]  716 	inc	b
      000068 80 06            [24]  717 	sjmp	00123$
      00006A                        718 00122$:
      00006A EC               [12]  719 	mov	a,r4
      00006B 2C               [12]  720 	add	a,r4
      00006C FC               [12]  721 	mov	r4,a
      00006D ED               [12]  722 	mov	a,r5
      00006E 33               [12]  723 	rlc	a
      00006F FD               [12]  724 	mov	r5,a
      000070                        725 00123$:
      000070 D5 F0 F7         [24]  726 	djnz	b,00122$
      000073 EC               [12]  727 	mov	a,r4
      000074 30 E7 04         [24]  728 	jnb	acc.7,00102$
                                    729 ;	main.c:73: set_SDA_high;	// If bit is high, make SDA high
                                    730 ;	assignBit
      000077 D2 97            [12]  731 	setb	_P1_7
      000079 80 02            [24]  732 	sjmp	00103$
      00007B                        733 00102$:
                                    734 ;	main.c:75: set_SDA_low;	// If bit is low, make SDA low
                                    735 ;	assignBit
      00007B C2 97            [12]  736 	clr	_P1_7
      00007D                        737 00103$:
                                    738 ;	main.c:77: delay(50);	// Toggle SCL pin
      00007D 90 00 32         [24]  739 	mov	dptr,#0x0032
      000080 C0 07            [24]  740 	push	ar7
      000082 C0 06            [24]  741 	push	ar6
      000084 12r00r1E         [24]  742 	lcall	_delay
                                    743 ;	main.c:78: set_SCL_high;				// So that slave can
                                    744 ;	assignBit
      000087 D2 96            [12]  745 	setb	_P1_6
                                    746 ;	main.c:79: delay(50);	// latch data bit
      000089 90 00 32         [24]  747 	mov	dptr,#0x0032
      00008C 12r00r1E         [24]  748 	lcall	_delay
      00008F D0 06            [24]  749 	pop	ar6
      000091 D0 07            [24]  750 	pop	ar7
                                    751 ;	main.c:65: for(i=0;i<8;i++)		// Repeat for every bit
      000093 0E               [12]  752 	inc	r6
      000094 BE 08 00         [24]  753 	cjne	r6,#0x08,00125$
      000097                        754 00125$:
      000097 40 B7            [24]  755 	jc	00105$
                                    756 ;	main.c:83: set_SCL_low;
                                    757 ;	assignBit
      000099 C2 96            [12]  758 	clr	_P1_6
                                    759 ;	main.c:84: set_SDA_high;
                                    760 ;	assignBit
      00009B D2 97            [12]  761 	setb	_P1_7
                                    762 ;	main.c:85: delay(50);
      00009D 90 00 32         [24]  763 	mov	dptr,#0x0032
      0000A0 12r00r1E         [24]  764 	lcall	_delay
                                    765 ;	main.c:86: set_SCL_high;
                                    766 ;	assignBit
      0000A3 D2 96            [12]  767 	setb	_P1_6
                                    768 ;	main.c:87: delay(50);
      0000A5 90 00 32         [24]  769 	mov	dptr,#0x0032
      0000A8 12r00r1E         [24]  770 	lcall	_delay
                                    771 ;	main.c:89: return SDA;
      0000AB A2 97            [12]  772 	mov	c,_P1_7
      0000AD E4               [12]  773 	clr	a
      0000AE 33               [12]  774 	rlc	a
      0000AF F5 82            [12]  775 	mov	dpl,a
                                    776 ;	main.c:90: }
      0000B1 22               [24]  777 	ret
                                    778 ;------------------------------------------------------------
                                    779 ;Allocation info for local variables in function 'I2C_Read_Byte'
                                    780 ;------------------------------------------------------------
                                    781 ;i                         Allocated to registers r6 
                                    782 ;d                         Allocated to registers r5 
                                    783 ;RxData                    Allocated to registers r7 
                                    784 ;------------------------------------------------------------
                                    785 ;	main.c:93: unsigned char I2C_Read_Byte(void)
                                    786 ;	-----------------------------------------
                                    787 ;	 function I2C_Read_Byte
                                    788 ;	-----------------------------------------
      0000B2                        789 _I2C_Read_Byte:
                                    790 ;	main.c:95: unsigned char i, d, RxData = 0;
      0000B2 7F 00            [12]  791 	mov	r7,#0x00
                                    792 ;	main.c:97: for(i=0;i<8;i++)
      0000B4 7E 00            [12]  793 	mov	r6,#0x00
      0000B6                        794 00102$:
                                    795 ;	main.c:99: set_SCL_low;					// Make SCL pin low
                                    796 ;	assignBit
      0000B6 C2 96            [12]  797 	clr	_P1_6
                                    798 ;	main.c:100: set_SDA_high;					// Don't drive SDA
                                    799 ;	assignBit
      0000B8 D2 97            [12]  800 	setb	_P1_7
                                    801 ;	main.c:101: delay(50);		// Half bit delay
      0000BA 90 00 32         [24]  802 	mov	dptr,#0x0032
      0000BD C0 07            [24]  803 	push	ar7
      0000BF C0 06            [24]  804 	push	ar6
      0000C1 12r00r1E         [24]  805 	lcall	_delay
                                    806 ;	main.c:102: set_SCL_high;					// Make SCL pin high
                                    807 ;	assignBit
      0000C4 D2 96            [12]  808 	setb	_P1_6
                                    809 ;	main.c:103: delay(50);		// 1/4 bit delay
      0000C6 90 00 32         [24]  810 	mov	dptr,#0x0032
      0000C9 12r00r1E         [24]  811 	lcall	_delay
      0000CC D0 06            [24]  812 	pop	ar6
      0000CE D0 07            [24]  813 	pop	ar7
                                    814 ;	main.c:104: d = SDA;					    // Capture Received Bit
      0000D0 A2 97            [12]  815 	mov	c,_P1_7
      0000D2 E4               [12]  816 	clr	a
      0000D3 33               [12]  817 	rlc	a
      0000D4 FD               [12]  818 	mov	r5,a
                                    819 ;	main.c:105: RxData = RxData|(d<<(7-i));   	// Copy it in RxData
      0000D5 8E 04            [24]  820 	mov	ar4,r6
      0000D7 74 07            [12]  821 	mov	a,#0x07
      0000D9 C3               [12]  822 	clr	c
      0000DA 9C               [12]  823 	subb	a,r4
      0000DB FC               [12]  824 	mov	r4,a
      0000DC 8C F0            [24]  825 	mov	b,r4
      0000DE 05 F0            [12]  826 	inc	b
      0000E0 ED               [12]  827 	mov	a,r5
      0000E1 80 02            [24]  828 	sjmp	00117$
      0000E3                        829 00115$:
      0000E3 25 E0            [12]  830 	add	a,acc
      0000E5                        831 00117$:
      0000E5 D5 F0 FB         [24]  832 	djnz	b,00115$
      0000E8 42 07            [12]  833 	orl	ar7,a
                                    834 ;	main.c:106: delay(50);		// 1/4 bit delay
      0000EA 90 00 32         [24]  835 	mov	dptr,#0x0032
      0000ED C0 07            [24]  836 	push	ar7
      0000EF C0 06            [24]  837 	push	ar6
      0000F1 12r00r1E         [24]  838 	lcall	_delay
      0000F4 D0 06            [24]  839 	pop	ar6
      0000F6 D0 07            [24]  840 	pop	ar7
                                    841 ;	main.c:97: for(i=0;i<8;i++)
      0000F8 0E               [12]  842 	inc	r6
      0000F9 BE 08 00         [24]  843 	cjne	r6,#0x08,00118$
      0000FC                        844 00118$:
      0000FC 40 B8            [24]  845 	jc	00102$
                                    846 ;	main.c:109: return RxData;						// Return received byte
      0000FE 8F 82            [24]  847 	mov	dpl,r7
                                    848 ;	main.c:110: }
      000100 22               [24]  849 	ret
                                    850 ;------------------------------------------------------------
                                    851 ;Allocation info for local variables in function 'I2C_Send_ACK'
                                    852 ;------------------------------------------------------------
                                    853 ;	main.c:113: void I2C_Send_ACK(void)
                                    854 ;	-----------------------------------------
                                    855 ;	 function I2C_Send_ACK
                                    856 ;	-----------------------------------------
      000101                        857 _I2C_Send_ACK:
                                    858 ;	main.c:115: set_SCL_low;				// Make SCL pin low
                                    859 ;	assignBit
      000101 C2 96            [12]  860 	clr	_P1_6
                                    861 ;	main.c:116: delay(50);	// Data pin should change it's value,
      000103 90 00 32         [24]  862 	mov	dptr,#0x0032
      000106 12r00r1E         [24]  863 	lcall	_delay
                                    864 ;	main.c:118: set_SDA_high;				// Make SDA Low
                                    865 ;	assignBit
      000109 D2 97            [12]  866 	setb	_P1_7
                                    867 ;	main.c:119: delay(50);	// 1/4 bit delay
      00010B 90 00 32         [24]  868 	mov	dptr,#0x0032
      00010E 12r00r1E         [24]  869 	lcall	_delay
                                    870 ;	main.c:120: set_SCL_high;				// Make SCL pin high
                                    871 ;	assignBit
      000111 D2 96            [12]  872 	setb	_P1_6
                                    873 ;	main.c:121: delay(50);	// Half bit delay
      000113 90 00 32         [24]  874 	mov	dptr,#0x0032
                                    875 ;	main.c:122: }
      000116 02r00r1E         [24]  876 	ljmp	_delay
                                    877 ;------------------------------------------------------------
                                    878 ;Allocation info for local variables in function 'I2C_ReStart'
                                    879 ;------------------------------------------------------------
                                    880 ;	main.c:125: void I2C_ReStart(void)
                                    881 ;	-----------------------------------------
                                    882 ;	 function I2C_ReStart
                                    883 ;	-----------------------------------------
      000119                        884 _I2C_ReStart:
                                    885 ;	main.c:127: set_SCL_low;				// Make SCL pin low
                                    886 ;	assignBit
      000119 C2 96            [12]  887 	clr	_P1_6
                                    888 ;	main.c:129: delay(50);	// Data pin should change it's value,
      00011B 90 00 32         [24]  889 	mov	dptr,#0x0032
      00011E 12r00r1E         [24]  890 	lcall	_delay
                                    891 ;	main.c:131: set_SDA_high;				// Make SDA pin High
                                    892 ;	assignBit
      000121 D2 97            [12]  893 	setb	_P1_7
                                    894 ;	main.c:133: delay(50);	// 1/4 bit delay
      000123 90 00 32         [24]  895 	mov	dptr,#0x0032
      000126 12r00r1E         [24]  896 	lcall	_delay
                                    897 ;	main.c:134: set_SCL_high;				// Make SCL pin high
                                    898 ;	assignBit
      000129 D2 96            [12]  899 	setb	_P1_6
                                    900 ;	main.c:135: delay(50);	// 1/4 bit delay
      00012B 90 00 32         [24]  901 	mov	dptr,#0x0032
      00012E 12r00r1E         [24]  902 	lcall	_delay
                                    903 ;	main.c:136: set_SDA_low;				// Make SDA Low
                                    904 ;	assignBit
      000131 C2 97            [12]  905 	clr	_P1_7
                                    906 ;	main.c:137: delay(50);	// 1/4 bit delay
      000133 90 00 32         [24]  907 	mov	dptr,#0x0032
                                    908 ;	main.c:138: }
      000136 02r00r1E         [24]  909 	ljmp	_delay
                                    910 ;------------------------------------------------------------
                                    911 ;Allocation info for local variables in function 'I2C_Stop'
                                    912 ;------------------------------------------------------------
                                    913 ;	main.c:142: void I2C_Stop(void)
                                    914 ;	-----------------------------------------
                                    915 ;	 function I2C_Stop
                                    916 ;	-----------------------------------------
      000139                        917 _I2C_Stop:
                                    918 ;	main.c:144: set_SCL_low;				// Make SCL pin low
                                    919 ;	assignBit
      000139 C2 96            [12]  920 	clr	_P1_6
                                    921 ;	main.c:146: delay(50);	// Data pin should change it's value,
      00013B 90 00 32         [24]  922 	mov	dptr,#0x0032
      00013E 12r00r1E         [24]  923 	lcall	_delay
                                    924 ;	main.c:148: set_SDA_low;				// Make SDA pin low
                                    925 ;	assignBit
      000141 C2 97            [12]  926 	clr	_P1_7
                                    927 ;	main.c:150: delay(50);	// 1/4 bit delay
      000143 90 00 32         [24]  928 	mov	dptr,#0x0032
      000146 12r00r1E         [24]  929 	lcall	_delay
                                    930 ;	main.c:151: set_SCL_high;				// Make SCL pin high
                                    931 ;	assignBit
      000149 D2 96            [12]  932 	setb	_P1_6
                                    933 ;	main.c:152: delay(50);	// 1/4 bit delay
      00014B 90 00 32         [24]  934 	mov	dptr,#0x0032
      00014E 12r00r1E         [24]  935 	lcall	_delay
                                    936 ;	main.c:153: set_SDA_high;				// Make SDA high
                                    937 ;	assignBit
      000151 D2 97            [12]  938 	setb	_P1_7
                                    939 ;	main.c:154: delay(50);	// 1/4 bit delay
      000153 90 00 32         [24]  940 	mov	dptr,#0x0032
                                    941 ;	main.c:155: }
      000156 02r00r1E         [24]  942 	ljmp	_delay
                                    943 ;------------------------------------------------------------
                                    944 ;Allocation info for local variables in function 'RepeatedStartI2c'
                                    945 ;------------------------------------------------------------
                                    946 ;	main.c:157: void RepeatedStartI2c()
                                    947 ;	-----------------------------------------
                                    948 ;	 function RepeatedStartI2c
                                    949 ;	-----------------------------------------
      000159                        950 _RepeatedStartI2c:
                                    951 ;	main.c:159: SCL  = 0;
                                    952 ;	assignBit
      000159 C2 96            [12]  953 	clr	_P1_6
                                    954 ;	main.c:160: delay(50);
      00015B 90 00 32         [24]  955 	mov	dptr,#0x0032
      00015E 12r00r1E         [24]  956 	lcall	_delay
                                    957 ;	main.c:161: SDA  = 1;
                                    958 ;	assignBit
      000161 D2 97            [12]  959 	setb	_P1_7
                                    960 ;	main.c:162: delay(50);
      000163 90 00 32         [24]  961 	mov	dptr,#0x0032
      000166 12r00r1E         [24]  962 	lcall	_delay
                                    963 ;	main.c:163: SCL  = 1;
                                    964 ;	assignBit
      000169 D2 96            [12]  965 	setb	_P1_6
                                    966 ;	main.c:164: delay(50);
      00016B 90 00 32         [24]  967 	mov	dptr,#0x0032
      00016E 12r00r1E         [24]  968 	lcall	_delay
                                    969 ;	main.c:165: SDA  = 0;
                                    970 ;	assignBit
      000171 C2 97            [12]  971 	clr	_P1_7
                                    972 ;	main.c:166: delay(50);
      000173 90 00 32         [24]  973 	mov	dptr,#0x0032
                                    974 ;	main.c:167: }
      000176 02r00r1E         [24]  975 	ljmp	_delay
                                    976 ;------------------------------------------------------------
                                    977 ;Allocation info for local variables in function 'eebytew'
                                    978 ;------------------------------------------------------------
                                    979 ;databyte                  Allocated with name '_eebytew_PARM_2'
                                    980 ;addr                      Allocated to registers r6 r7 
                                    981 ;------------------------------------------------------------
                                    982 ;	main.c:169: void eebytew(unsigned int addr, unsigned char databyte)
                                    983 ;	-----------------------------------------
                                    984 ;	 function eebytew
                                    985 ;	-----------------------------------------
      000179                        986 _eebytew:
      000179 AE 82            [24]  987 	mov	r6,dpl
      00017B AF 83            [24]  988 	mov	r7,dph
                                    989 ;	main.c:171: I2C_Start();
      00017D C0 07            [24]  990 	push	ar7
      00017F C0 06            [24]  991 	push	ar6
      000181 12r00r3A         [24]  992 	lcall	_I2C_Start
      000184 D0 06            [24]  993 	pop	ar6
      000186 D0 07            [24]  994 	pop	ar7
                                    995 ;	main.c:172: if(addr <= 0xFF)
      000188 C3               [12]  996 	clr	c
      000189 74 FF            [12]  997 	mov	a,#0xff
      00018B 9E               [12]  998 	subb	a,r6
      00018C E4               [12]  999 	clr	a
      00018D 9F               [12] 1000 	subb	a,r7
      00018E 40 11            [24] 1001 	jc	00122$
                                   1002 ;	main.c:174: I2C_Write_Byte((unsigned char)0xA0);
      000190 75 82 A0         [24] 1003 	mov	dpl,#0xa0
      000193 C0 07            [24] 1004 	push	ar7
      000195 C0 06            [24] 1005 	push	ar6
      000197 12r00r4C         [24] 1006 	lcall	_I2C_Write_Byte
      00019A D0 06            [24] 1007 	pop	ar6
      00019C D0 07            [24] 1008 	pop	ar7
      00019E 02r02r50         [24] 1009 	ljmp	00123$
      0001A1                       1010 00122$:
                                   1011 ;	main.c:177: if(addr <= 0x1FF){
      0001A1 C3               [12] 1012 	clr	c
      0001A2 74 FF            [12] 1013 	mov	a,#0xff
      0001A4 9E               [12] 1014 	subb	a,r6
      0001A5 74 01            [12] 1015 	mov	a,#0x01
      0001A7 9F               [12] 1016 	subb	a,r7
      0001A8 40 11            [24] 1017 	jc	00119$
                                   1018 ;	main.c:178: I2C_Write_Byte((unsigned char)0xA2);
      0001AA 75 82 A2         [24] 1019 	mov	dpl,#0xa2
      0001AD C0 07            [24] 1020 	push	ar7
      0001AF C0 06            [24] 1021 	push	ar6
      0001B1 12r00r4C         [24] 1022 	lcall	_I2C_Write_Byte
      0001B4 D0 06            [24] 1023 	pop	ar6
      0001B6 D0 07            [24] 1024 	pop	ar7
      0001B8 02r02r50         [24] 1025 	ljmp	00123$
      0001BB                       1026 00119$:
                                   1027 ;	main.c:181: if(addr <= 0x2FF){
      0001BB C3               [12] 1028 	clr	c
      0001BC 74 FF            [12] 1029 	mov	a,#0xff
      0001BE 9E               [12] 1030 	subb	a,r6
      0001BF 74 02            [12] 1031 	mov	a,#0x02
      0001C1 9F               [12] 1032 	subb	a,r7
      0001C2 40 11            [24] 1033 	jc	00116$
                                   1034 ;	main.c:182: I2C_Write_Byte((unsigned char)0xA4);
      0001C4 75 82 A4         [24] 1035 	mov	dpl,#0xa4
      0001C7 C0 07            [24] 1036 	push	ar7
      0001C9 C0 06            [24] 1037 	push	ar6
      0001CB 12r00r4C         [24] 1038 	lcall	_I2C_Write_Byte
      0001CE D0 06            [24] 1039 	pop	ar6
      0001D0 D0 07            [24] 1040 	pop	ar7
      0001D2 02r02r50         [24] 1041 	ljmp	00123$
      0001D5                       1042 00116$:
                                   1043 ;	main.c:185: if(addr <= 0x3FF){
      0001D5 C3               [12] 1044 	clr	c
      0001D6 74 FF            [12] 1045 	mov	a,#0xff
      0001D8 9E               [12] 1046 	subb	a,r6
      0001D9 74 03            [12] 1047 	mov	a,#0x03
      0001DB 9F               [12] 1048 	subb	a,r7
      0001DC 40 10            [24] 1049 	jc	00113$
                                   1050 ;	main.c:186: I2C_Write_Byte((unsigned char)0xA6);
      0001DE 75 82 A6         [24] 1051 	mov	dpl,#0xa6
      0001E1 C0 07            [24] 1052 	push	ar7
      0001E3 C0 06            [24] 1053 	push	ar6
      0001E5 12r00r4C         [24] 1054 	lcall	_I2C_Write_Byte
      0001E8 D0 06            [24] 1055 	pop	ar6
      0001EA D0 07            [24] 1056 	pop	ar7
      0001EC 80 62            [24] 1057 	sjmp	00123$
      0001EE                       1058 00113$:
                                   1059 ;	main.c:189: if(addr <= 0x4FF){
      0001EE C3               [12] 1060 	clr	c
      0001EF 74 FF            [12] 1061 	mov	a,#0xff
      0001F1 9E               [12] 1062 	subb	a,r6
      0001F2 74 04            [12] 1063 	mov	a,#0x04
      0001F4 9F               [12] 1064 	subb	a,r7
      0001F5 40 10            [24] 1065 	jc	00110$
                                   1066 ;	main.c:190: I2C_Write_Byte((unsigned char)0xA8);
      0001F7 75 82 A8         [24] 1067 	mov	dpl,#0xa8
      0001FA C0 07            [24] 1068 	push	ar7
      0001FC C0 06            [24] 1069 	push	ar6
      0001FE 12r00r4C         [24] 1070 	lcall	_I2C_Write_Byte
      000201 D0 06            [24] 1071 	pop	ar6
      000203 D0 07            [24] 1072 	pop	ar7
      000205 80 49            [24] 1073 	sjmp	00123$
      000207                       1074 00110$:
                                   1075 ;	main.c:193: if(addr <= 0x5FF){
      000207 C3               [12] 1076 	clr	c
      000208 74 FF            [12] 1077 	mov	a,#0xff
      00020A 9E               [12] 1078 	subb	a,r6
      00020B 74 05            [12] 1079 	mov	a,#0x05
      00020D 9F               [12] 1080 	subb	a,r7
      00020E 40 10            [24] 1081 	jc	00107$
                                   1082 ;	main.c:194: I2C_Write_Byte((unsigned char)0xAA);
      000210 75 82 AA         [24] 1083 	mov	dpl,#0xaa
      000213 C0 07            [24] 1084 	push	ar7
      000215 C0 06            [24] 1085 	push	ar6
      000217 12r00r4C         [24] 1086 	lcall	_I2C_Write_Byte
      00021A D0 06            [24] 1087 	pop	ar6
      00021C D0 07            [24] 1088 	pop	ar7
      00021E 80 30            [24] 1089 	sjmp	00123$
      000220                       1090 00107$:
                                   1091 ;	main.c:197: if(addr <= 0x6FF){
      000220 C3               [12] 1092 	clr	c
      000221 74 FF            [12] 1093 	mov	a,#0xff
      000223 9E               [12] 1094 	subb	a,r6
      000224 74 06            [12] 1095 	mov	a,#0x06
      000226 9F               [12] 1096 	subb	a,r7
      000227 40 10            [24] 1097 	jc	00104$
                                   1098 ;	main.c:198: I2C_Write_Byte((unsigned char)0xAC);
      000229 75 82 AC         [24] 1099 	mov	dpl,#0xac
      00022C C0 07            [24] 1100 	push	ar7
      00022E C0 06            [24] 1101 	push	ar6
      000230 12r00r4C         [24] 1102 	lcall	_I2C_Write_Byte
      000233 D0 06            [24] 1103 	pop	ar6
      000235 D0 07            [24] 1104 	pop	ar7
      000237 80 17            [24] 1105 	sjmp	00123$
      000239                       1106 00104$:
                                   1107 ;	main.c:201: if(addr <= 0x7FF){
      000239 C3               [12] 1108 	clr	c
      00023A 74 FF            [12] 1109 	mov	a,#0xff
      00023C 9E               [12] 1110 	subb	a,r6
      00023D 74 07            [12] 1111 	mov	a,#0x07
      00023F 9F               [12] 1112 	subb	a,r7
      000240 40 0E            [24] 1113 	jc	00123$
                                   1114 ;	main.c:202: I2C_Write_Byte((unsigned char)0xAE);
      000242 75 82 AE         [24] 1115 	mov	dpl,#0xae
      000245 C0 07            [24] 1116 	push	ar7
      000247 C0 06            [24] 1117 	push	ar6
      000249 12r00r4C         [24] 1118 	lcall	_I2C_Write_Byte
      00024C D0 06            [24] 1119 	pop	ar6
      00024E D0 07            [24] 1120 	pop	ar7
      000250                       1121 00123$:
                                   1122 ;	main.c:211: I2C_Write_Byte((unsigned char)addr);
      000250 8E 82            [24] 1123 	mov	dpl,r6
      000252 12r00r4C         [24] 1124 	lcall	_I2C_Write_Byte
                                   1125 ;	main.c:212: I2C_Write_Byte(databyte);
      000255 85*00 82         [24] 1126 	mov	dpl,_eebytew_PARM_2
      000258 12r00r4C         [24] 1127 	lcall	_I2C_Write_Byte
                                   1128 ;	main.c:213: I2C_Stop();
                                   1129 ;	main.c:215: }
      00025B 02r01r39         [24] 1130 	ljmp	_I2C_Stop
                                   1131 ;------------------------------------------------------------
                                   1132 ;Allocation info for local variables in function 'eebyter'
                                   1133 ;------------------------------------------------------------
                                   1134 ;addr                      Allocated to registers r6 r7 
                                   1135 ;rec                       Allocated to registers r7 
                                   1136 ;------------------------------------------------------------
                                   1137 ;	main.c:217: unsigned char eebyter(unsigned int addr)
                                   1138 ;	-----------------------------------------
                                   1139 ;	 function eebyter
                                   1140 ;	-----------------------------------------
      00025E                       1141 _eebyter:
      00025E AE 82            [24] 1142 	mov	r6,dpl
      000260 AF 83            [24] 1143 	mov	r7,dph
                                   1144 ;	main.c:220: I2C_Start();
      000262 C0 07            [24] 1145 	push	ar7
      000264 C0 06            [24] 1146 	push	ar6
      000266 12r00r3A         [24] 1147 	lcall	_I2C_Start
      000269 D0 06            [24] 1148 	pop	ar6
      00026B D0 07            [24] 1149 	pop	ar7
                                   1150 ;	main.c:221: if(addr <= 0xFF)
      00026D C3               [12] 1151 	clr	c
      00026E 74 FF            [12] 1152 	mov	a,#0xff
      000270 9E               [12] 1153 	subb	a,r6
      000271 E4               [12] 1154 	clr	a
      000272 9F               [12] 1155 	subb	a,r7
      000273 92*00            [24] 1156 	mov	_eebyter_sloc0_1_0,c
      000275 40 11            [24] 1157 	jc	00122$
                                   1158 ;	main.c:223: I2C_Write_Byte((unsigned char)0xA0);
      000277 75 82 A0         [24] 1159 	mov	dpl,#0xa0
      00027A C0 07            [24] 1160 	push	ar7
      00027C C0 06            [24] 1161 	push	ar6
      00027E 12r00r4C         [24] 1162 	lcall	_I2C_Write_Byte
      000281 D0 06            [24] 1163 	pop	ar6
      000283 D0 07            [24] 1164 	pop	ar7
      000285 02r03r36         [24] 1165 	ljmp	00123$
      000288                       1166 00122$:
                                   1167 ;	main.c:226: if(addr <= 0x1FF){
      000288 C3               [12] 1168 	clr	c
      000289 74 FF            [12] 1169 	mov	a,#0xff
      00028B 9E               [12] 1170 	subb	a,r6
      00028C 74 01            [12] 1171 	mov	a,#0x01
      00028E 9F               [12] 1172 	subb	a,r7
      00028F 40 11            [24] 1173 	jc	00119$
                                   1174 ;	main.c:227: I2C_Write_Byte((unsigned char)0xA2);
      000291 75 82 A2         [24] 1175 	mov	dpl,#0xa2
      000294 C0 07            [24] 1176 	push	ar7
      000296 C0 06            [24] 1177 	push	ar6
      000298 12r00r4C         [24] 1178 	lcall	_I2C_Write_Byte
      00029B D0 06            [24] 1179 	pop	ar6
      00029D D0 07            [24] 1180 	pop	ar7
      00029F 02r03r36         [24] 1181 	ljmp	00123$
      0002A2                       1182 00119$:
                                   1183 ;	main.c:230: if(addr <= 0x2FF){
      0002A2 C3               [12] 1184 	clr	c
      0002A3 74 FF            [12] 1185 	mov	a,#0xff
      0002A5 9E               [12] 1186 	subb	a,r6
      0002A6 74 02            [12] 1187 	mov	a,#0x02
      0002A8 9F               [12] 1188 	subb	a,r7
      0002A9 40 10            [24] 1189 	jc	00116$
                                   1190 ;	main.c:231: I2C_Write_Byte((unsigned char)0xA4);
      0002AB 75 82 A4         [24] 1191 	mov	dpl,#0xa4
      0002AE C0 07            [24] 1192 	push	ar7
      0002B0 C0 06            [24] 1193 	push	ar6
      0002B2 12r00r4C         [24] 1194 	lcall	_I2C_Write_Byte
      0002B5 D0 06            [24] 1195 	pop	ar6
      0002B7 D0 07            [24] 1196 	pop	ar7
      0002B9 80 7B            [24] 1197 	sjmp	00123$
      0002BB                       1198 00116$:
                                   1199 ;	main.c:234: if(addr <= 0x3FF){
      0002BB C3               [12] 1200 	clr	c
      0002BC 74 FF            [12] 1201 	mov	a,#0xff
      0002BE 9E               [12] 1202 	subb	a,r6
      0002BF 74 03            [12] 1203 	mov	a,#0x03
      0002C1 9F               [12] 1204 	subb	a,r7
      0002C2 40 10            [24] 1205 	jc	00113$
                                   1206 ;	main.c:235: I2C_Write_Byte((unsigned char)0xA6);
      0002C4 75 82 A6         [24] 1207 	mov	dpl,#0xa6
      0002C7 C0 07            [24] 1208 	push	ar7
      0002C9 C0 06            [24] 1209 	push	ar6
      0002CB 12r00r4C         [24] 1210 	lcall	_I2C_Write_Byte
      0002CE D0 06            [24] 1211 	pop	ar6
      0002D0 D0 07            [24] 1212 	pop	ar7
      0002D2 80 62            [24] 1213 	sjmp	00123$
      0002D4                       1214 00113$:
                                   1215 ;	main.c:238: if(addr <= 0x4FF){
      0002D4 C3               [12] 1216 	clr	c
      0002D5 74 FF            [12] 1217 	mov	a,#0xff
      0002D7 9E               [12] 1218 	subb	a,r6
      0002D8 74 04            [12] 1219 	mov	a,#0x04
      0002DA 9F               [12] 1220 	subb	a,r7
      0002DB 40 10            [24] 1221 	jc	00110$
                                   1222 ;	main.c:239: I2C_Write_Byte((unsigned char)0xA8);
      0002DD 75 82 A8         [24] 1223 	mov	dpl,#0xa8
      0002E0 C0 07            [24] 1224 	push	ar7
      0002E2 C0 06            [24] 1225 	push	ar6
      0002E4 12r00r4C         [24] 1226 	lcall	_I2C_Write_Byte
      0002E7 D0 06            [24] 1227 	pop	ar6
      0002E9 D0 07            [24] 1228 	pop	ar7
      0002EB 80 49            [24] 1229 	sjmp	00123$
      0002ED                       1230 00110$:
                                   1231 ;	main.c:242: if(addr <= 0x5FF){
      0002ED C3               [12] 1232 	clr	c
      0002EE 74 FF            [12] 1233 	mov	a,#0xff
      0002F0 9E               [12] 1234 	subb	a,r6
      0002F1 74 05            [12] 1235 	mov	a,#0x05
      0002F3 9F               [12] 1236 	subb	a,r7
      0002F4 40 10            [24] 1237 	jc	00107$
                                   1238 ;	main.c:243: I2C_Write_Byte((unsigned char)0xAA);
      0002F6 75 82 AA         [24] 1239 	mov	dpl,#0xaa
      0002F9 C0 07            [24] 1240 	push	ar7
      0002FB C0 06            [24] 1241 	push	ar6
      0002FD 12r00r4C         [24] 1242 	lcall	_I2C_Write_Byte
      000300 D0 06            [24] 1243 	pop	ar6
      000302 D0 07            [24] 1244 	pop	ar7
      000304 80 30            [24] 1245 	sjmp	00123$
      000306                       1246 00107$:
                                   1247 ;	main.c:246: if(addr <= 0x6FF){
      000306 C3               [12] 1248 	clr	c
      000307 74 FF            [12] 1249 	mov	a,#0xff
      000309 9E               [12] 1250 	subb	a,r6
      00030A 74 06            [12] 1251 	mov	a,#0x06
      00030C 9F               [12] 1252 	subb	a,r7
      00030D 40 10            [24] 1253 	jc	00104$
                                   1254 ;	main.c:247: I2C_Write_Byte((unsigned char)0xAC);
      00030F 75 82 AC         [24] 1255 	mov	dpl,#0xac
      000312 C0 07            [24] 1256 	push	ar7
      000314 C0 06            [24] 1257 	push	ar6
      000316 12r00r4C         [24] 1258 	lcall	_I2C_Write_Byte
      000319 D0 06            [24] 1259 	pop	ar6
      00031B D0 07            [24] 1260 	pop	ar7
      00031D 80 17            [24] 1261 	sjmp	00123$
      00031F                       1262 00104$:
                                   1263 ;	main.c:250: if(addr <= 0x7FF){
      00031F C3               [12] 1264 	clr	c
      000320 74 FF            [12] 1265 	mov	a,#0xff
      000322 9E               [12] 1266 	subb	a,r6
      000323 74 07            [12] 1267 	mov	a,#0x07
      000325 9F               [12] 1268 	subb	a,r7
      000326 40 0E            [24] 1269 	jc	00123$
                                   1270 ;	main.c:251: I2C_Write_Byte((unsigned char)0xAE);
      000328 75 82 AE         [24] 1271 	mov	dpl,#0xae
      00032B C0 07            [24] 1272 	push	ar7
      00032D C0 06            [24] 1273 	push	ar6
      00032F 12r00r4C         [24] 1274 	lcall	_I2C_Write_Byte
      000332 D0 06            [24] 1275 	pop	ar6
      000334 D0 07            [24] 1276 	pop	ar7
      000336                       1277 00123$:
                                   1278 ;	main.c:261: I2C_Write_Byte((unsigned char)addr);
      000336 8E 82            [24] 1279 	mov	dpl,r6
      000338 C0 07            [24] 1280 	push	ar7
      00033A C0 06            [24] 1281 	push	ar6
      00033C 12r00r4C         [24] 1282 	lcall	_I2C_Write_Byte
                                   1283 ;	main.c:262: RepeatedStartI2c();
      00033F 12r01r59         [24] 1284 	lcall	_RepeatedStartI2c
      000342 D0 06            [24] 1285 	pop	ar6
      000344 D0 07            [24] 1286 	pop	ar7
                                   1287 ;	main.c:263: if(addr <= 0xFF)
      000346 20*00 08         [24] 1288 	jb	_eebyter_sloc0_1_0,00145$
                                   1289 ;	main.c:265: I2C_Write_Byte((unsigned char)0xA1);
      000349 75 82 A1         [24] 1290 	mov	dpl,#0xa1
      00034C 12r00r4C         [24] 1291 	lcall	_I2C_Write_Byte
      00034F 80 75            [24] 1292 	sjmp	00146$
      000351                       1293 00145$:
                                   1294 ;	main.c:268: if(addr <= 0x1FF){
      000351 C3               [12] 1295 	clr	c
      000352 74 FF            [12] 1296 	mov	a,#0xff
      000354 9E               [12] 1297 	subb	a,r6
      000355 74 01            [12] 1298 	mov	a,#0x01
      000357 9F               [12] 1299 	subb	a,r7
      000358 40 08            [24] 1300 	jc	00142$
                                   1301 ;	main.c:269: I2C_Write_Byte((unsigned char)0xA3);
      00035A 75 82 A3         [24] 1302 	mov	dpl,#0xa3
      00035D 12r00r4C         [24] 1303 	lcall	_I2C_Write_Byte
      000360 80 64            [24] 1304 	sjmp	00146$
      000362                       1305 00142$:
                                   1306 ;	main.c:272: if(addr <= 0x2FF){
      000362 C3               [12] 1307 	clr	c
      000363 74 FF            [12] 1308 	mov	a,#0xff
      000365 9E               [12] 1309 	subb	a,r6
      000366 74 02            [12] 1310 	mov	a,#0x02
      000368 9F               [12] 1311 	subb	a,r7
      000369 40 08            [24] 1312 	jc	00139$
                                   1313 ;	main.c:273: I2C_Write_Byte((unsigned char)0xA5);
      00036B 75 82 A5         [24] 1314 	mov	dpl,#0xa5
      00036E 12r00r4C         [24] 1315 	lcall	_I2C_Write_Byte
      000371 80 53            [24] 1316 	sjmp	00146$
      000373                       1317 00139$:
                                   1318 ;	main.c:276: if(addr <= 0x3FF){
      000373 C3               [12] 1319 	clr	c
      000374 74 FF            [12] 1320 	mov	a,#0xff
      000376 9E               [12] 1321 	subb	a,r6
      000377 74 03            [12] 1322 	mov	a,#0x03
      000379 9F               [12] 1323 	subb	a,r7
      00037A 40 08            [24] 1324 	jc	00136$
                                   1325 ;	main.c:277: I2C_Write_Byte((unsigned char)0xA7);
      00037C 75 82 A7         [24] 1326 	mov	dpl,#0xa7
      00037F 12r00r4C         [24] 1327 	lcall	_I2C_Write_Byte
      000382 80 42            [24] 1328 	sjmp	00146$
      000384                       1329 00136$:
                                   1330 ;	main.c:280: if(addr <= 0x4FF){
      000384 C3               [12] 1331 	clr	c
      000385 74 FF            [12] 1332 	mov	a,#0xff
      000387 9E               [12] 1333 	subb	a,r6
      000388 74 04            [12] 1334 	mov	a,#0x04
      00038A 9F               [12] 1335 	subb	a,r7
      00038B 40 08            [24] 1336 	jc	00133$
                                   1337 ;	main.c:281: I2C_Write_Byte((unsigned char)0xA9);
      00038D 75 82 A9         [24] 1338 	mov	dpl,#0xa9
      000390 12r00r4C         [24] 1339 	lcall	_I2C_Write_Byte
      000393 80 31            [24] 1340 	sjmp	00146$
      000395                       1341 00133$:
                                   1342 ;	main.c:284: if(addr <= 0x5FF){
      000395 C3               [12] 1343 	clr	c
      000396 74 FF            [12] 1344 	mov	a,#0xff
      000398 9E               [12] 1345 	subb	a,r6
      000399 74 05            [12] 1346 	mov	a,#0x05
      00039B 9F               [12] 1347 	subb	a,r7
      00039C 40 08            [24] 1348 	jc	00130$
                                   1349 ;	main.c:285: I2C_Write_Byte((unsigned char)0xAB);
      00039E 75 82 AB         [24] 1350 	mov	dpl,#0xab
      0003A1 12r00r4C         [24] 1351 	lcall	_I2C_Write_Byte
      0003A4 80 20            [24] 1352 	sjmp	00146$
      0003A6                       1353 00130$:
                                   1354 ;	main.c:288: if(addr <= 0x6FF){
      0003A6 C3               [12] 1355 	clr	c
      0003A7 74 FF            [12] 1356 	mov	a,#0xff
      0003A9 9E               [12] 1357 	subb	a,r6
      0003AA 74 06            [12] 1358 	mov	a,#0x06
      0003AC 9F               [12] 1359 	subb	a,r7
      0003AD 40 08            [24] 1360 	jc	00127$
                                   1361 ;	main.c:289: I2C_Write_Byte((unsigned char)0xAD);
      0003AF 75 82 AD         [24] 1362 	mov	dpl,#0xad
      0003B2 12r00r4C         [24] 1363 	lcall	_I2C_Write_Byte
      0003B5 80 0F            [24] 1364 	sjmp	00146$
      0003B7                       1365 00127$:
                                   1366 ;	main.c:292: if(addr <= 0x7FF){
      0003B7 C3               [12] 1367 	clr	c
      0003B8 74 FF            [12] 1368 	mov	a,#0xff
      0003BA 9E               [12] 1369 	subb	a,r6
      0003BB 74 07            [12] 1370 	mov	a,#0x07
      0003BD 9F               [12] 1371 	subb	a,r7
      0003BE 40 06            [24] 1372 	jc	00146$
                                   1373 ;	main.c:293: I2C_Write_Byte((unsigned char)0xAF);
      0003C0 75 82 AF         [24] 1374 	mov	dpl,#0xaf
      0003C3 12r00r4C         [24] 1375 	lcall	_I2C_Write_Byte
      0003C6                       1376 00146$:
                                   1377 ;	main.c:303: rec=I2C_Read_Byte();
      0003C6 12r00rB2         [24] 1378 	lcall	_I2C_Read_Byte
      0003C9 AF 82            [24] 1379 	mov	r7,dpl
                                   1380 ;	main.c:304: I2C_Send_ACK();
      0003CB C0 07            [24] 1381 	push	ar7
      0003CD 12r01r01         [24] 1382 	lcall	_I2C_Send_ACK
                                   1383 ;	main.c:305: I2C_Stop();
      0003D0 12r01r39         [24] 1384 	lcall	_I2C_Stop
      0003D3 D0 07            [24] 1385 	pop	ar7
                                   1386 ;	main.c:306: return rec;
      0003D5 8F 82            [24] 1387 	mov	dpl,r7
                                   1388 ;	main.c:307: }
      0003D7 22               [24] 1389 	ret
                                   1390 ;------------------------------------------------------------
                                   1391 ;Allocation info for local variables in function 'main'
                                   1392 ;------------------------------------------------------------
                                   1393 ;rx                        Allocated to registers 
                                   1394 ;addr                      Allocated with name '_main_addr_131072_92'
                                   1395 ;addr1                     Allocated with name '_main_addr1_131072_92'
                                   1396 ;start_addr                Allocated with name '_main_start_addr_131072_92'
                                   1397 ;end_addr                  Allocated with name '_main_end_addr_131072_92'
                                   1398 ;data                      Allocated with name '_main_data_131072_92'
                                   1399 ;digit                     Allocated to registers r1 r2 
                                   1400 ;ch                        Allocated to registers r4 
                                   1401 ;rd                        Allocated to registers r5 
                                   1402 ;i                         Allocated to registers r0 r1 
                                   1403 ;------------------------------------------------------------
                                   1404 ;	main.c:309: void main(void)
                                   1405 ;	-----------------------------------------
                                   1406 ;	 function main
                                   1407 ;	-----------------------------------------
      0003D8                       1408 _main:
                                   1409 ;	main.c:312: I2C_init();					// Initialize i2c pins
      0003D8 12r00r35         [24] 1410 	lcall	_I2C_init
                                   1411 ;	main.c:313: printf("Starting I2C application\r\n");
      0003DB 74r00            [12] 1412 	mov	a,#___str_0
      0003DD C0 E0            [24] 1413 	push	acc
      0003DF 74s00            [12] 1414 	mov	a,#(___str_0 >> 8)
      0003E1 C0 E0            [24] 1415 	push	acc
      0003E3 74 80            [12] 1416 	mov	a,#0x80
      0003E5 C0 E0            [24] 1417 	push	acc
      0003E7 12r00r00         [24] 1418 	lcall	_printf
      0003EA 15 81            [12] 1419 	dec	sp
      0003EC 15 81            [12] 1420 	dec	sp
      0003EE 15 81            [12] 1421 	dec	sp
                                   1422 ;	main.c:314: printf("Help menu:\r\n");
      0003F0 74r1B            [12] 1423 	mov	a,#___str_1
      0003F2 C0 E0            [24] 1424 	push	acc
      0003F4 74s00            [12] 1425 	mov	a,#(___str_1 >> 8)
      0003F6 C0 E0            [24] 1426 	push	acc
      0003F8 74 80            [12] 1427 	mov	a,#0x80
      0003FA C0 E0            [24] 1428 	push	acc
      0003FC 12r00r00         [24] 1429 	lcall	_printf
      0003FF 15 81            [12] 1430 	dec	sp
      000401 15 81            [12] 1431 	dec	sp
      000403 15 81            [12] 1432 	dec	sp
                                   1433 ;	main.c:315: printf("'w': Enter an EEPROM address in hex to write data at and byte data\r\n");
      000405 74r28            [12] 1434 	mov	a,#___str_2
      000407 C0 E0            [24] 1435 	push	acc
      000409 74s00            [12] 1436 	mov	a,#(___str_2 >> 8)
      00040B C0 E0            [24] 1437 	push	acc
      00040D 74 80            [12] 1438 	mov	a,#0x80
      00040F C0 E0            [24] 1439 	push	acc
      000411 12r00r00         [24] 1440 	lcall	_printf
      000414 15 81            [12] 1441 	dec	sp
      000416 15 81            [12] 1442 	dec	sp
      000418 15 81            [12] 1443 	dec	sp
                                   1444 ;	main.c:316: printf("'r': Enter an EEPROM address in hex to read data from\r\n");
      00041A 74r6D            [12] 1445 	mov	a,#___str_3
      00041C C0 E0            [24] 1446 	push	acc
      00041E 74s00            [12] 1447 	mov	a,#(___str_3 >> 8)
      000420 C0 E0            [24] 1448 	push	acc
      000422 74 80            [12] 1449 	mov	a,#0x80
      000424 C0 E0            [24] 1450 	push	acc
      000426 12r00r00         [24] 1451 	lcall	_printf
      000429 15 81            [12] 1452 	dec	sp
      00042B 15 81            [12] 1453 	dec	sp
      00042D 15 81            [12] 1454 	dec	sp
                                   1455 ;	main.c:317: printf("'h': Enter an EEPROM start and end addresses to dump the data\r\n");
      00042F 74rA5            [12] 1456 	mov	a,#___str_4
      000431 C0 E0            [24] 1457 	push	acc
      000433 74s00            [12] 1458 	mov	a,#(___str_4 >> 8)
      000435 C0 E0            [24] 1459 	push	acc
      000437 74 80            [12] 1460 	mov	a,#0x80
      000439 C0 E0            [24] 1461 	push	acc
      00043B 12r00r00         [24] 1462 	lcall	_printf
      00043E 15 81            [12] 1463 	dec	sp
      000440 15 81            [12] 1464 	dec	sp
      000442 15 81            [12] 1465 	dec	sp
                                   1466 ;	main.c:318: printf("'e': Reset EEPROM\r\n");
      000444 74rE5            [12] 1467 	mov	a,#___str_5
      000446 C0 E0            [24] 1468 	push	acc
      000448 74s00            [12] 1469 	mov	a,#(___str_5 >> 8)
      00044A C0 E0            [24] 1470 	push	acc
      00044C 74 80            [12] 1471 	mov	a,#0x80
      00044E C0 E0            [24] 1472 	push	acc
      000450 12r00r00         [24] 1473 	lcall	_printf
      000453 15 81            [12] 1474 	dec	sp
      000455 15 81            [12] 1475 	dec	sp
      000457 15 81            [12] 1476 	dec	sp
                                   1477 ;	main.c:320: while(1)
      000459 E4               [12] 1478 	clr	a
      00045A FE               [12] 1479 	mov	r6,a
      00045B FF               [12] 1480 	mov	r7,a
      00045C F5*03            [12] 1481 	mov	_main_addr1_131072_92,a
      00045E F5*04            [12] 1482 	mov	(_main_addr1_131072_92 + 1),a
      000460 F5*05            [12] 1483 	mov	_main_start_addr_131072_92,a
      000462 F5*06            [12] 1484 	mov	(_main_start_addr_131072_92 + 1),a
      000464                       1485 00212$:
                                   1486 ;	main.c:322: unsigned int addr, addr1, start_addr, end_addr = 0;
      000464 E4               [12] 1487 	clr	a
      000465 F5*07            [12] 1488 	mov	_main_end_addr_131072_92,a
      000467 F5*08            [12] 1489 	mov	(_main_end_addr_131072_92 + 1),a
                                   1490 ;	main.c:323: unsigned int data = 0;
      000469 F5*09            [12] 1491 	mov	_main_data_131072_92,a
      00046B F5*0A            [12] 1492 	mov	(_main_data_131072_92 + 1),a
                                   1493 ;	main.c:325: char ch = getchar();
      00046D C0 07            [24] 1494 	push	ar7
      00046F C0 06            [24] 1495 	push	ar6
      000471 12r00r00         [24] 1496 	lcall	_getchar
      000474 AC 82            [24] 1497 	mov	r4,dpl
                                   1498 ;	main.c:326: putchar(ch);
      000476 8C 01            [24] 1499 	mov	ar1,r4
      000478 7D 00            [12] 1500 	mov	r5,#0x00
      00047A 89 82            [24] 1501 	mov	dpl,r1
      00047C 8D 83            [24] 1502 	mov	dph,r5
      00047E C0 04            [24] 1503 	push	ar4
      000480 12r00r0E         [24] 1504 	lcall	_putchar
                                   1505 ;	main.c:327: printf("\r\n");
      000483 74rF9            [12] 1506 	mov	a,#___str_6
      000485 C0 E0            [24] 1507 	push	acc
      000487 74s00            [12] 1508 	mov	a,#(___str_6 >> 8)
      000489 C0 E0            [24] 1509 	push	acc
      00048B 74 80            [12] 1510 	mov	a,#0x80
      00048D C0 E0            [24] 1511 	push	acc
      00048F 12r00r00         [24] 1512 	lcall	_printf
      000492 15 81            [12] 1513 	dec	sp
      000494 15 81            [12] 1514 	dec	sp
      000496 15 81            [12] 1515 	dec	sp
      000498 D0 04            [24] 1516 	pop	ar4
      00049A D0 06            [24] 1517 	pop	ar6
      00049C D0 07            [24] 1518 	pop	ar7
                                   1519 ;	main.c:328: switch(ch)
      00049E BC 68 03         [24] 1520 	cjne	r4,#0x68,00485$
      0004A1 02r07rBE         [24] 1521 	ljmp	00163$
      0004A4                       1522 00485$:
      0004A4 BC 72 03         [24] 1523 	cjne	r4,#0x72,00486$
      0004A7 02r06rA7         [24] 1524 	ljmp	00142$
      0004AA                       1525 00486$:
      0004AA BC 77 02         [24] 1526 	cjne	r4,#0x77,00487$
      0004AD 80 03            [24] 1527 	sjmp	00488$
      0004AF                       1528 00487$:
      0004AF 02r0Ar81         [24] 1529 	ljmp	00209$
      0004B2                       1530 00488$:
                                   1531 ;	main.c:331: printf("Enter the address location to store the data at : \r\n");
      0004B2 C0 07            [24] 1532 	push	ar7
      0004B4 C0 06            [24] 1533 	push	ar6
      0004B6 74rFC            [12] 1534 	mov	a,#___str_7
      0004B8 C0 E0            [24] 1535 	push	acc
      0004BA 74s00            [12] 1536 	mov	a,#(___str_7 >> 8)
      0004BC C0 E0            [24] 1537 	push	acc
      0004BE 74 80            [12] 1538 	mov	a,#0x80
      0004C0 C0 E0            [24] 1539 	push	acc
      0004C2 12r00r00         [24] 1540 	lcall	_printf
      0004C5 15 81            [12] 1541 	dec	sp
      0004C7 15 81            [12] 1542 	dec	sp
      0004C9 15 81            [12] 1543 	dec	sp
      0004CB D0 06            [24] 1544 	pop	ar6
      0004CD D0 07            [24] 1545 	pop	ar7
                                   1546 ;	main.c:332: while (1) {
      0004CF                       1547 00117$:
                                   1548 ;	main.c:333: ch = getchar();
      0004CF C0 07            [24] 1549 	push	ar7
      0004D1 C0 06            [24] 1550 	push	ar6
      0004D3 12r00r00         [24] 1551 	lcall	_getchar
      0004D6 AC 82            [24] 1552 	mov	r4,dpl
      0004D8 D0 06            [24] 1553 	pop	ar6
      0004DA D0 07            [24] 1554 	pop	ar7
                                   1555 ;	main.c:335: if ((int)ch == 13) { // Check until carriage return
      0004DC 8C 01            [24] 1556 	mov	ar1,r4
      0004DE 7D 00            [12] 1557 	mov	r5,#0x00
      0004E0 B9 0D 05         [24] 1558 	cjne	r1,#0x0d,00489$
      0004E3 BD 00 02         [24] 1559 	cjne	r5,#0x00,00489$
      0004E6 80 71            [24] 1560 	sjmp	00118$
      0004E8                       1561 00489$:
                                   1562 ;	main.c:339: if ((ch >= '0') && (ch <= '9')) {
      0004E8 BC 30 00         [24] 1563 	cjne	r4,#0x30,00490$
      0004EB                       1564 00490$:
      0004EB 40 0F            [24] 1565 	jc	00113$
      0004ED EC               [12] 1566 	mov	a,r4
      0004EE 24 C6            [12] 1567 	add	a,#0xff - 0x39
      0004F0 40 0A            [24] 1568 	jc	00113$
                                   1569 ;	main.c:340: digit = ch - '0';
      0004F2 E9               [12] 1570 	mov	a,r1
      0004F3 24 D0            [12] 1571 	add	a,#0xd0
      0004F5 F9               [12] 1572 	mov	r1,a
      0004F6 ED               [12] 1573 	mov	a,r5
      0004F7 34 FF            [12] 1574 	addc	a,#0xff
      0004F9 FD               [12] 1575 	mov	r5,a
      0004FA 80 44            [24] 1576 	sjmp	00114$
      0004FC                       1577 00113$:
                                   1578 ;	main.c:341: } else if ((ch >= 'A') && (ch <= 'F')) {
      0004FC BC 41 00         [24] 1579 	cjne	r4,#0x41,00493$
      0004FF                       1580 00493$:
      0004FF 40 13            [24] 1581 	jc	00109$
      000501 EC               [12] 1582 	mov	a,r4
      000502 24 B9            [12] 1583 	add	a,#0xff - 0x46
      000504 40 0E            [24] 1584 	jc	00109$
                                   1585 ;	main.c:342: digit = ch - 7 - '0';
      000506 8C 00            [24] 1586 	mov	ar0,r4
      000508 7B 00            [12] 1587 	mov	r3,#0x00
      00050A E8               [12] 1588 	mov	a,r0
      00050B 24 C9            [12] 1589 	add	a,#0xc9
      00050D F9               [12] 1590 	mov	r1,a
      00050E EB               [12] 1591 	mov	a,r3
      00050F 34 FF            [12] 1592 	addc	a,#0xff
      000511 FD               [12] 1593 	mov	r5,a
      000512 80 2C            [24] 1594 	sjmp	00114$
      000514                       1595 00109$:
                                   1596 ;	main.c:343: } else if ((ch >= 'a') && (ch <= 'f')) {
      000514 BC 61 00         [24] 1597 	cjne	r4,#0x61,00496$
      000517                       1598 00496$:
      000517 40 11            [24] 1599 	jc	00105$
      000519 EC               [12] 1600 	mov	a,r4
      00051A 24 99            [12] 1601 	add	a,#0xff - 0x66
      00051C 40 0C            [24] 1602 	jc	00105$
                                   1603 ;	main.c:344: digit = ch - 32 - 7 - '0';
      00051E 7B 00            [12] 1604 	mov	r3,#0x00
      000520 EC               [12] 1605 	mov	a,r4
      000521 24 A9            [12] 1606 	add	a,#0xa9
      000523 F9               [12] 1607 	mov	r1,a
      000524 EB               [12] 1608 	mov	a,r3
      000525 34 FF            [12] 1609 	addc	a,#0xff
      000527 FD               [12] 1610 	mov	r5,a
      000528 80 16            [24] 1611 	sjmp	00114$
      00052A                       1612 00105$:
                                   1613 ;	main.c:346: printf("Invalid input. Please enter 0-9, A-F or a-f only.\r\n");
      00052A 74r31            [12] 1614 	mov	a,#___str_8
      00052C C0 E0            [24] 1615 	push	acc
      00052E 74s01            [12] 1616 	mov	a,#(___str_8 >> 8)
      000530 C0 E0            [24] 1617 	push	acc
      000532 74 80            [12] 1618 	mov	a,#0x80
      000534 C0 E0            [24] 1619 	push	acc
      000536 12r00r00         [24] 1620 	lcall	_printf
      000539 15 81            [12] 1621 	dec	sp
      00053B 15 81            [12] 1622 	dec	sp
      00053D 15 81            [12] 1623 	dec	sp
                                   1624 ;	main.c:347: return;
      00053F 22               [24] 1625 	ret
      000540                       1626 00114$:
                                   1627 ;	main.c:349: addr = addr * 16 + digit;
      000540 8E 03            [24] 1628 	mov	ar3,r6
      000542 EF               [12] 1629 	mov	a,r7
      000543 C4               [12] 1630 	swap	a
      000544 54 F0            [12] 1631 	anl	a,#0xf0
      000546 CB               [12] 1632 	xch	a,r3
      000547 C4               [12] 1633 	swap	a
      000548 CB               [12] 1634 	xch	a,r3
      000549 6B               [12] 1635 	xrl	a,r3
      00054A CB               [12] 1636 	xch	a,r3
      00054B 54 F0            [12] 1637 	anl	a,#0xf0
      00054D CB               [12] 1638 	xch	a,r3
      00054E 6B               [12] 1639 	xrl	a,r3
      00054F FC               [12] 1640 	mov	r4,a
      000550 E9               [12] 1641 	mov	a,r1
      000551 2B               [12] 1642 	add	a,r3
      000552 FE               [12] 1643 	mov	r6,a
      000553 ED               [12] 1644 	mov	a,r5
      000554 3C               [12] 1645 	addc	a,r4
      000555 FF               [12] 1646 	mov	r7,a
      000556 02r04rCF         [24] 1647 	ljmp	00117$
      000559                       1648 00118$:
                                   1649 ;	main.c:353: printf("Entered address: 0x%x\r\n", addr);
      000559 C0 07            [24] 1650 	push	ar7
      00055B C0 06            [24] 1651 	push	ar6
      00055D C0 06            [24] 1652 	push	ar6
      00055F C0 07            [24] 1653 	push	ar7
      000561 74r65            [12] 1654 	mov	a,#___str_9
      000563 C0 E0            [24] 1655 	push	acc
      000565 74s01            [12] 1656 	mov	a,#(___str_9 >> 8)
      000567 C0 E0            [24] 1657 	push	acc
      000569 74 80            [12] 1658 	mov	a,#0x80
      00056B C0 E0            [24] 1659 	push	acc
      00056D 12r00r00         [24] 1660 	lcall	_printf
      000570 E5 81            [12] 1661 	mov	a,sp
      000572 24 FB            [12] 1662 	add	a,#0xfb
      000574 F5 81            [12] 1663 	mov	sp,a
      000576 D0 06            [24] 1664 	pop	ar6
      000578 D0 07            [24] 1665 	pop	ar7
                                   1666 ;	main.c:356: if ((addr < 0x0) || (addr > 0x7FF)) {
      00057A C3               [12] 1667 	clr	c
      00057B 74 FF            [12] 1668 	mov	a,#0xff
      00057D 9E               [12] 1669 	subb	a,r6
      00057E 74 07            [12] 1670 	mov	a,#0x07
      000580 9F               [12] 1671 	subb	a,r7
      000581 50 20            [24] 1672 	jnc	00120$
                                   1673 ;	main.c:357: printf("Invalid buffer address. The address should be between 0 and 7FF.\r\n");
      000583 C0 07            [24] 1674 	push	ar7
      000585 C0 06            [24] 1675 	push	ar6
      000587 74r7D            [12] 1676 	mov	a,#___str_10
      000589 C0 E0            [24] 1677 	push	acc
      00058B 74s01            [12] 1678 	mov	a,#(___str_10 >> 8)
      00058D C0 E0            [24] 1679 	push	acc
      00058F 74 80            [12] 1680 	mov	a,#0x80
      000591 C0 E0            [24] 1681 	push	acc
      000593 12r00r00         [24] 1682 	lcall	_printf
      000596 15 81            [12] 1683 	dec	sp
      000598 15 81            [12] 1684 	dec	sp
      00059A 15 81            [12] 1685 	dec	sp
      00059C D0 06            [24] 1686 	pop	ar6
      00059E D0 07            [24] 1687 	pop	ar7
                                   1688 ;	main.c:358: break;
      0005A0 02r04r64         [24] 1689 	ljmp	00212$
      0005A3                       1690 00120$:
                                   1691 ;	main.c:361: printf("Enter the data byte to write:\r\n");
      0005A3 C0 07            [24] 1692 	push	ar7
      0005A5 C0 06            [24] 1693 	push	ar6
      0005A7 74rC0            [12] 1694 	mov	a,#___str_11
      0005A9 C0 E0            [24] 1695 	push	acc
      0005AB 74s01            [12] 1696 	mov	a,#(___str_11 >> 8)
      0005AD C0 E0            [24] 1697 	push	acc
      0005AF 74 80            [12] 1698 	mov	a,#0x80
      0005B1 C0 E0            [24] 1699 	push	acc
      0005B3 12r00r00         [24] 1700 	lcall	_printf
      0005B6 15 81            [12] 1701 	dec	sp
      0005B8 15 81            [12] 1702 	dec	sp
      0005BA 15 81            [12] 1703 	dec	sp
      0005BC D0 06            [24] 1704 	pop	ar6
      0005BE D0 07            [24] 1705 	pop	ar7
                                   1706 ;	main.c:363: while (1) {
      0005C0                       1707 00137$:
                                   1708 ;	main.c:364: ch = getchar();
      0005C0 C0 07            [24] 1709 	push	ar7
      0005C2 C0 06            [24] 1710 	push	ar6
      0005C4 12r00r00         [24] 1711 	lcall	_getchar
      0005C7 AC 82            [24] 1712 	mov	r4,dpl
      0005C9 D0 06            [24] 1713 	pop	ar6
      0005CB D0 07            [24] 1714 	pop	ar7
                                   1715 ;	main.c:366: if ((int)ch == 13) { // Check until carriage return
      0005CD 8C 03            [24] 1716 	mov	ar3,r4
      0005CF 7D 00            [12] 1717 	mov	r5,#0x00
      0005D1 BB 0D 05         [24] 1718 	cjne	r3,#0x0d,00500$
      0005D4 BD 00 02         [24] 1719 	cjne	r5,#0x00,00500$
      0005D7 80 6E            [24] 1720 	sjmp	00138$
      0005D9                       1721 00500$:
                                   1722 ;	main.c:370: if ((ch >= '0') && (ch <= '9')) {
      0005D9 BC 30 00         [24] 1723 	cjne	r4,#0x30,00501$
      0005DC                       1724 00501$:
      0005DC 40 0F            [24] 1725 	jc	00133$
      0005DE EC               [12] 1726 	mov	a,r4
      0005DF 24 C6            [12] 1727 	add	a,#0xff - 0x39
      0005E1 40 0A            [24] 1728 	jc	00133$
                                   1729 ;	main.c:371: digit = ch - '0';
      0005E3 EB               [12] 1730 	mov	a,r3
      0005E4 24 D0            [12] 1731 	add	a,#0xd0
      0005E6 F9               [12] 1732 	mov	r1,a
      0005E7 ED               [12] 1733 	mov	a,r5
      0005E8 34 FF            [12] 1734 	addc	a,#0xff
      0005EA FA               [12] 1735 	mov	r2,a
      0005EB 80 3E            [24] 1736 	sjmp	00134$
      0005ED                       1737 00133$:
                                   1738 ;	main.c:372: } else if ((ch >= 'A') && (ch <= 'F')) {
      0005ED BC 41 00         [24] 1739 	cjne	r4,#0x41,00504$
      0005F0                       1740 00504$:
      0005F0 40 0F            [24] 1741 	jc	00129$
      0005F2 EC               [12] 1742 	mov	a,r4
      0005F3 24 B9            [12] 1743 	add	a,#0xff - 0x46
      0005F5 40 0A            [24] 1744 	jc	00129$
                                   1745 ;	main.c:373: digit = ch - 7 - '0';
      0005F7 EB               [12] 1746 	mov	a,r3
      0005F8 24 C9            [12] 1747 	add	a,#0xc9
      0005FA F9               [12] 1748 	mov	r1,a
      0005FB ED               [12] 1749 	mov	a,r5
      0005FC 34 FF            [12] 1750 	addc	a,#0xff
      0005FE FA               [12] 1751 	mov	r2,a
      0005FF 80 2A            [24] 1752 	sjmp	00134$
      000601                       1753 00129$:
                                   1754 ;	main.c:374: } else if ((ch >= 'a') && (ch <= 'f')) {
      000601 BC 61 00         [24] 1755 	cjne	r4,#0x61,00507$
      000604                       1756 00507$:
      000604 40 0F            [24] 1757 	jc	00125$
      000606 EC               [12] 1758 	mov	a,r4
      000607 24 99            [12] 1759 	add	a,#0xff - 0x66
      000609 40 0A            [24] 1760 	jc	00125$
                                   1761 ;	main.c:375: digit = ch - 32 - 7 - '0';
      00060B EB               [12] 1762 	mov	a,r3
      00060C 24 A9            [12] 1763 	add	a,#0xa9
      00060E F9               [12] 1764 	mov	r1,a
      00060F ED               [12] 1765 	mov	a,r5
      000610 34 FF            [12] 1766 	addc	a,#0xff
      000612 FA               [12] 1767 	mov	r2,a
      000613 80 16            [24] 1768 	sjmp	00134$
      000615                       1769 00125$:
                                   1770 ;	main.c:377: printf("Invalid input. Please enter 0-9, A-F or a-f only.\r\n");
      000615 74r31            [12] 1771 	mov	a,#___str_8
      000617 C0 E0            [24] 1772 	push	acc
      000619 74s01            [12] 1773 	mov	a,#(___str_8 >> 8)
      00061B C0 E0            [24] 1774 	push	acc
      00061D 74 80            [12] 1775 	mov	a,#0x80
      00061F C0 E0            [24] 1776 	push	acc
      000621 12r00r00         [24] 1777 	lcall	_printf
      000624 15 81            [12] 1778 	dec	sp
      000626 15 81            [12] 1779 	dec	sp
      000628 15 81            [12] 1780 	dec	sp
                                   1781 ;	main.c:378: return;
      00062A 22               [24] 1782 	ret
      00062B                       1783 00134$:
                                   1784 ;	main.c:380: data = data * 16 + digit;
      00062B AC*09            [24] 1785 	mov	r4,_main_data_131072_92
      00062D E5*0A            [12] 1786 	mov	a,(_main_data_131072_92 + 1)
      00062F C4               [12] 1787 	swap	a
      000630 54 F0            [12] 1788 	anl	a,#0xf0
      000632 CC               [12] 1789 	xch	a,r4
      000633 C4               [12] 1790 	swap	a
      000634 CC               [12] 1791 	xch	a,r4
      000635 6C               [12] 1792 	xrl	a,r4
      000636 CC               [12] 1793 	xch	a,r4
      000637 54 F0            [12] 1794 	anl	a,#0xf0
      000639 CC               [12] 1795 	xch	a,r4
      00063A 6C               [12] 1796 	xrl	a,r4
      00063B FD               [12] 1797 	mov	r5,a
      00063C E9               [12] 1798 	mov	a,r1
      00063D 2C               [12] 1799 	add	a,r4
      00063E F5*09            [12] 1800 	mov	_main_data_131072_92,a
      000640 EA               [12] 1801 	mov	a,r2
      000641 3D               [12] 1802 	addc	a,r5
      000642 F5*0A            [12] 1803 	mov	(_main_data_131072_92 + 1),a
      000644 02r05rC0         [24] 1804 	ljmp	00137$
      000647                       1805 00138$:
                                   1806 ;	main.c:384: printf("Entered data: 0x%x\r\n", data);
      000647 C0 07            [24] 1807 	push	ar7
      000649 C0 06            [24] 1808 	push	ar6
      00064B C0*09            [24] 1809 	push	_main_data_131072_92
      00064D C0*0A            [24] 1810 	push	(_main_data_131072_92 + 1)
      00064F 74rE0            [12] 1811 	mov	a,#___str_12
      000651 C0 E0            [24] 1812 	push	acc
      000653 74s01            [12] 1813 	mov	a,#(___str_12 >> 8)
      000655 C0 E0            [24] 1814 	push	acc
      000657 74 80            [12] 1815 	mov	a,#0x80
      000659 C0 E0            [24] 1816 	push	acc
      00065B 12r00r00         [24] 1817 	lcall	_printf
      00065E E5 81            [12] 1818 	mov	a,sp
      000660 24 FB            [12] 1819 	add	a,#0xfb
      000662 F5 81            [12] 1820 	mov	sp,a
      000664 D0 06            [24] 1821 	pop	ar6
      000666 D0 07            [24] 1822 	pop	ar7
                                   1823 ;	main.c:387: if ((data < 0x0) || (data > 0xFF)) {
      000668 C3               [12] 1824 	clr	c
      000669 74 FF            [12] 1825 	mov	a,#0xff
      00066B 95*09            [12] 1826 	subb	a,_main_data_131072_92
      00066D E4               [12] 1827 	clr	a
      00066E 95*0A            [12] 1828 	subb	a,(_main_data_131072_92 + 1)
      000670 50 20            [24] 1829 	jnc	00140$
                                   1830 ;	main.c:388: printf("Invalid buffer data. The data should be between 0 and FF.\r\n");
      000672 C0 07            [24] 1831 	push	ar7
      000674 C0 06            [24] 1832 	push	ar6
      000676 74rF5            [12] 1833 	mov	a,#___str_13
      000678 C0 E0            [24] 1834 	push	acc
      00067A 74s01            [12] 1835 	mov	a,#(___str_13 >> 8)
      00067C C0 E0            [24] 1836 	push	acc
      00067E 74 80            [12] 1837 	mov	a,#0x80
      000680 C0 E0            [24] 1838 	push	acc
      000682 12r00r00         [24] 1839 	lcall	_printf
      000685 15 81            [12] 1840 	dec	sp
      000687 15 81            [12] 1841 	dec	sp
      000689 15 81            [12] 1842 	dec	sp
      00068B D0 06            [24] 1843 	pop	ar6
      00068D D0 07            [24] 1844 	pop	ar7
                                   1845 ;	main.c:389: break;
      00068F 02r04r64         [24] 1846 	ljmp	00212$
      000692                       1847 00140$:
                                   1848 ;	main.c:392: eebytew(addr, data);
      000692 85*09*00         [24] 1849 	mov	_eebytew_PARM_2,_main_data_131072_92
      000695 8E 82            [24] 1850 	mov	dpl,r6
      000697 8F 83            [24] 1851 	mov	dph,r7
      000699 C0 07            [24] 1852 	push	ar7
      00069B C0 06            [24] 1853 	push	ar6
      00069D 12r01r79         [24] 1854 	lcall	_eebytew
      0006A0 D0 06            [24] 1855 	pop	ar6
      0006A2 D0 07            [24] 1856 	pop	ar7
                                   1857 ;	main.c:393: break;
      0006A4 02r04r64         [24] 1858 	ljmp	00212$
                                   1859 ;	main.c:396: case 'r':
      0006A7                       1860 00142$:
                                   1861 ;	main.c:397: printf("Enter the address location to read the data from : \r\n");
      0006A7 C0 07            [24] 1862 	push	ar7
      0006A9 C0 06            [24] 1863 	push	ar6
      0006AB 74r31            [12] 1864 	mov	a,#___str_14
      0006AD C0 E0            [24] 1865 	push	acc
      0006AF 74s02            [12] 1866 	mov	a,#(___str_14 >> 8)
      0006B1 C0 E0            [24] 1867 	push	acc
      0006B3 74 80            [12] 1868 	mov	a,#0x80
      0006B5 C0 E0            [24] 1869 	push	acc
      0006B7 12r00r00         [24] 1870 	lcall	_printf
      0006BA 15 81            [12] 1871 	dec	sp
      0006BC 15 81            [12] 1872 	dec	sp
      0006BE 15 81            [12] 1873 	dec	sp
      0006C0 D0 06            [24] 1874 	pop	ar6
      0006C2 D0 07            [24] 1875 	pop	ar7
                                   1876 ;	main.c:398: while (1) {
      0006C4                       1877 00158$:
                                   1878 ;	main.c:399: ch = getchar();
      0006C4 C0 07            [24] 1879 	push	ar7
      0006C6 C0 06            [24] 1880 	push	ar6
      0006C8 12r00r00         [24] 1881 	lcall	_getchar
      0006CB AC 82            [24] 1882 	mov	r4,dpl
      0006CD D0 06            [24] 1883 	pop	ar6
      0006CF D0 07            [24] 1884 	pop	ar7
                                   1885 ;	main.c:401: if ((int)ch == 13) { // Check until carriage return
      0006D1 8C 03            [24] 1886 	mov	ar3,r4
      0006D3 7D 00            [12] 1887 	mov	r5,#0x00
      0006D5 BB 0D 05         [24] 1888 	cjne	r3,#0x0d,00511$
      0006D8 BD 00 02         [24] 1889 	cjne	r5,#0x00,00511$
      0006DB 80 6E            [24] 1890 	sjmp	00159$
      0006DD                       1891 00511$:
                                   1892 ;	main.c:405: if ((ch >= '0') && (ch <= '9')) {
      0006DD BC 30 00         [24] 1893 	cjne	r4,#0x30,00512$
      0006E0                       1894 00512$:
      0006E0 40 0F            [24] 1895 	jc	00154$
      0006E2 EC               [12] 1896 	mov	a,r4
      0006E3 24 C6            [12] 1897 	add	a,#0xff - 0x39
      0006E5 40 0A            [24] 1898 	jc	00154$
                                   1899 ;	main.c:406: digit = ch - '0';
      0006E7 EB               [12] 1900 	mov	a,r3
      0006E8 24 D0            [12] 1901 	add	a,#0xd0
      0006EA F9               [12] 1902 	mov	r1,a
      0006EB ED               [12] 1903 	mov	a,r5
      0006EC 34 FF            [12] 1904 	addc	a,#0xff
      0006EE FA               [12] 1905 	mov	r2,a
      0006EF 80 3E            [24] 1906 	sjmp	00155$
      0006F1                       1907 00154$:
                                   1908 ;	main.c:407: } else if ((ch >= 'A') && (ch <= 'F')) {
      0006F1 BC 41 00         [24] 1909 	cjne	r4,#0x41,00515$
      0006F4                       1910 00515$:
      0006F4 40 0F            [24] 1911 	jc	00150$
      0006F6 EC               [12] 1912 	mov	a,r4
      0006F7 24 B9            [12] 1913 	add	a,#0xff - 0x46
      0006F9 40 0A            [24] 1914 	jc	00150$
                                   1915 ;	main.c:408: digit = ch - 7 - '0';
      0006FB EB               [12] 1916 	mov	a,r3
      0006FC 24 C9            [12] 1917 	add	a,#0xc9
      0006FE F9               [12] 1918 	mov	r1,a
      0006FF ED               [12] 1919 	mov	a,r5
      000700 34 FF            [12] 1920 	addc	a,#0xff
      000702 FA               [12] 1921 	mov	r2,a
      000703 80 2A            [24] 1922 	sjmp	00155$
      000705                       1923 00150$:
                                   1924 ;	main.c:409: } else if ((ch >= 'a') && (ch <= 'f')) {
      000705 BC 61 00         [24] 1925 	cjne	r4,#0x61,00518$
      000708                       1926 00518$:
      000708 40 0F            [24] 1927 	jc	00146$
      00070A EC               [12] 1928 	mov	a,r4
      00070B 24 99            [12] 1929 	add	a,#0xff - 0x66
      00070D 40 0A            [24] 1930 	jc	00146$
                                   1931 ;	main.c:410: digit = ch - 32 - 7 - '0';
      00070F EB               [12] 1932 	mov	a,r3
      000710 24 A9            [12] 1933 	add	a,#0xa9
      000712 F9               [12] 1934 	mov	r1,a
      000713 ED               [12] 1935 	mov	a,r5
      000714 34 FF            [12] 1936 	addc	a,#0xff
      000716 FA               [12] 1937 	mov	r2,a
      000717 80 16            [24] 1938 	sjmp	00155$
      000719                       1939 00146$:
                                   1940 ;	main.c:412: printf("Invalid input. Please enter 0-9, A-F or a-f.\r\n");
      000719 74r67            [12] 1941 	mov	a,#___str_15
      00071B C0 E0            [24] 1942 	push	acc
      00071D 74s02            [12] 1943 	mov	a,#(___str_15 >> 8)
      00071F C0 E0            [24] 1944 	push	acc
      000721 74 80            [12] 1945 	mov	a,#0x80
      000723 C0 E0            [24] 1946 	push	acc
      000725 12r00r00         [24] 1947 	lcall	_printf
      000728 15 81            [12] 1948 	dec	sp
      00072A 15 81            [12] 1949 	dec	sp
      00072C 15 81            [12] 1950 	dec	sp
                                   1951 ;	main.c:413: return;
      00072E 22               [24] 1952 	ret
      00072F                       1953 00155$:
                                   1954 ;	main.c:415: addr1 = addr1 * 16 + digit;
      00072F AC*03            [24] 1955 	mov	r4,_main_addr1_131072_92
      000731 E5*04            [12] 1956 	mov	a,(_main_addr1_131072_92 + 1)
      000733 C4               [12] 1957 	swap	a
      000734 54 F0            [12] 1958 	anl	a,#0xf0
      000736 CC               [12] 1959 	xch	a,r4
      000737 C4               [12] 1960 	swap	a
      000738 CC               [12] 1961 	xch	a,r4
      000739 6C               [12] 1962 	xrl	a,r4
      00073A CC               [12] 1963 	xch	a,r4
      00073B 54 F0            [12] 1964 	anl	a,#0xf0
      00073D CC               [12] 1965 	xch	a,r4
      00073E 6C               [12] 1966 	xrl	a,r4
      00073F FD               [12] 1967 	mov	r5,a
      000740 E9               [12] 1968 	mov	a,r1
      000741 2C               [12] 1969 	add	a,r4
      000742 F5*03            [12] 1970 	mov	_main_addr1_131072_92,a
      000744 EA               [12] 1971 	mov	a,r2
      000745 3D               [12] 1972 	addc	a,r5
      000746 F5*04            [12] 1973 	mov	(_main_addr1_131072_92 + 1),a
      000748 02r06rC4         [24] 1974 	ljmp	00158$
      00074B                       1975 00159$:
                                   1976 ;	main.c:419: printf("Entered address: 0x%x\r\n", addr1);
      00074B C0 07            [24] 1977 	push	ar7
      00074D C0 06            [24] 1978 	push	ar6
      00074F C0*03            [24] 1979 	push	_main_addr1_131072_92
      000751 C0*04            [24] 1980 	push	(_main_addr1_131072_92 + 1)
      000753 74r65            [12] 1981 	mov	a,#___str_9
      000755 C0 E0            [24] 1982 	push	acc
      000757 74s01            [12] 1983 	mov	a,#(___str_9 >> 8)
      000759 C0 E0            [24] 1984 	push	acc
      00075B 74 80            [12] 1985 	mov	a,#0x80
      00075D C0 E0            [24] 1986 	push	acc
      00075F 12r00r00         [24] 1987 	lcall	_printf
      000762 E5 81            [12] 1988 	mov	a,sp
      000764 24 FB            [12] 1989 	add	a,#0xfb
      000766 F5 81            [12] 1990 	mov	sp,a
      000768 D0 06            [24] 1991 	pop	ar6
      00076A D0 07            [24] 1992 	pop	ar7
                                   1993 ;	main.c:422: if ((addr1 < 0x0) || (addr1 > 0x7FF)) {
      00076C C3               [12] 1994 	clr	c
      00076D 74 FF            [12] 1995 	mov	a,#0xff
      00076F 95*03            [12] 1996 	subb	a,_main_addr1_131072_92
      000771 74 07            [12] 1997 	mov	a,#0x07
      000773 95*04            [12] 1998 	subb	a,(_main_addr1_131072_92 + 1)
      000775 50 16            [24] 1999 	jnc	00161$
                                   2000 ;	main.c:423: printf("Invalid buffer address. The address should be between 0 and 7FF.\r\n");
      000777 74r7D            [12] 2001 	mov	a,#___str_10
      000779 C0 E0            [24] 2002 	push	acc
      00077B 74s01            [12] 2003 	mov	a,#(___str_10 >> 8)
      00077D C0 E0            [24] 2004 	push	acc
      00077F 74 80            [12] 2005 	mov	a,#0x80
      000781 C0 E0            [24] 2006 	push	acc
      000783 12r00r00         [24] 2007 	lcall	_printf
      000786 15 81            [12] 2008 	dec	sp
      000788 15 81            [12] 2009 	dec	sp
      00078A 15 81            [12] 2010 	dec	sp
                                   2011 ;	main.c:424: return;
      00078C 22               [24] 2012 	ret
      00078D                       2013 00161$:
                                   2014 ;	main.c:426: unsigned char rd = eebyter(addr1);
      00078D 85*03 82         [24] 2015 	mov	dpl,_main_addr1_131072_92
      000790 85*04 83         [24] 2016 	mov	dph,(_main_addr1_131072_92 + 1)
      000793 C0 07            [24] 2017 	push	ar7
      000795 C0 06            [24] 2018 	push	ar6
      000797 12r02r5E         [24] 2019 	lcall	_eebyter
      00079A AD 82            [24] 2020 	mov	r5,dpl
                                   2021 ;	main.c:427: printf("read data: 0x%x\r\n", rd);
      00079C 7C 00            [12] 2022 	mov	r4,#0x00
      00079E C0 05            [24] 2023 	push	ar5
      0007A0 C0 04            [24] 2024 	push	ar4
      0007A2 74r96            [12] 2025 	mov	a,#___str_16
      0007A4 C0 E0            [24] 2026 	push	acc
      0007A6 74s02            [12] 2027 	mov	a,#(___str_16 >> 8)
      0007A8 C0 E0            [24] 2028 	push	acc
      0007AA 74 80            [12] 2029 	mov	a,#0x80
      0007AC C0 E0            [24] 2030 	push	acc
      0007AE 12r00r00         [24] 2031 	lcall	_printf
      0007B1 E5 81            [12] 2032 	mov	a,sp
      0007B3 24 FB            [12] 2033 	add	a,#0xfb
      0007B5 F5 81            [12] 2034 	mov	sp,a
      0007B7 D0 06            [24] 2035 	pop	ar6
      0007B9 D0 07            [24] 2036 	pop	ar7
                                   2037 ;	main.c:428: break;
      0007BB 02r04r64         [24] 2038 	ljmp	00212$
                                   2039 ;	main.c:430: case 'h':
      0007BE                       2040 00163$:
                                   2041 ;	main.c:431: printf("Enter the start address for dump:\r\n");
      0007BE 74rA8            [12] 2042 	mov	a,#___str_17
      0007C0 C0 E0            [24] 2043 	push	acc
      0007C2 74s02            [12] 2044 	mov	a,#(___str_17 >> 8)
      0007C4 C0 E0            [24] 2045 	push	acc
      0007C6 74 80            [12] 2046 	mov	a,#0x80
      0007C8 C0 E0            [24] 2047 	push	acc
      0007CA 12r00r00         [24] 2048 	lcall	_printf
      0007CD 15 81            [12] 2049 	dec	sp
      0007CF 15 81            [12] 2050 	dec	sp
      0007D1 15 81            [12] 2051 	dec	sp
                                   2052 ;	main.c:432: while (1) {
      0007D3                       2053 00179$:
                                   2054 ;	main.c:433: ch = getchar();
      0007D3 12r00r00         [24] 2055 	lcall	_getchar
      0007D6 AC 82            [24] 2056 	mov	r4,dpl
                                   2057 ;	main.c:435: if ((int)ch == 13) { // Check until carriage return
      0007D8 8C 05            [24] 2058 	mov	ar5,r4
      0007DA 7B 00            [12] 2059 	mov	r3,#0x00
      0007DC BD 0D 05         [24] 2060 	cjne	r5,#0x0d,00522$
      0007DF BB 00 02         [24] 2061 	cjne	r3,#0x00,00522$
      0007E2 80 74            [24] 2062 	sjmp	00180$
      0007E4                       2063 00522$:
                                   2064 ;	main.c:439: if ((ch >= '0') && (ch <= '9')) {
      0007E4 BC 30 00         [24] 2065 	cjne	r4,#0x30,00523$
      0007E7                       2066 00523$:
      0007E7 40 0F            [24] 2067 	jc	00175$
      0007E9 EC               [12] 2068 	mov	a,r4
      0007EA 24 C6            [12] 2069 	add	a,#0xff - 0x39
      0007EC 40 0A            [24] 2070 	jc	00175$
                                   2071 ;	main.c:440: digit = ch - '0';
      0007EE ED               [12] 2072 	mov	a,r5
      0007EF 24 D0            [12] 2073 	add	a,#0xd0
      0007F1 FD               [12] 2074 	mov	r5,a
      0007F2 EB               [12] 2075 	mov	a,r3
      0007F3 34 FF            [12] 2076 	addc	a,#0xff
      0007F5 FB               [12] 2077 	mov	r3,a
      0007F6 80 44            [24] 2078 	sjmp	00176$
      0007F8                       2079 00175$:
                                   2080 ;	main.c:441: } else if ((ch >= 'A') && (ch <= 'F')) {
      0007F8 BC 41 00         [24] 2081 	cjne	r4,#0x41,00526$
      0007FB                       2082 00526$:
      0007FB 40 13            [24] 2083 	jc	00171$
      0007FD EC               [12] 2084 	mov	a,r4
      0007FE 24 B9            [12] 2085 	add	a,#0xff - 0x46
      000800 40 0E            [24] 2086 	jc	00171$
                                   2087 ;	main.c:442: digit = ch - 7 - '0';
      000802 8C 01            [24] 2088 	mov	ar1,r4
      000804 7A 00            [12] 2089 	mov	r2,#0x00
      000806 E9               [12] 2090 	mov	a,r1
      000807 24 C9            [12] 2091 	add	a,#0xc9
      000809 FD               [12] 2092 	mov	r5,a
      00080A EA               [12] 2093 	mov	a,r2
      00080B 34 FF            [12] 2094 	addc	a,#0xff
      00080D FB               [12] 2095 	mov	r3,a
      00080E 80 2C            [24] 2096 	sjmp	00176$
      000810                       2097 00171$:
                                   2098 ;	main.c:443: } else if ((ch >= 'a') && (ch <= 'f')) {
      000810 BC 61 00         [24] 2099 	cjne	r4,#0x61,00529$
      000813                       2100 00529$:
      000813 40 11            [24] 2101 	jc	00167$
      000815 EC               [12] 2102 	mov	a,r4
      000816 24 99            [12] 2103 	add	a,#0xff - 0x66
      000818 40 0C            [24] 2104 	jc	00167$
                                   2105 ;	main.c:444: digit = ch - 32 - 7 - '0';
      00081A 7A 00            [12] 2106 	mov	r2,#0x00
      00081C EC               [12] 2107 	mov	a,r4
      00081D 24 A9            [12] 2108 	add	a,#0xa9
      00081F FD               [12] 2109 	mov	r5,a
      000820 EA               [12] 2110 	mov	a,r2
      000821 34 FF            [12] 2111 	addc	a,#0xff
      000823 FB               [12] 2112 	mov	r3,a
      000824 80 16            [24] 2113 	sjmp	00176$
      000826                       2114 00167$:
                                   2115 ;	main.c:446: printf("Invalid input. Please enter 0-9, A-F or a-f.\r\n");
      000826 74r67            [12] 2116 	mov	a,#___str_15
      000828 C0 E0            [24] 2117 	push	acc
      00082A 74s02            [12] 2118 	mov	a,#(___str_15 >> 8)
      00082C C0 E0            [24] 2119 	push	acc
      00082E 74 80            [12] 2120 	mov	a,#0x80
      000830 C0 E0            [24] 2121 	push	acc
      000832 12r00r00         [24] 2122 	lcall	_printf
      000835 15 81            [12] 2123 	dec	sp
      000837 15 81            [12] 2124 	dec	sp
      000839 15 81            [12] 2125 	dec	sp
                                   2126 ;	main.c:447: return;
      00083B 22               [24] 2127 	ret
      00083C                       2128 00176$:
                                   2129 ;	main.c:449: start_addr = start_addr * 16 + digit;
      00083C AA*05            [24] 2130 	mov	r2,_main_start_addr_131072_92
      00083E E5*06            [12] 2131 	mov	a,(_main_start_addr_131072_92 + 1)
      000840 C4               [12] 2132 	swap	a
      000841 54 F0            [12] 2133 	anl	a,#0xf0
      000843 CA               [12] 2134 	xch	a,r2
      000844 C4               [12] 2135 	swap	a
      000845 CA               [12] 2136 	xch	a,r2
      000846 6A               [12] 2137 	xrl	a,r2
      000847 CA               [12] 2138 	xch	a,r2
      000848 54 F0            [12] 2139 	anl	a,#0xf0
      00084A CA               [12] 2140 	xch	a,r2
      00084B 6A               [12] 2141 	xrl	a,r2
      00084C FC               [12] 2142 	mov	r4,a
      00084D ED               [12] 2143 	mov	a,r5
      00084E 2A               [12] 2144 	add	a,r2
      00084F F5*05            [12] 2145 	mov	_main_start_addr_131072_92,a
      000851 EB               [12] 2146 	mov	a,r3
      000852 3C               [12] 2147 	addc	a,r4
      000853 F5*06            [12] 2148 	mov	(_main_start_addr_131072_92 + 1),a
      000855 02r07rD3         [24] 2149 	ljmp	00179$
      000858                       2150 00180$:
                                   2151 ;	main.c:453: printf("Entered start address: 0x%x\r\n", start_addr);
      000858 C0*05            [24] 2152 	push	_main_start_addr_131072_92
      00085A C0*06            [24] 2153 	push	(_main_start_addr_131072_92 + 1)
      00085C 74rCC            [12] 2154 	mov	a,#___str_18
      00085E C0 E0            [24] 2155 	push	acc
      000860 74s02            [12] 2156 	mov	a,#(___str_18 >> 8)
      000862 C0 E0            [24] 2157 	push	acc
      000864 74 80            [12] 2158 	mov	a,#0x80
      000866 C0 E0            [24] 2159 	push	acc
      000868 12r00r00         [24] 2160 	lcall	_printf
      00086B E5 81            [12] 2161 	mov	a,sp
      00086D 24 FB            [12] 2162 	add	a,#0xfb
      00086F F5 81            [12] 2163 	mov	sp,a
                                   2164 ;	main.c:456: if ((start_addr < 0x0) || (start_addr > 0x7FF)) {
      000871 C3               [12] 2165 	clr	c
      000872 74 FF            [12] 2166 	mov	a,#0xff
      000874 95*05            [12] 2167 	subb	a,_main_start_addr_131072_92
      000876 74 07            [12] 2168 	mov	a,#0x07
      000878 95*06            [12] 2169 	subb	a,(_main_start_addr_131072_92 + 1)
      00087A 50 16            [24] 2170 	jnc	00182$
                                   2171 ;	main.c:457: printf("Invalid start address. The address should be between 0 and 7FF.\r\n");
      00087C 74rEA            [12] 2172 	mov	a,#___str_19
      00087E C0 E0            [24] 2173 	push	acc
      000880 74s02            [12] 2174 	mov	a,#(___str_19 >> 8)
      000882 C0 E0            [24] 2175 	push	acc
      000884 74 80            [12] 2176 	mov	a,#0x80
      000886 C0 E0            [24] 2177 	push	acc
      000888 12r00r00         [24] 2178 	lcall	_printf
      00088B 15 81            [12] 2179 	dec	sp
      00088D 15 81            [12] 2180 	dec	sp
      00088F 15 81            [12] 2181 	dec	sp
                                   2182 ;	main.c:458: return;
      000891 22               [24] 2183 	ret
      000892                       2184 00182$:
                                   2185 ;	main.c:461: printf("Enter the end address for dump:\r\n");
      000892 74r2C            [12] 2186 	mov	a,#___str_20
      000894 C0 E0            [24] 2187 	push	acc
      000896 74s03            [12] 2188 	mov	a,#(___str_20 >> 8)
      000898 C0 E0            [24] 2189 	push	acc
      00089A 74 80            [12] 2190 	mov	a,#0x80
      00089C C0 E0            [24] 2191 	push	acc
      00089E 12r00r00         [24] 2192 	lcall	_printf
      0008A1 15 81            [12] 2193 	dec	sp
      0008A3 15 81            [12] 2194 	dec	sp
      0008A5 15 81            [12] 2195 	dec	sp
                                   2196 ;	main.c:462: while (1) {
      0008A7                       2197 00199$:
                                   2198 ;	main.c:463: ch = getchar();
      0008A7 12r00r00         [24] 2199 	lcall	_getchar
      0008AA AC 82            [24] 2200 	mov	r4,dpl
                                   2201 ;	main.c:465: if ((int)ch == 13) { // Check until carriage return
      0008AC 8C 03            [24] 2202 	mov	ar3,r4
      0008AE 7D 00            [12] 2203 	mov	r5,#0x00
      0008B0 BB 0D 05         [24] 2204 	cjne	r3,#0x0d,00533$
      0008B3 BD 00 02         [24] 2205 	cjne	r5,#0x00,00533$
      0008B6 80 6D            [24] 2206 	sjmp	00200$
      0008B8                       2207 00533$:
                                   2208 ;	main.c:469: if ((ch >= '0') && (ch <= '9')) {
      0008B8 BC 30 00         [24] 2209 	cjne	r4,#0x30,00534$
      0008BB                       2210 00534$:
      0008BB 40 0F            [24] 2211 	jc	00195$
      0008BD EC               [12] 2212 	mov	a,r4
      0008BE 24 C6            [12] 2213 	add	a,#0xff - 0x39
      0008C0 40 0A            [24] 2214 	jc	00195$
                                   2215 ;	main.c:470: digit = ch - '0';
      0008C2 EB               [12] 2216 	mov	a,r3
      0008C3 24 D0            [12] 2217 	add	a,#0xd0
      0008C5 FA               [12] 2218 	mov	r2,a
      0008C6 ED               [12] 2219 	mov	a,r5
      0008C7 34 FF            [12] 2220 	addc	a,#0xff
      0008C9 F9               [12] 2221 	mov	r1,a
      0008CA 80 3E            [24] 2222 	sjmp	00196$
      0008CC                       2223 00195$:
                                   2224 ;	main.c:471: } else if ((ch >= 'A') && (ch <= 'F')) {
      0008CC BC 41 00         [24] 2225 	cjne	r4,#0x41,00537$
      0008CF                       2226 00537$:
      0008CF 40 0F            [24] 2227 	jc	00191$
      0008D1 EC               [12] 2228 	mov	a,r4
      0008D2 24 B9            [12] 2229 	add	a,#0xff - 0x46
      0008D4 40 0A            [24] 2230 	jc	00191$
                                   2231 ;	main.c:472: digit = ch - 7 - '0';
      0008D6 EB               [12] 2232 	mov	a,r3
      0008D7 24 C9            [12] 2233 	add	a,#0xc9
      0008D9 FA               [12] 2234 	mov	r2,a
      0008DA ED               [12] 2235 	mov	a,r5
      0008DB 34 FF            [12] 2236 	addc	a,#0xff
      0008DD F9               [12] 2237 	mov	r1,a
      0008DE 80 2A            [24] 2238 	sjmp	00196$
      0008E0                       2239 00191$:
                                   2240 ;	main.c:473: } else if ((ch >= 'a') && (ch <= 'f')) {
      0008E0 BC 61 00         [24] 2241 	cjne	r4,#0x61,00540$
      0008E3                       2242 00540$:
      0008E3 40 0F            [24] 2243 	jc	00187$
      0008E5 EC               [12] 2244 	mov	a,r4
      0008E6 24 99            [12] 2245 	add	a,#0xff - 0x66
      0008E8 40 0A            [24] 2246 	jc	00187$
                                   2247 ;	main.c:474: digit = ch - 32 - 7 - '0';
      0008EA EB               [12] 2248 	mov	a,r3
      0008EB 24 A9            [12] 2249 	add	a,#0xa9
      0008ED FA               [12] 2250 	mov	r2,a
      0008EE ED               [12] 2251 	mov	a,r5
      0008EF 34 FF            [12] 2252 	addc	a,#0xff
      0008F1 F9               [12] 2253 	mov	r1,a
      0008F2 80 16            [24] 2254 	sjmp	00196$
      0008F4                       2255 00187$:
                                   2256 ;	main.c:476: printf("Invalid input. Please enter 0-9, A-F or a-f.\r\n");
      0008F4 74r67            [12] 2257 	mov	a,#___str_15
      0008F6 C0 E0            [24] 2258 	push	acc
      0008F8 74s02            [12] 2259 	mov	a,#(___str_15 >> 8)
      0008FA C0 E0            [24] 2260 	push	acc
      0008FC 74 80            [12] 2261 	mov	a,#0x80
      0008FE C0 E0            [24] 2262 	push	acc
      000900 12r00r00         [24] 2263 	lcall	_printf
      000903 15 81            [12] 2264 	dec	sp
      000905 15 81            [12] 2265 	dec	sp
      000907 15 81            [12] 2266 	dec	sp
                                   2267 ;	main.c:477: return;
      000909 22               [24] 2268 	ret
      00090A                       2269 00196$:
                                   2270 ;	main.c:479: end_addr = end_addr * 16 + digit;
      00090A AC*07            [24] 2271 	mov	r4,_main_end_addr_131072_92
      00090C E5*08            [12] 2272 	mov	a,(_main_end_addr_131072_92 + 1)
      00090E C4               [12] 2273 	swap	a
      00090F 54 F0            [12] 2274 	anl	a,#0xf0
      000911 CC               [12] 2275 	xch	a,r4
      000912 C4               [12] 2276 	swap	a
      000913 CC               [12] 2277 	xch	a,r4
      000914 6C               [12] 2278 	xrl	a,r4
      000915 CC               [12] 2279 	xch	a,r4
      000916 54 F0            [12] 2280 	anl	a,#0xf0
      000918 CC               [12] 2281 	xch	a,r4
      000919 6C               [12] 2282 	xrl	a,r4
      00091A FD               [12] 2283 	mov	r5,a
      00091B EA               [12] 2284 	mov	a,r2
      00091C 2C               [12] 2285 	add	a,r4
      00091D F5*07            [12] 2286 	mov	_main_end_addr_131072_92,a
      00091F E9               [12] 2287 	mov	a,r1
      000920 3D               [12] 2288 	addc	a,r5
      000921 F5*08            [12] 2289 	mov	(_main_end_addr_131072_92 + 1),a
      000923 80 82            [24] 2290 	sjmp	00199$
      000925                       2291 00200$:
                                   2292 ;	main.c:483: printf("Entered end address: 0x%x\r\n", end_addr);
      000925 C0*07            [24] 2293 	push	_main_end_addr_131072_92
      000927 C0*08            [24] 2294 	push	(_main_end_addr_131072_92 + 1)
      000929 74r4E            [12] 2295 	mov	a,#___str_21
      00092B C0 E0            [24] 2296 	push	acc
      00092D 74s03            [12] 2297 	mov	a,#(___str_21 >> 8)
      00092F C0 E0            [24] 2298 	push	acc
      000931 74 80            [12] 2299 	mov	a,#0x80
      000933 C0 E0            [24] 2300 	push	acc
      000935 12r00r00         [24] 2301 	lcall	_printf
      000938 E5 81            [12] 2302 	mov	a,sp
      00093A 24 FB            [12] 2303 	add	a,#0xfb
      00093C F5 81            [12] 2304 	mov	sp,a
                                   2305 ;	main.c:486: if ((end_addr < 0x0) || (end_addr > 0x7FF) || (end_addr < start_addr)) {
      00093E C3               [12] 2306 	clr	c
      00093F 74 FF            [12] 2307 	mov	a,#0xff
      000941 95*07            [12] 2308 	subb	a,_main_end_addr_131072_92
      000943 74 07            [12] 2309 	mov	a,#0x07
      000945 95*08            [12] 2310 	subb	a,(_main_end_addr_131072_92 + 1)
      000947 40 0A            [24] 2311 	jc	00201$
      000949 E5*07            [12] 2312 	mov	a,_main_end_addr_131072_92
      00094B 95*05            [12] 2313 	subb	a,_main_start_addr_131072_92
      00094D E5*08            [12] 2314 	mov	a,(_main_end_addr_131072_92 + 1)
      00094F 95*06            [12] 2315 	subb	a,(_main_start_addr_131072_92 + 1)
      000951 50 16            [24] 2316 	jnc	00202$
      000953                       2317 00201$:
                                   2318 ;	main.c:487: printf("Invalid end address. The address should be between 0-7FF and more than the start address.\r\n");
      000953 74r6A            [12] 2319 	mov	a,#___str_22
      000955 C0 E0            [24] 2320 	push	acc
      000957 74s03            [12] 2321 	mov	a,#(___str_22 >> 8)
      000959 C0 E0            [24] 2322 	push	acc
      00095B 74 80            [12] 2323 	mov	a,#0x80
      00095D C0 E0            [24] 2324 	push	acc
      00095F 12r00r00         [24] 2325 	lcall	_printf
      000962 15 81            [12] 2326 	dec	sp
      000964 15 81            [12] 2327 	dec	sp
      000966 15 81            [12] 2328 	dec	sp
                                   2329 ;	main.c:488: return;
      000968 22               [24] 2330 	ret
      000969                       2331 00202$:
                                   2332 ;	main.c:491: printf("%x:", start_addr);
      000969 C0*05            [24] 2333 	push	_main_start_addr_131072_92
      00096B C0*06            [24] 2334 	push	(_main_start_addr_131072_92 + 1)
      00096D 74rC6            [12] 2335 	mov	a,#___str_23
      00096F C0 E0            [24] 2336 	push	acc
      000971 74s03            [12] 2337 	mov	a,#(___str_23 >> 8)
      000973 C0 E0            [24] 2338 	push	acc
      000975 74 80            [12] 2339 	mov	a,#0x80
      000977 C0 E0            [24] 2340 	push	acc
      000979 12r00r00         [24] 2341 	lcall	_printf
      00097C E5 81            [12] 2342 	mov	a,sp
      00097E 24 FB            [12] 2343 	add	a,#0xfb
      000980 F5 81            [12] 2344 	mov	sp,a
                                   2345 ;	main.c:493: for (int i=0; i<end_addr - start_addr; i++)
      000982 E5*07            [12] 2346 	mov	a,_main_end_addr_131072_92
      000984 C3               [12] 2347 	clr	c
      000985 95*05            [12] 2348 	subb	a,_main_start_addr_131072_92
      000987 FC               [12] 2349 	mov	r4,a
      000988 E5*08            [12] 2350 	mov	a,(_main_end_addr_131072_92 + 1)
      00098A 95*06            [12] 2351 	subb	a,(_main_start_addr_131072_92 + 1)
      00098C FD               [12] 2352 	mov	r5,a
      00098D 85*05*01         [24] 2353 	mov	_main_addr_131072_92,_main_start_addr_131072_92
      000990 85*06*02         [24] 2354 	mov	(_main_addr_131072_92 + 1),(_main_start_addr_131072_92 + 1)
      000993 78 00            [12] 2355 	mov	r0,#0x00
      000995 79 00            [12] 2356 	mov	r1,#0x00
      000997                       2357 00215$:
      000997 88 02            [24] 2358 	mov	ar2,r0
      000999 89 03            [24] 2359 	mov	ar3,r1
      00099B C3               [12] 2360 	clr	c
      00099C EA               [12] 2361 	mov	a,r2
      00099D 9C               [12] 2362 	subb	a,r4
      00099E EB               [12] 2363 	mov	a,r3
      00099F 9D               [12] 2364 	subb	a,r5
      0009A0 40 03            [24] 2365 	jc	00545$
      0009A2 02r0Ar5D         [24] 2366 	ljmp	00272$
      0009A5                       2367 00545$:
                                   2368 ;	main.c:495: if (i > 0 && i % 16 == 0) {
      0009A5 C3               [12] 2369 	clr	c
      0009A6 E4               [12] 2370 	clr	a
      0009A7 98               [12] 2371 	subb	a,r0
      0009A8 74 80            [12] 2372 	mov	a,#(0x00 ^ 0x80)
      0009AA 89 F0            [24] 2373 	mov	b,r1
      0009AC 63 F0 80         [24] 2374 	xrl	b,#0x80
      0009AF 95 F0            [12] 2375 	subb	a,b
      0009B1 50 64            [24] 2376 	jnc	00206$
      0009B3 75*00 10         [24] 2377 	mov	__modsint_PARM_2,#0x10
      0009B6 75*01 00         [24] 2378 	mov	(__modsint_PARM_2 + 1),#0x00
      0009B9 88 82            [24] 2379 	mov	dpl,r0
      0009BB 89 83            [24] 2380 	mov	dph,r1
      0009BD C0 05            [24] 2381 	push	ar5
      0009BF C0 04            [24] 2382 	push	ar4
      0009C1 C0 01            [24] 2383 	push	ar1
      0009C3 C0 00            [24] 2384 	push	ar0
      0009C5 12r00r00         [24] 2385 	lcall	__modsint
      0009C8 E5 82            [12] 2386 	mov	a,dpl
      0009CA 85 83 F0         [24] 2387 	mov	b,dph
      0009CD D0 00            [24] 2388 	pop	ar0
      0009CF D0 01            [24] 2389 	pop	ar1
      0009D1 D0 04            [24] 2390 	pop	ar4
      0009D3 D0 05            [24] 2391 	pop	ar5
      0009D5 45 F0            [12] 2392 	orl	a,b
      0009D7 70 3E            [24] 2393 	jnz	00206$
                                   2394 ;	main.c:496: printf("\r\n");  // Start a new line after every 16 bytes
      0009D9 C0 05            [24] 2395 	push	ar5
      0009DB C0 04            [24] 2396 	push	ar4
      0009DD C0 01            [24] 2397 	push	ar1
      0009DF C0 00            [24] 2398 	push	ar0
      0009E1 74rF9            [12] 2399 	mov	a,#___str_6
      0009E3 C0 E0            [24] 2400 	push	acc
      0009E5 74s00            [12] 2401 	mov	a,#(___str_6 >> 8)
      0009E7 C0 E0            [24] 2402 	push	acc
      0009E9 74 80            [12] 2403 	mov	a,#0x80
      0009EB C0 E0            [24] 2404 	push	acc
      0009ED 12r00r00         [24] 2405 	lcall	_printf
      0009F0 15 81            [12] 2406 	dec	sp
      0009F2 15 81            [12] 2407 	dec	sp
      0009F4 15 81            [12] 2408 	dec	sp
                                   2409 ;	main.c:497: printf("%x:", addr);
      0009F6 C0*01            [24] 2410 	push	_main_addr_131072_92
      0009F8 C0*02            [24] 2411 	push	(_main_addr_131072_92 + 1)
      0009FA 74rC6            [12] 2412 	mov	a,#___str_23
      0009FC C0 E0            [24] 2413 	push	acc
      0009FE 74s03            [12] 2414 	mov	a,#(___str_23 >> 8)
      000A00 C0 E0            [24] 2415 	push	acc
      000A02 74 80            [12] 2416 	mov	a,#0x80
      000A04 C0 E0            [24] 2417 	push	acc
      000A06 12r00r00         [24] 2418 	lcall	_printf
      000A09 E5 81            [12] 2419 	mov	a,sp
      000A0B 24 FB            [12] 2420 	add	a,#0xfb
      000A0D F5 81            [12] 2421 	mov	sp,a
      000A0F D0 00            [24] 2422 	pop	ar0
      000A11 D0 01            [24] 2423 	pop	ar1
      000A13 D0 04            [24] 2424 	pop	ar4
      000A15 D0 05            [24] 2425 	pop	ar5
      000A17                       2426 00206$:
                                   2427 ;	main.c:499: printf("%x ", eebyter(addr));
      000A17 85*01 82         [24] 2428 	mov	dpl,_main_addr_131072_92
      000A1A 85*02 83         [24] 2429 	mov	dph,(_main_addr_131072_92 + 1)
      000A1D C0 05            [24] 2430 	push	ar5
      000A1F C0 04            [24] 2431 	push	ar4
      000A21 C0 01            [24] 2432 	push	ar1
      000A23 C0 00            [24] 2433 	push	ar0
      000A25 12r02r5E         [24] 2434 	lcall	_eebyter
      000A28 AB 82            [24] 2435 	mov	r3,dpl
      000A2A 7A 00            [12] 2436 	mov	r2,#0x00
      000A2C C0 03            [24] 2437 	push	ar3
      000A2E C0 02            [24] 2438 	push	ar2
      000A30 74rCA            [12] 2439 	mov	a,#___str_24
      000A32 C0 E0            [24] 2440 	push	acc
      000A34 74s03            [12] 2441 	mov	a,#(___str_24 >> 8)
      000A36 C0 E0            [24] 2442 	push	acc
      000A38 74 80            [12] 2443 	mov	a,#0x80
      000A3A C0 E0            [24] 2444 	push	acc
      000A3C 12r00r00         [24] 2445 	lcall	_printf
      000A3F E5 81            [12] 2446 	mov	a,sp
      000A41 24 FB            [12] 2447 	add	a,#0xfb
      000A43 F5 81            [12] 2448 	mov	sp,a
      000A45 D0 00            [24] 2449 	pop	ar0
      000A47 D0 01            [24] 2450 	pop	ar1
      000A49 D0 04            [24] 2451 	pop	ar4
      000A4B D0 05            [24] 2452 	pop	ar5
                                   2453 ;	main.c:500: addr += 1;
      000A4D 05*01            [12] 2454 	inc	_main_addr_131072_92
      000A4F E4               [12] 2455 	clr	a
      000A50 B5*01 02         [24] 2456 	cjne	a,_main_addr_131072_92,00548$
      000A53 05*02            [12] 2457 	inc	(_main_addr_131072_92 + 1)
      000A55                       2458 00548$:
                                   2459 ;	main.c:493: for (int i=0; i<end_addr - start_addr; i++)
      000A55 08               [12] 2460 	inc	r0
      000A56 B8 00 01         [24] 2461 	cjne	r0,#0x00,00549$
      000A59 09               [12] 2462 	inc	r1
      000A5A                       2463 00549$:
      000A5A 02r09r97         [24] 2464 	ljmp	00215$
      000A5D                       2465 00272$:
      000A5D AE*01            [24] 2466 	mov	r6,_main_addr_131072_92
      000A5F AF*02            [24] 2467 	mov	r7,(_main_addr_131072_92 + 1)
                                   2468 ;	main.c:502: printf("\r\n");
      000A61 C0 07            [24] 2469 	push	ar7
      000A63 C0 06            [24] 2470 	push	ar6
      000A65 74rF9            [12] 2471 	mov	a,#___str_6
      000A67 C0 E0            [24] 2472 	push	acc
      000A69 74s00            [12] 2473 	mov	a,#(___str_6 >> 8)
      000A6B C0 E0            [24] 2474 	push	acc
      000A6D 74 80            [12] 2475 	mov	a,#0x80
      000A6F C0 E0            [24] 2476 	push	acc
      000A71 12r00r00         [24] 2477 	lcall	_printf
      000A74 15 81            [12] 2478 	dec	sp
      000A76 15 81            [12] 2479 	dec	sp
      000A78 15 81            [12] 2480 	dec	sp
      000A7A D0 06            [24] 2481 	pop	ar6
      000A7C D0 07            [24] 2482 	pop	ar7
                                   2483 ;	main.c:504: break;
      000A7E 02r04r64         [24] 2484 	ljmp	00212$
                                   2485 ;	main.c:511: default:
      000A81                       2486 00209$:
                                   2487 ;	main.c:512: printf("Invalid input\r\n");
      000A81 C0 07            [24] 2488 	push	ar7
      000A83 C0 06            [24] 2489 	push	ar6
      000A85 74rCE            [12] 2490 	mov	a,#___str_25
      000A87 C0 E0            [24] 2491 	push	acc
      000A89 74s03            [12] 2492 	mov	a,#(___str_25 >> 8)
      000A8B C0 E0            [24] 2493 	push	acc
      000A8D 74 80            [12] 2494 	mov	a,#0x80
      000A8F C0 E0            [24] 2495 	push	acc
      000A91 12r00r00         [24] 2496 	lcall	_printf
      000A94 15 81            [12] 2497 	dec	sp
      000A96 15 81            [12] 2498 	dec	sp
      000A98 15 81            [12] 2499 	dec	sp
      000A9A D0 06            [24] 2500 	pop	ar6
      000A9C D0 07            [24] 2501 	pop	ar7
                                   2502 ;	main.c:515: }
                                   2503 ;	main.c:559: }
      000A9E 02r04r64         [24] 2504 	ljmp	00212$
                                   2505 	.area CSEG    (CODE)
                                   2506 	.area CONST   (CODE)
                                   2507 	.area CONST   (CODE)
      000000                       2508 ___str_0:
      000000 53 74 61 72 74 69 6E  2509 	.ascii "Starting I2C application"
             67 20 49 32 43 20 61
             70 70 6C 69 63 61 74
             69 6F 6E
      000018 0D                    2510 	.db 0x0d
      000019 0A                    2511 	.db 0x0a
      00001A 00                    2512 	.db 0x00
                                   2513 	.area CSEG    (CODE)
                                   2514 	.area CONST   (CODE)
      00001B                       2515 ___str_1:
      00001B 48 65 6C 70 20 6D 65  2516 	.ascii "Help menu:"
             6E 75 3A
      000025 0D                    2517 	.db 0x0d
      000026 0A                    2518 	.db 0x0a
      000027 00                    2519 	.db 0x00
                                   2520 	.area CSEG    (CODE)
                                   2521 	.area CONST   (CODE)
      000028                       2522 ___str_2:
      000028 27 77 27 3A 20 45 6E  2523 	.ascii "'w': Enter an EEPROM address in hex to write data at and byt"
             74 65 72 20 61 6E 20
             45 45 50 52 4F 4D 20
             61 64 64 72 65 73 73
             20 69 6E 20 68 65 78
             20 74 6F 20 77 72 69
             74 65 20 64 61 74 61
             20 61 74 20 61 6E 64
             20 62 79 74
      000064 65 20 64 61 74 61     2524 	.ascii "e data"
      00006A 0D                    2525 	.db 0x0d
      00006B 0A                    2526 	.db 0x0a
      00006C 00                    2527 	.db 0x00
                                   2528 	.area CSEG    (CODE)
                                   2529 	.area CONST   (CODE)
      00006D                       2530 ___str_3:
      00006D 27 72 27 3A 20 45 6E  2531 	.ascii "'r': Enter an EEPROM address in hex to read data from"
             74 65 72 20 61 6E 20
             45 45 50 52 4F 4D 20
             61 64 64 72 65 73 73
             20 69 6E 20 68 65 78
             20 74 6F 20 72 65 61
             64 20 64 61 74 61 20
             66 72 6F 6D
      0000A2 0D                    2532 	.db 0x0d
      0000A3 0A                    2533 	.db 0x0a
      0000A4 00                    2534 	.db 0x00
                                   2535 	.area CSEG    (CODE)
                                   2536 	.area CONST   (CODE)
      0000A5                       2537 ___str_4:
      0000A5 27 68 27 3A 20 45 6E  2538 	.ascii "'h': Enter an EEPROM start and end addresses to dump the dat"
             74 65 72 20 61 6E 20
             45 45 50 52 4F 4D 20
             73 74 61 72 74 20 61
             6E 64 20 65 6E 64 20
             61 64 64 72 65 73 73
             65 73 20 74 6F 20 64
             75 6D 70 20 74 68 65
             20 64 61 74
      0000E1 61                    2539 	.ascii "a"
      0000E2 0D                    2540 	.db 0x0d
      0000E3 0A                    2541 	.db 0x0a
      0000E4 00                    2542 	.db 0x00
                                   2543 	.area CSEG    (CODE)
                                   2544 	.area CONST   (CODE)
      0000E5                       2545 ___str_5:
      0000E5 27 65 27 3A 20 52 65  2546 	.ascii "'e': Reset EEPROM"
             73 65 74 20 45 45 50
             52 4F 4D
      0000F6 0D                    2547 	.db 0x0d
      0000F7 0A                    2548 	.db 0x0a
      0000F8 00                    2549 	.db 0x00
                                   2550 	.area CSEG    (CODE)
                                   2551 	.area CONST   (CODE)
      0000F9                       2552 ___str_6:
      0000F9 0D                    2553 	.db 0x0d
      0000FA 0A                    2554 	.db 0x0a
      0000FB 00                    2555 	.db 0x00
                                   2556 	.area CSEG    (CODE)
                                   2557 	.area CONST   (CODE)
      0000FC                       2558 ___str_7:
      0000FC 45 6E 74 65 72 20 74  2559 	.ascii "Enter the address location to store the data at : "
             68 65 20 61 64 64 72
             65 73 73 20 6C 6F 63
             61 74 69 6F 6E 20 74
             6F 20 73 74 6F 72 65
             20 74 68 65 20 64 61
             74 61 20 61 74 20 3A
             20
      00012E 0D                    2560 	.db 0x0d
      00012F 0A                    2561 	.db 0x0a
      000130 00                    2562 	.db 0x00
                                   2563 	.area CSEG    (CODE)
                                   2564 	.area CONST   (CODE)
      000131                       2565 ___str_8:
      000131 49 6E 76 61 6C 69 64  2566 	.ascii "Invalid input. Please enter 0-9, A-F or a-f only."
             20 69 6E 70 75 74 2E
             20 50 6C 65 61 73 65
             20 65 6E 74 65 72 20
             30 2D 39 2C 20 41 2D
             46 20 6F 72 20 61 2D
             66 20 6F 6E 6C 79 2E
      000162 0D                    2567 	.db 0x0d
      000163 0A                    2568 	.db 0x0a
      000164 00                    2569 	.db 0x00
                                   2570 	.area CSEG    (CODE)
                                   2571 	.area CONST   (CODE)
      000165                       2572 ___str_9:
      000165 45 6E 74 65 72 65 64  2573 	.ascii "Entered address: 0x%x"
             20 61 64 64 72 65 73
             73 3A 20 30 78 25 78
      00017A 0D                    2574 	.db 0x0d
      00017B 0A                    2575 	.db 0x0a
      00017C 00                    2576 	.db 0x00
                                   2577 	.area CSEG    (CODE)
                                   2578 	.area CONST   (CODE)
      00017D                       2579 ___str_10:
      00017D 49 6E 76 61 6C 69 64  2580 	.ascii "Invalid buffer address. The address should be between 0 and "
             20 62 75 66 66 65 72
             20 61 64 64 72 65 73
             73 2E 20 54 68 65 20
             61 64 64 72 65 73 73
             20 73 68 6F 75 6C 64
             20 62 65 20 62 65 74
             77 65 65 6E 20 30 20
             61 6E 64 20
      0001B9 37 46 46 2E           2581 	.ascii "7FF."
      0001BD 0D                    2582 	.db 0x0d
      0001BE 0A                    2583 	.db 0x0a
      0001BF 00                    2584 	.db 0x00
                                   2585 	.area CSEG    (CODE)
                                   2586 	.area CONST   (CODE)
      0001C0                       2587 ___str_11:
      0001C0 45 6E 74 65 72 20 74  2588 	.ascii "Enter the data byte to write:"
             68 65 20 64 61 74 61
             20 62 79 74 65 20 74
             6F 20 77 72 69 74 65
             3A
      0001DD 0D                    2589 	.db 0x0d
      0001DE 0A                    2590 	.db 0x0a
      0001DF 00                    2591 	.db 0x00
                                   2592 	.area CSEG    (CODE)
                                   2593 	.area CONST   (CODE)
      0001E0                       2594 ___str_12:
      0001E0 45 6E 74 65 72 65 64  2595 	.ascii "Entered data: 0x%x"
             20 64 61 74 61 3A 20
             30 78 25 78
      0001F2 0D                    2596 	.db 0x0d
      0001F3 0A                    2597 	.db 0x0a
      0001F4 00                    2598 	.db 0x00
                                   2599 	.area CSEG    (CODE)
                                   2600 	.area CONST   (CODE)
      0001F5                       2601 ___str_13:
      0001F5 49 6E 76 61 6C 69 64  2602 	.ascii "Invalid buffer data. The data should be between 0 and FF."
             20 62 75 66 66 65 72
             20 64 61 74 61 2E 20
             54 68 65 20 64 61 74
             61 20 73 68 6F 75 6C
             64 20 62 65 20 62 65
             74 77 65 65 6E 20 30
             20 61 6E 64 20 46 46
             2E
      00022E 0D                    2603 	.db 0x0d
      00022F 0A                    2604 	.db 0x0a
      000230 00                    2605 	.db 0x00
                                   2606 	.area CSEG    (CODE)
                                   2607 	.area CONST   (CODE)
      000231                       2608 ___str_14:
      000231 45 6E 74 65 72 20 74  2609 	.ascii "Enter the address location to read the data from : "
             68 65 20 61 64 64 72
             65 73 73 20 6C 6F 63
             61 74 69 6F 6E 20 74
             6F 20 72 65 61 64 20
             74 68 65 20 64 61 74
             61 20 66 72 6F 6D 20
             3A 20
      000264 0D                    2610 	.db 0x0d
      000265 0A                    2611 	.db 0x0a
      000266 00                    2612 	.db 0x00
                                   2613 	.area CSEG    (CODE)
                                   2614 	.area CONST   (CODE)
      000267                       2615 ___str_15:
      000267 49 6E 76 61 6C 69 64  2616 	.ascii "Invalid input. Please enter 0-9, A-F or a-f."
             20 69 6E 70 75 74 2E
             20 50 6C 65 61 73 65
             20 65 6E 74 65 72 20
             30 2D 39 2C 20 41 2D
             46 20 6F 72 20 61 2D
             66 2E
      000293 0D                    2617 	.db 0x0d
      000294 0A                    2618 	.db 0x0a
      000295 00                    2619 	.db 0x00
                                   2620 	.area CSEG    (CODE)
                                   2621 	.area CONST   (CODE)
      000296                       2622 ___str_16:
      000296 72 65 61 64 20 64 61  2623 	.ascii "read data: 0x%x"
             74 61 3A 20 30 78 25
             78
      0002A5 0D                    2624 	.db 0x0d
      0002A6 0A                    2625 	.db 0x0a
      0002A7 00                    2626 	.db 0x00
                                   2627 	.area CSEG    (CODE)
                                   2628 	.area CONST   (CODE)
      0002A8                       2629 ___str_17:
      0002A8 45 6E 74 65 72 20 74  2630 	.ascii "Enter the start address for dump:"
             68 65 20 73 74 61 72
             74 20 61 64 64 72 65
             73 73 20 66 6F 72 20
             64 75 6D 70 3A
      0002C9 0D                    2631 	.db 0x0d
      0002CA 0A                    2632 	.db 0x0a
      0002CB 00                    2633 	.db 0x00
                                   2634 	.area CSEG    (CODE)
                                   2635 	.area CONST   (CODE)
      0002CC                       2636 ___str_18:
      0002CC 45 6E 74 65 72 65 64  2637 	.ascii "Entered start address: 0x%x"
             20 73 74 61 72 74 20
             61 64 64 72 65 73 73
             3A 20 30 78 25 78
      0002E7 0D                    2638 	.db 0x0d
      0002E8 0A                    2639 	.db 0x0a
      0002E9 00                    2640 	.db 0x00
                                   2641 	.area CSEG    (CODE)
                                   2642 	.area CONST   (CODE)
      0002EA                       2643 ___str_19:
      0002EA 49 6E 76 61 6C 69 64  2644 	.ascii "Invalid start address. The address should be between 0 and 7"
             20 73 74 61 72 74 20
             61 64 64 72 65 73 73
             2E 20 54 68 65 20 61
             64 64 72 65 73 73 20
             73 68 6F 75 6C 64 20
             62 65 20 62 65 74 77
             65 65 6E 20 30 20 61
             6E 64 20 37
      000326 46 46 2E              2645 	.ascii "FF."
      000329 0D                    2646 	.db 0x0d
      00032A 0A                    2647 	.db 0x0a
      00032B 00                    2648 	.db 0x00
                                   2649 	.area CSEG    (CODE)
                                   2650 	.area CONST   (CODE)
      00032C                       2651 ___str_20:
      00032C 45 6E 74 65 72 20 74  2652 	.ascii "Enter the end address for dump:"
             68 65 20 65 6E 64 20
             61 64 64 72 65 73 73
             20 66 6F 72 20 64 75
             6D 70 3A
      00034B 0D                    2653 	.db 0x0d
      00034C 0A                    2654 	.db 0x0a
      00034D 00                    2655 	.db 0x00
                                   2656 	.area CSEG    (CODE)
                                   2657 	.area CONST   (CODE)
      00034E                       2658 ___str_21:
      00034E 45 6E 74 65 72 65 64  2659 	.ascii "Entered end address: 0x%x"
             20 65 6E 64 20 61 64
             64 72 65 73 73 3A 20
             30 78 25 78
      000367 0D                    2660 	.db 0x0d
      000368 0A                    2661 	.db 0x0a
      000369 00                    2662 	.db 0x00
                                   2663 	.area CSEG    (CODE)
                                   2664 	.area CONST   (CODE)
      00036A                       2665 ___str_22:
      00036A 49 6E 76 61 6C 69 64  2666 	.ascii "Invalid end address. The address should be between 0-7FF and"
             20 65 6E 64 20 61 64
             64 72 65 73 73 2E 20
             54 68 65 20 61 64 64
             72 65 73 73 20 73 68
             6F 75 6C 64 20 62 65
             20 62 65 74 77 65 65
             6E 20 30 2D 37 46 46
             20 61 6E 64
      0003A6 20 6D 6F 72 65 20 74  2667 	.ascii " more than the start address."
             68 61 6E 20 74 68 65
             20 73 74 61 72 74 20
             61 64 64 72 65 73 73
             2E
      0003C3 0D                    2668 	.db 0x0d
      0003C4 0A                    2669 	.db 0x0a
      0003C5 00                    2670 	.db 0x00
                                   2671 	.area CSEG    (CODE)
                                   2672 	.area CONST   (CODE)
      0003C6                       2673 ___str_23:
      0003C6 25 78 3A              2674 	.ascii "%x:"
      0003C9 00                    2675 	.db 0x00
                                   2676 	.area CSEG    (CODE)
                                   2677 	.area CONST   (CODE)
      0003CA                       2678 ___str_24:
      0003CA 25 78 20              2679 	.ascii "%x "
      0003CD 00                    2680 	.db 0x00
                                   2681 	.area CSEG    (CODE)
                                   2682 	.area CONST   (CODE)
      0003CE                       2683 ___str_25:
      0003CE 49 6E 76 61 6C 69 64  2684 	.ascii "Invalid input"
             20 69 6E 70 75 74
      0003DB 0D                    2685 	.db 0x0d
      0003DC 0A                    2686 	.db 0x0a
      0003DD 00                    2687 	.db 0x00
                                   2688 	.area CSEG    (CODE)
                                   2689 	.area XINIT   (CODE)
                                   2690 	.area CABS    (ABS,CODE)
